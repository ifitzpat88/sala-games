<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Energy Siege: Overload</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  canvas { display: block; }
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: flex-start;
    padding: 12px 20px; pointer-events: none; z-index: 10;
  }
  #hud > div { pointer-events: auto; }
  .hud-panel {
    background: rgba(0,0,0,0.75); border: 1px solid rgba(0,255,255,0.3);
    border-radius: 8px; padding: 10px 16px; color: #fff;
    font-size: 14px; backdrop-filter: blur(4px);
  }
  .hud-panel .label { color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
  .hud-panel .value { font-size: 22px; font-weight: bold; }
  .energy-val { color: #ffdd00; }
  .wave-val { color: #ff4444; }
  .hp-val { color: #44ff44; }

  /* Wave info bar at top center */
  #wave-info {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    pointer-events: none; z-index: 10; text-align: center;
    min-width: 260px;
  }
  #wave-info .wave-status {
    color: #aaa; font-size: 13px; margin-bottom: 6px;
  }
  #wave-info .wave-status span { color: #0ff; font-weight: bold; }
  #wave-progress-bg {
    width: 260px; height: 10px; background: rgba(255,255,255,0.08);
    border-radius: 5px; overflow: hidden; border: 1px solid rgba(255,68,68,0.3);
    margin: 0 auto;
  }
  #wave-progress-fill {
    height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ff8800);
    border-radius: 5px; transition: width 0.15s;
  }
  #between-wave-timer {
    color: #ffdd00; font-size: 16px; font-weight: bold; margin-top: 4px;
    visibility: hidden;
  }
  #between-wave-timer.show { visibility: visible; }

  #build-menu {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; z-index: 10;
  }
  .build-btn {
    background: rgba(0,0,0,0.8); border: 2px solid rgba(0,255,255,0.4);
    border-radius: 8px; padding: 10px 18px; color: #fff; cursor: pointer;
    font-size: 13px; transition: all 0.15s; user-select: none;
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    min-width: 90px;
  }
  .build-btn:hover { border-color: #0ff; background: rgba(0,255,255,0.1); }
  .build-btn.active { border-color: #0f0; background: rgba(0,255,0,0.15); box-shadow: 0 0 12px rgba(0,255,0,0.3); }
  .build-btn.disabled { opacity: 0.4; cursor: not-allowed; }
  .build-btn .cost { color: #ffdd00; font-size: 11px; }
  .build-btn .key { color: #888; font-size: 10px; }

  #wave-banner {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 48px; font-weight: bold; color: #ff4444;
    text-shadow: 0 0 20px rgba(255,0,0,0.5); pointer-events: none;
    opacity: 0; transition: opacity 0.3s; z-index: 20;
  }
  #wave-banner.show { opacity: 1; }
  #wave-banner .wave-subtitle {
    font-size: 16px; color: #ff8888; font-weight: normal; margin-top: 4px;
  }

  #game-over {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85); display: none; z-index: 100;
    justify-content: center; align-items: center; flex-direction: column;
  }
  #game-over.show { display: flex; }
  #game-over h1 { font-size: 56px; margin-bottom: 10px; }
  #game-over p { font-size: 20px; color: #aaa; margin-bottom: 30px; }
  #game-over button {
    background: rgba(0,255,255,0.15); border: 2px solid #0ff; color: #0ff;
    padding: 14px 40px; font-size: 18px; border-radius: 8px; cursor: pointer;
    transition: all 0.2s;
  }
  #game-over button:hover { background: rgba(0,255,255,0.3); }

  #story-screen {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(ellipse at center, #0a1a0a 0%, #000 70%);
    display: none; z-index: 100;
    justify-content: center; align-items: center; flex-direction: column;
    padding: 40px;
  }
  #story-screen.show { display: flex; }
  #story-screen h2 {
    font-size: 42px; color: #44ff44; margin-bottom: 24px;
    text-shadow: 0 0 30px rgba(0,255,0,0.5);
    animation: storyFadeIn 1.5s ease-out;
  }
  #story-text {
    max-width: 640px; text-align: center; color: #ccc; font-size: 17px;
    line-height: 1.8; margin-bottom: 28px; font-style: italic;
    animation: storyFadeIn 2.5s ease-out;
  }
  #story-stats {
    color: #888; font-size: 14px; margin-bottom: 32px;
    animation: storyFadeIn 3s ease-out;
  }
  #story-screen button {
    background: rgba(0,255,0,0.1); border: 2px solid #44ff44; color: #44ff44;
    padding: 14px 40px; font-size: 18px; border-radius: 8px; cursor: pointer;
    transition: all 0.2s; letter-spacing: 2px;
    animation: storyFadeIn 3.5s ease-out, storyPulse 2s ease-in-out infinite 3.5s;
  }
  #story-screen button:hover { background: rgba(0,255,0,0.25); transform: scale(1.05); }
  @keyframes storyFadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes storyPulse { 0%,100% { box-shadow: 0 0 8px rgba(0,255,0,0.3); } 50% { box-shadow: 0 0 20px rgba(0,255,0,0.6); } }

  #start-screen {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: #0a0a0a; display: flex; z-index: 200;
    justify-content: center; align-items: center; flex-direction: column;
  }
  #start-screen.hidden { display: none; }
  #start-screen h1 {
    font-size: 52px; color: #0ff; margin-bottom: 6px;
    text-shadow: 0 0 30px rgba(0,255,255,0.5);
  }
  #start-screen .subtitle { font-size: 20px; color: #ff4444; margin-bottom: 40px; letter-spacing: 4px; }
  #start-screen .controls {
    color: #888; font-size: 14px; line-height: 2; margin-bottom: 30px; text-align: center;
  }
  #start-screen .controls span { color: #0ff; }
  #start-screen button {
    background: rgba(0,255,255,0.1); border: 2px solid #0ff; color: #0ff;
    padding: 16px 50px; font-size: 20px; border-radius: 8px; cursor: pointer;
    transition: all 0.2s; letter-spacing: 2px;
  }
  #start-screen button:hover { background: rgba(0,255,255,0.25); transform: scale(1.05); }
  #start-screen .credit { position: absolute; bottom: 20px; color: #444; font-size: 12px; }

  /* Biome selector */
  .biome-selector {
    display: flex; gap: 10px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;
  }
  .biome-card {
    width: 100px; height: 80px; border: 2px solid rgba(255,255,255,0.15);
    border-radius: 8px; cursor: pointer; transition: all 0.2s; position: relative;
    display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
    padding-bottom: 6px; overflow: hidden;
  }
  .biome-card:hover { transform: scale(1.08); border-color: rgba(0,255,255,0.4); }
  .biome-card.selected {
    border-color: #0ff; box-shadow: 0 0 14px rgba(0,255,255,0.4);
  }
  .biome-card .biome-name {
    color: #fff; font-size: 11px; font-weight: bold; letter-spacing: 1px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8); z-index: 1;
  }
  .biome-card .biome-desc {
    color: #aaa; font-size: 9px; z-index: 1;
  }
  .biome-card svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  .biome-label { font-size: 13px; color: #888; margin-bottom: 8px; letter-spacing: 2px; text-transform: uppercase; }

  #dash-indicator {
    position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
    z-index: 10; pointer-events: none; text-align: center;
  }
  #dash-indicator .dash-label { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
  #dash-bar-bg {
    width: 120px; height: 8px; background: rgba(255,255,255,0.1);
    border-radius: 4px; overflow: hidden; border: 1px solid rgba(0,255,255,0.2);
  }
  #dash-bar-fill {
    height: 100%; width: 100%; background: #0ff; border-radius: 4px;
    transition: width 0.05s linear;
    box-shadow: 0 0 6px rgba(0,255,255,0.5);
  }
  #dash-bar-fill.on-cooldown { background: #555; box-shadow: none; }

  #boss-bar {
    position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
    width: 340px; z-index: 15; text-align: center; display: none;
  }
  #boss-bar.show { display: block; }
  #boss-bar .boss-name { color: #ff4444; font-size: 14px; font-weight: bold; letter-spacing: 2px; margin-bottom: 4px; text-shadow: 0 0 10px rgba(255,0,0,0.5); }
  #boss-bar-bg { width: 100%; height: 14px; background: rgba(0,0,0,0.7); border-radius: 7px; border: 1px solid rgba(255,68,68,0.5); overflow: hidden; }
  #boss-bar-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #ff2222, #ff6600); border-radius: 7px; transition: width 0.1s; }

  #endless-timer {
    position: fixed; top: 12px; right: 20px; z-index: 15;
    color: #ff4444; font-size: 28px; font-weight: bold; display: none;
    text-shadow: 0 0 15px rgba(255,0,0,0.5); font-family: monospace;
  }
  #endless-timer.show { display: block; }

  #score-display {
    position: fixed; bottom: 60px; right: 20px; z-index: 10;
    color: #aaa; font-size: 12px; text-align: right; pointer-events: none;
  }

  /* Co-op UI */
  .coop-btns { margin-top: 16px; display: flex; gap: 12px; align-items: center; flex-direction: column; }
  .coop-btns button {
    background: rgba(0,255,100,0.1); border: 2px solid #0f8; color: #0f8;
    padding: 10px 30px; font-size: 16px; border-radius: 8px; cursor: pointer;
    transition: all 0.2s; letter-spacing: 1px;
  }
  .coop-btns button:hover { background: rgba(0,255,100,0.25); transform: scale(1.05); }
  .join-row { display: flex; gap: 8px; align-items: center; }
  .join-row input {
    background: rgba(255,255,255,0.08); border: 2px solid #0f8; color: #fff;
    padding: 10px 14px; font-size: 16px; border-radius: 8px; width: 140px;
    text-align: center; letter-spacing: 3px; text-transform: uppercase;
    font-family: monospace;
  }
  .join-row input::placeholder { color: #555; letter-spacing: 1px; font-family: inherit; }

  #lobby-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.92); display: none; z-index: 250;
    justify-content: center; align-items: center; flex-direction: column;
  }
  #lobby-overlay.show { display: flex; }
  #lobby-overlay h2 { color: #0f8; font-size: 32px; margin-bottom: 10px; }
  #lobby-overlay .room-code {
    font-size: 48px; color: #fff; letter-spacing: 8px; font-family: monospace;
    margin: 16px 0; text-shadow: 0 0 20px rgba(0,255,136,0.4);
  }
  #lobby-overlay .lobby-status { color: #aaa; font-size: 16px; margin: 10px 0; }
  #lobby-overlay .lobby-btns { display: flex; gap: 12px; margin-top: 20px; }
  #lobby-overlay .lobby-btns button {
    padding: 12px 30px; font-size: 16px; border-radius: 8px; cursor: pointer;
    transition: all 0.2s;
  }
  .lobby-start-btn {
    background: rgba(0,255,100,0.15); border: 2px solid #0f8; color: #0f8;
  }
  .lobby-start-btn:hover { background: rgba(0,255,100,0.3); }
  .lobby-start-btn:disabled { opacity: 0.3; cursor: not-allowed; }
  .lobby-cancel-btn {
    background: rgba(255,68,68,0.15); border: 2px solid #f44; color: #f44;
  }
  .lobby-cancel-btn:hover { background: rgba(255,68,68,0.3); }

  #coop-badge {
    position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
    z-index: 10; pointer-events: none; display: none;
    background: rgba(0,255,100,0.15); border: 1px solid rgba(0,255,100,0.4);
    border-radius: 6px; padding: 4px 14px; color: #0f8; font-size: 12px;
    font-weight: bold; letter-spacing: 2px;
  }
  #coop-badge.show { display: block; }

  #disconnect-toast {
    position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
    z-index: 300; display: none; background: rgba(255,68,68,0.9);
    border-radius: 8px; padding: 12px 24px; color: #fff; font-size: 16px;
    font-weight: bold;
  }
  #disconnect-toast.show { display: block; }
</style>
</head>
<body>

<div id="start-screen">
  <h1>ENERGY SIEGE</h1>
  <div class="subtitle">O V E R L O A D</div>
  <div class="controls">
    <span>WASD</span> Move &nbsp;|&nbsp; <span>Mouse</span> Aim &nbsp;|&nbsp; <span>Click</span> Shoot (Semi-Auto)<br>
    <span>SPACE</span> Dash &nbsp;|&nbsp; <span>1</span> Wall (15E) &nbsp;|&nbsp; <span>2</span> Generator (40E)<br>
    <span>3</span> Turret (30E) &nbsp;|&nbsp; <span>4</span> Laser Tower (50E) &nbsp;|&nbsp; <span>5</span> Barracks (60E) &nbsp;|&nbsp; <span>6</span> Catapult (75E)<br>
    <span>Left Click</span> Place Building &nbsp;|&nbsp; <span>Right Click</span> Upgrade Building &nbsp;|&nbsp; <span>R</span> Repair Building<br>
    <span>Q</span> Airstrike (60E) &nbsp;|&nbsp; <span>ESC</span> Pause / Cancel Build<br>
    Survive <span style="color:#ff4444">10 Waves + Bosses</span> then face the <span style="color:#ff4444">Endless Siege</span><br>
    Collect <span style="color:#ffdd00">Energy Orbs</span> &bull; Build defenses &bull; <span style="color:#44ff44">Upgrade between waves</span>
  </div>
  <div class="biome-label">MAP THEME</div>
  <div class="biome-selector" id="biome-selector"></div>
  <button onclick="startGame()">START GAME</button>
  <div class="coop-btns">
    <button onclick="hostGame()">HOST CO-OP</button>
    <div class="join-row">
      <input type="text" id="join-code-input" maxlength="6" placeholder="CODE" />
      <button onclick="joinGame()">JOIN</button>
    </div>
  </div>
  <div class="credit">Designed by Cash &nbsp;|&nbsp; <span id="version-display"></span></div>
</div>

<div id="lobby-overlay">
  <h2 id="lobby-title">CO-OP LOBBY</h2>
  <div class="room-code" id="lobby-room-code"></div>
  <div class="lobby-status" id="lobby-status">Waiting for player...</div>
  <div class="lobby-btns">
    <button class="lobby-start-btn" id="lobby-start-btn" onclick="startCoopGame()" disabled>START</button>
    <button class="lobby-cancel-btn" onclick="cancelLobby()">CANCEL</button>
  </div>
</div>

<div id="coop-badge">CO-OP</div>
<div id="disconnect-toast">Player 2 disconnected</div>

<div id="hud">
  <div class="hud-panel">
    <div class="label">Energy</div>
    <div class="value energy-val" id="energy-display">0</div>
  </div>
  <div class="hud-panel" style="text-align:center">
    <div class="label">Wave</div>
    <div class="value wave-val" id="wave-display">0 / 10</div>
  </div>
  <div class="hud-panel" style="text-align:right">
    <div class="label">HP</div>
    <div class="value hp-val" id="hp-display">100</div>
  </div>
</div>

<div id="wave-info">
  <div class="wave-status" id="wave-status-text"></div>
  <div id="wave-progress-bg"><div id="wave-progress-fill"></div></div>
  <div id="between-wave-timer"></div>
</div>

<div id="build-menu">
  <div class="build-btn" data-type="wall" onclick="selectBuild('wall')">
    <div>Wall</div>
    <div class="cost">15 E</div>
    <div class="key">[1]</div>
  </div>
  <div class="build-btn" data-type="generator" onclick="selectBuild('generator')">
    <div>Generator</div>
    <div class="cost">40 E</div>
    <div class="key">[2]</div>
  </div>
  <div class="build-btn" data-type="turret" onclick="selectBuild('turret')">
    <div>Turret</div>
    <div class="cost">30 E</div>
    <div class="key">[3]</div>
  </div>
  <div class="build-btn" data-type="laser" onclick="selectBuild('laser')">
    <div>Laser</div>
    <div class="cost">50 E</div>
    <div class="key">[4]</div>
  </div>
  <div class="build-btn" data-type="barracks" onclick="selectBuild('barracks')">
    <div>Barracks</div>
    <div class="cost">60 E</div>
    <div class="key">[5]</div>
  </div>
  <div class="build-btn" data-type="catapult" onclick="selectBuild('catapult')">
    <div>Catapult</div>
    <div class="cost">75 E</div>
    <div class="key">[6]</div>
  </div>
</div>

<div id="dash-indicator">
  <div class="dash-label">Dash [SPACE]</div>
  <div id="dash-bar-bg"><div id="dash-bar-fill"></div></div>
</div>

<div id="wave-banner"></div>

<div id="boss-bar">
  <div class="boss-name" id="boss-name-text">BOSS</div>
  <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
</div>

<div id="endless-timer">00:00</div>
<div id="score-display"></div>

<div id="game-over">
  <h1 id="go-title">OVERLOADED</h1>
  <p id="go-stats">You survived 0 waves</p>
  <button onclick="restartGame()">PLAY AGAIN</button>
</div>

<div id="story-screen">
  <h2>SIEGE BROKEN</h2>
  <div id="story-text"></div>
  <div id="story-stats"></div>
  <button onclick="continueToEndless()">ENTER THE ENDLESS SIEGE</button>
</div>

<canvas id="game"></canvas>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
// ============================================================
// ENERGY SIEGE: OVERLOAD — Designed by Cash
// ============================================================
const GAME_VERSION = 'v1.3.0';

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ---- Constants ----
const TILE = 40;
const MAP_W = 100;
const MAP_H = 100;
const WORLD_W = MAP_W * TILE;
const WORLD_H = MAP_H * TILE;
const PLAYER_R = 16;
const PLAYER_SPEED = 3.2;
const BULLET_SPEED = 10;
const BULLET_R = 4;
const BULLET_LIFE = 80;
const PLAYER_FIRE_COOLDOWN = 10; // Semi-auto: min frames between shots
const PLAYER_BULLET_DMG = 18; // Higher damage per shot for semi-auto
const DRONE_R = 8;
const DRONE_ORBIT = 50;
const DRONE_FIRE_RATE = 20;
const DRONE_RANGE = 280;
const ENEMY_BASE_SPEED = 1.2;
const ENERGY_ORB_R = 8;
const BUILD_SIZE = TILE;
const TURRET_RANGE = 240;
const TURRET_FIRE_RATE = 30;
const TURRET_BULLET_SPEED = 8;
const LASER_RANGE = 300;
const LASER_DPS = 0.6;

const DASH_SPEED = 12;
const DASH_DURATION = 8;
const DASH_COOLDOWN = 150;

const MAX_WAVES = 10;
const BETWEEN_WAVE_SECONDS = 10;
const BETWEEN_WAVE_FAST = 4;
const FRENZY_TIME = 600; // frames before enemies go frenzy (10s)
const FRENZY_SPEED_MULT = 1.4;
const FRENZY_DMG_MULT = 1.3;
const MINE_ARM_TIME = 120;
const MINE_LIFETIME = 900;
const MINE_RADIUS = 55;
const MINE_DAMAGE = 25;
const CHARGER_WINDUP = 60;
const CHARGER_SPEED = 8;
const CHARGER_STUN = 120;
const LASER_E_RANGE = 260;
const LASER_E_CHARGE = 90;
const LASER_E_FIRE = 60;
const LASER_E_DPS = 0.8;
const LASER_E_COOLDOWN = 180;

const HEAT_RADIUS = 100;
const HEAT_DPS = 0.5;

const BARRACKS_SPAWN_RATE = 300;
const BARRACKS_MAX_MEN = 2;
const SPACEMAN_HP = 35;
const SPACEMAN_SPEED = 2.2;
const SPACEMAN_DMG = 8;
const SPACEMAN_ATTACK_CD = 35;
const SPACEMAN_R = 7;

// ---- Biome / Map Theme System ----
let currentBiome = 'moon';
const BIOMES = {
  moon: {
    name: 'Moon', desc: 'Lunar surface',
    bgFill: '#111', gridStroke: 'rgba(255,255,255,0.04)',
    rockFill: '#2a2a2a', rockStroke: '#3a3a3a', rockDetail: '#333',
    lakeFill: 'rgba(30,80,160,0.6)', lakeShimmerBase: [80, 150, 255],
    minimapBg: '#0a0a0a', minimapRock: '#333', minimapLake: 'rgba(30,80,160,0.5)',
    previewBg: '#111', previewAccent: '#3a3a3a',
    decorateRock: null,
    decorateLake: null,
  },
  safari: {
    name: 'Safari', desc: 'African savanna',
    bgFill: '#2a2210', gridStroke: 'rgba(200,180,120,0.05)',
    rockFill: '#5c4a2e', rockStroke: '#7a6340', rockDetail: '#6b5535',
    lakeFill: 'rgba(60,120,50,0.6)', lakeShimmerBase: [90, 160, 70],
    minimapBg: '#1a1808', minimapRock: '#5c4a2e', minimapLake: 'rgba(60,120,50,0.5)',
    previewBg: '#2a2210', previewAccent: '#5c4a2e',
    decorateRock(ctx, x, y, TILE, fc) {
      // Grass tufts swaying near rocks
      ctx.strokeStyle = 'rgba(140,160,50,0.6)';
      ctx.lineWidth = 1.5;
      const sway = Math.sin(fc * 0.04 + x * 0.2) * 3;
      for (let i = 0; i < 3; i++) {
        const bx = x - 4 + i * (TILE / 2 + 4);
        const by = y + TILE + 1;
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.quadraticCurveTo(bx + sway, by - 10, bx + sway + 2, by - 14);
        ctx.stroke();
      }
    },
    decorateLake: null,
  },
  sky: {
    name: 'Sky', desc: 'Aerial platforms',
    bgFill: '#1a2a44', gridStroke: 'rgba(180,200,255,0.04)',
    rockFill: '#ccd8e8', rockStroke: '#dde6f0', rockDetail: '#b8c8dc',
    lakeFill: 'rgba(100,180,255,0.5)', lakeShimmerBase: [160, 210, 255],
    minimapBg: '#101828', minimapRock: '#ccd8e8', minimapLake: 'rgba(100,180,255,0.4)',
    previewBg: '#1a2a44', previewAccent: '#ccd8e8',
    decorateRock(ctx, x, y, TILE, fc) {
      // Cloud wisps drifting on rock platforms
      const drift = Math.sin(fc * 0.015 + x * 0.05) * 6;
      ctx.fillStyle = 'rgba(220,230,255,0.15)';
      ctx.beginPath();
      ctx.arc(x + 10 + drift, y + 12, 8, 0, Math.PI * 2);
      ctx.arc(x + 22 + drift, y + 10, 10, 0, Math.PI * 2);
      ctx.arc(x + 32 + drift, y + 14, 7, 0, Math.PI * 2);
      ctx.fill();
    },
    decorateLake: null,
  },
  plains: {
    name: 'Plains', desc: 'Grassland',
    bgFill: '#1a2a12', gridStroke: 'rgba(100,160,80,0.04)',
    rockFill: '#5a5a50', rockStroke: '#6a6a60', rockDetail: '#505048',
    lakeFill: 'rgba(40,100,180,0.6)', lakeShimmerBase: [70, 140, 220],
    minimapBg: '#0e1a08', minimapRock: '#5a5a50', minimapLake: 'rgba(40,100,180,0.5)',
    previewBg: '#1a2a12', previewAccent: '#5a5a50',
    decorateRock(ctx, x, y, TILE, fc) {
      // Moss patches on rocks
      ctx.fillStyle = 'rgba(60,120,40,0.45)';
      ctx.fillRect(x + 3, y + TILE - 10, 12, 6);
      ctx.fillRect(x + TILE - 16, y + 4, 10, 5);
    },
    decorateLake(ctx, x, y, TILE, fc) {
      // Lily pad dots on lakes
      ctx.fillStyle = 'rgba(50,140,50,0.5)';
      const bob = Math.sin(fc * 0.025 + x * 0.3) * 1.5;
      ctx.beginPath(); ctx.arc(x + 12, y + 14 + bob, 4, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 28, y + 26 + bob, 3, 0, Math.PI * 2); ctx.fill();
    },
  },
  beach: {
    name: 'Beach', desc: 'Tropical coast',
    bgFill: '#2a2418', gridStroke: 'rgba(200,180,140,0.04)',
    rockFill: '#c2a86e', rockStroke: '#d4bc82', rockDetail: '#b09858',
    lakeFill: 'rgba(30,160,180,0.6)', lakeShimmerBase: [80, 200, 220],
    minimapBg: '#1a1810', minimapRock: '#c2a86e', minimapLake: 'rgba(30,160,180,0.5)',
    previewBg: '#2a2418', previewAccent: '#c2a86e',
    decorateRock(ctx, x, y, TILE, fc) {
      // Sand grain scatter on rocks
      ctx.fillStyle = 'rgba(220,200,150,0.3)';
      for (let i = 0; i < 6; i++) {
        const gx = x + 5 + ((i * 17 + x) % (TILE - 10));
        const gy = y + 4 + ((i * 13 + y) % (TILE - 8));
        ctx.fillRect(gx, gy, 2, 2);
      }
    },
    decorateLake(ctx, x, y, TILE, fc) {
      // Foam edge on water
      const foam = Math.sin(fc * 0.03 + x * 0.15) * 0.15 + 0.3;
      ctx.fillStyle = `rgba(240,248,255,${foam})`;
      ctx.fillRect(x + 2, y + 2, TILE - 4, 3);
      ctx.fillRect(x + 2, y + TILE - 5, TILE - 4, 3);
    },
  },
  dystopia: {
    name: 'Dystopia', desc: 'Ruined city',
    bgFill: '#1a1a18', gridStroke: 'rgba(160,160,140,0.04)',
    rockFill: '#4a4a42', rockStroke: '#5a5a52', rockDetail: '#3a3a34',
    lakeFill: 'rgba(60,80,40,0.6)', lakeShimmerBase: [80, 100, 60],
    minimapBg: '#101010', minimapRock: '#4a4a42', minimapLake: 'rgba(60,80,40,0.5)',
    previewBg: '#1a1a18', previewAccent: '#4a4a42',
    decorateRock(ctx, x, y, TILE, fc) {
      // Cracked lines on ruined concrete
      ctx.strokeStyle = 'rgba(90,90,80,0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 4, y + 8); ctx.lineTo(x + 18, y + 20); ctx.lineTo(x + 12, y + TILE - 4);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + TILE - 6, y + 5); ctx.lineTo(x + 22, y + 16);
      ctx.stroke();
      // Rebar stubs
      ctx.fillStyle = 'rgba(140,80,50,0.5)';
      ctx.fillRect(x + TILE - 8, y + TILE - 10, 3, 8);
      ctx.fillRect(x + 6, y + 2, 2, 6);
    },
    decorateLake(ctx, x, y, TILE, fc) {
      // Toxic bubbles floating up
      ctx.fillStyle = 'rgba(120,140,60,0.4)';
      const b1 = Math.sin(fc * 0.04 + x * 0.2) * 3;
      const b2 = Math.cos(fc * 0.03 + y * 0.15) * 2;
      ctx.beginPath(); ctx.arc(x + 12 + b1, y + 18 + b2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 28 + b2, y + 10 - b1, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 20 - b1, y + 30 + b2, 2.5, 0, Math.PI * 2); ctx.fill();
    },
  },
  forest: {
    name: 'Forest', desc: 'Deep woods',
    bgFill: '#0e1a0a',
    gridStroke: 'rgba(60,120,40,0.04)',
    rockFill: '#3a2a1a',
    rockStroke: '#4a3a2a',
    rockDetail: '#2a6a1a',
    lakeFill: 'rgba(80,140,60,0.5)',
    lakeShimmerBase: [90, 160, 70],
    minimapBg: '#0a120a',
    minimapRock: '#2a5a1a',
    minimapLake: 'rgba(80,140,60,0.4)',
    previewBg: '#0e1a0a',
    previewAccent: '#2a5a1a',
    noRocks: true,
    decorateRock: null,
    decorateLake(ctx, x, y, TILE, fc) {
      // Wildflower dots in grass clearings
      const colors = ['#cc4466','#ddaa33','#aa66cc','#44aadd'];
      for (let i = 0; i < 4; i++) {
        const fx = x + 6 + ((i * 23 + x) % (TILE - 12));
        const fy = y + 6 + ((i * 17 + y) % (TILE - 12));
        ctx.fillStyle = colors[i];
        ctx.beginPath(); ctx.arc(fx, fy, 1.5, 0, Math.PI * 2); ctx.fill();
      }
    },
  },
};

const COSTS = { wall: 15, generator: 40, turret: 30, laser: 50, barracks: 60, catapult: 75 };
const BUILD_HP = { wall: 120, generator: 80, turret: 100, laser: 90, barracks: 100, catapult: 90 };
const BUILD_MAX_LEVEL = 3;
const BUILD_UPGRADE_COST = {
  wall: [10, 20], generator: [25, 45], turret: [20, 35], laser: [30, 50], barracks: [35, 55], catapult: [40, 65]
};
const CATAPULT_RANGE = 350;
const CATAPULT_FIRE_RATE = 180;
const CATAPULT_BLAST_RADIUS = 160;
const CATAPULT_DAMAGE = 40;

// Upgrade definitions: [name, description, maxLevel, statPerLevel]
const UPGRADE_DEFS = [
  { name: 'Max HP', key: 'maxHp', max: 5, per: 15, icon: '+' },
  { name: 'Speed', key: 'speed', max: 5, per: 0.5, icon: '>' },
  { name: 'Damage', key: 'damage', max: 5, per: 6, icon: '!' },
  { name: 'Drone Rate', key: 'droneRate', max: 5, per: 3, icon: 'D' },
  { name: 'Dash CD', key: 'dashCD', max: 5, per: 20, icon: '~' },
  { name: 'Squad', key: 'squad', max: 5, per: 1, icon: 'S' },
];
const UPGRADE_COSTS = [6, 12, 20, 30, 44];

// Boss definitions
const BOSS_DEFS = {
  sentinel: { name: 'THE SENTINEL', hp: 300, size: 34, speed: 1.1, dmg: 18, color: '#cc4400', chargeCD: 180 },
  warden: { name: 'THE WARDEN', hp: 600, size: 44, speed: 0.85, dmg: 22, color: '#8800cc', summonCD: 300 },
  overlord: { name: 'THE OVERLORD', hp: 1200, size: 52, speed: 0.9, dmg: 28, color: '#0044cc', shootCD: 120, summonCD: 360 },
  core: { name: 'THE OVERLOAD CORE', hp: 2800, size: 62, speed: 0.75, dmg: 38, color: '#880000', shootCD: 90, summonCD: 240 },
};

// Wave config — 25% harder + enemy types + boss flags
const WAVE_CONFIG = [
  { count: 8,  hpMult: 1.25, speedMult: 1.1, dmgMult: 1.25, spawnRate: 38, sizeMin: 12, sizeMax: 16,
    name: 'Scouts', types: ['normal'], boss: 'sentinel' },
  { count: 13, hpMult: 1.5, speedMult: 1.15, dmgMult: 1.25, spawnRate: 32, sizeMin: 13, sizeMax: 17,
    name: 'Patrol', types: ['normal'], boss: null },
  { count: 18, hpMult: 1.9, speedMult: 1.2, dmgMult: 1.5, spawnRate: 28, sizeMin: 13, sizeMax: 18,
    name: 'Assault Squad', types: ['normal','laser'], boss: 'warden' },
  { count: 25, hpMult: 2.25, speedMult: 1.3, dmgMult: 1.6, spawnRate: 23, sizeMin: 14, sizeMax: 19,
    name: 'Siege Force', types: ['normal','laser','miner'], boss: null },
  { count: 33, hpMult: 2.75, speedMult: 1.35, dmgMult: 1.9, spawnRate: 18, sizeMin: 14, sizeMax: 20,
    name: 'Heavy Armor', types: ['normal','laser','miner','charger','heat'], boss: null },
  { count: 40, hpMult: 3.4, speedMult: 1.45, dmgMult: 2.1, spawnRate: 16, sizeMin: 15, sizeMax: 21,
    name: 'Blitz Swarm', types: ['normal','charger','splitter','heat'], boss: null },
  { count: 50, hpMult: 4.0, speedMult: 1.5, dmgMult: 2.5, spawnRate: 13, sizeMin: 15, sizeMax: 22,
    name: 'War Party', types: ['normal','laser','miner','charger','splitter','heat'], boss: 'overlord' },
  { count: 60, hpMult: 4.8, speedMult: 1.6, dmgMult: 2.9, spawnRate: 10, sizeMin: 16, sizeMax: 23,
    name: 'Death March', types: ['normal','laser','charger','splitter','heat'], boss: null },
  { count: 73, hpMult: 5.6, speedMult: 1.7, dmgMult: 3.4, spawnRate: 8, sizeMin: 16, sizeMax: 24,
    name: 'Annihilation', types: ['normal','laser','miner','charger','splitter','heat'], boss: null },
  { count: 94, hpMult: 7.5, speedMult: 1.85, dmgMult: 4.0, spawnRate: 5, sizeMin: 18, sizeMax: 28,
    name: 'O V E R L O A D', types: ['normal','laser','miner','charger','splitter','heat'], boss: 'core' },
];

// ---- State ----
let W, H;
let camera = { x: 0, y: 0 };
let keys = {};
let mouse = { x: 0, y: 0, clicked: false }; // clicked = single click flag for semi-auto
let worldMouseX = 0, worldMouseY = 0;
let gameRunning = false;
let gameOverShown = false;
let victoryShown = false;

// Initialize arrays so draw() never crashes before initGame()
let player = { x: 0, y: 0, hp: 100, maxHp: 100, angle: 0 };
let drone = { x: 0, y: 0 };
let bullets = [];
let enemies = [];
let buildings = [];
let orbs = [];
let particles = [];
let obstacles = [];
let spacemen = [];
let catapultBoulders = [];
let activePlanes = [];
let napalmFires = [];
let planeCooldownTimer = 0;
let planeWeaponSelect = false;
let planeTargetingWeapon = null; // non-null = player is choosing where to strike
const PLANE_COST = 60;
const PLANE_COOLDOWN = 900;
let energy = 0, wave = 0;
let waveBannerTimer = 0, selectedBuild = null, droneAngle = 0, playerFireCD = 0, droneFireCD = 0;
let generatorTimer = 0, frameCount = 0;
let dashTimer = 0, dashCooldown = 0, dashDX = 0, dashDY = 0;

// Wave state machine: 'pre','countdown','active','cleared','victory','upgrades','endless'
let wavePhase = 'pre';
let betweenTimer = 0, enemiesSpawned = 0, totalWaveEnemies = 0, spawnTimer = 0, waveKills = 0;

// New systems
let mines = [];
let shockwaves = [];
let activeBoss = null;
let bossSpawned = false;
let gamePaused = false;
let totalKills = 0;
let upgradePoints = 0;
let showingUpgrades = false;
let playerUpgrades = { maxHp: 0, speed: 0, damage: 0, droneRate: 0, dashCD: 0, squad: 0 };
let endlessMode = false;
let endlessTimer = 0;
let endlessLevel = 0;
let endlessBossTimer = 0;
let highScore = parseInt(localStorage.getItem('energySiegeHighScore') || '0');

// ---- Multiplayer State ----
let isCoop = false, isHost = false, isClient = false;
let peer = null, conn = null, roomCode = '';
let player2 = null, drone2 = null, droneAngle2 = 0, droneFireCD2 = 0;
let remoteInput = { keys: {}, mouseAngle: 0, clicked: false };
let p2Ready = false, hostReady = false;
let dashTimer2 = 0, dashCooldown2 = 0, dashDX2 = 0, dashDY2 = 0;
let playerFireCD2 = 0;
const COOP_MULT = {
  enemyCount: 1.5,
  enemyHp: 1.35,
  enemyDmg: 1.15,
  bossHp: 1.5,
  spawnRate: 0.85
};
const NET_SEND_INTERVAL = 3; // host sends state every N frames

// ---- Resize ----
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ---- Obstacle Map ----
let obstacleGrid = [];

function generateObstacles() {
  obstacleGrid = [];
  obstacles = [];
  for (let y = 0; y < MAP_H; y++) {
    obstacleGrid[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      obstacleGrid[y][x] = 0;
    }
  }
  const cx = Math.floor(MAP_W / 2), cy = Math.floor(MAP_H / 2);
  const biome = BIOMES[currentBiome];
  if (biome.noRocks) {
    // Trees instead of rocks
    for (let i = 0; i < 80; i++) {
      const x = Math.floor(Math.random() * MAP_W);
      const y = Math.floor(Math.random() * MAP_H);
      if (Math.abs(x - cx) < 5 && Math.abs(y - cy) < 5) continue;
      if (obstacleGrid[y][x] !== 0) continue;
      obstacleGrid[y][x] = 1;
      obstacles.push({ x: x * TILE, y: y * TILE, w: TILE, h: TILE, type: 'tree' });
    }
    // More grass clearings
    for (let i = 0; i < 25; i++) {
      const bx = Math.floor(Math.random() * (MAP_W - 6)) + 3;
      const by = Math.floor(Math.random() * (MAP_H - 6)) + 3;
      const size = Math.floor(Math.random() * 3) + 2;
      for (let dy = 0; dy < size; dy++) {
        for (let dx = 0; dx < size; dx++) {
          const tx = bx + dx, ty = by + dy;
          if (tx >= MAP_W || ty >= MAP_H) continue;
          if (Math.abs(tx - cx) < 5 && Math.abs(ty - cy) < 5) continue;
          if (obstacleGrid[ty][tx] === 0) {
            obstacleGrid[ty][tx] = 2;
            obstacles.push({ x: tx * TILE, y: ty * TILE, w: TILE, h: TILE, type: 'lake' });
          }
        }
      }
    }
  } else {
    for (let i = 0; i < 120; i++) {
      const x = Math.floor(Math.random() * MAP_W);
      const y = Math.floor(Math.random() * MAP_H);
      if (Math.abs(x - cx) < 5 && Math.abs(y - cy) < 5) continue;
      obstacleGrid[y][x] = 1;
      obstacles.push({ x: x * TILE, y: y * TILE, w: TILE, h: TILE, type: 'rock' });
    }
    for (let i = 0; i < 15; i++) {
      const bx = Math.floor(Math.random() * (MAP_W - 6)) + 3;
      const by = Math.floor(Math.random() * (MAP_H - 6)) + 3;
      const size = Math.floor(Math.random() * 3) + 2;
      for (let dy = 0; dy < size; dy++) {
        for (let dx = 0; dx < size; dx++) {
          const tx = bx + dx, ty = by + dy;
          if (tx >= MAP_W || ty >= MAP_H) continue;
          if (Math.abs(tx - cx) < 5 && Math.abs(ty - cy) < 5) continue;
          if (obstacleGrid[ty][tx] === 0) {
            obstacleGrid[ty][tx] = 2;
            obstacles.push({ x: tx * TILE, y: ty * TILE, w: TILE, h: TILE, type: 'lake' });
          }
        }
      }
    }
  }
}

function isObstacle(wx, wy) {
  const tx = Math.floor(wx / TILE), ty = Math.floor(wy / TILE);
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return true;
  if (!obstacleGrid[ty]) return true;
  return obstacleGrid[ty][tx] !== 0;
}

// ---- Flow Field Pathfinding ----
// BFS distance grid from player — enemies follow the gradient toward the player
// 65535 = unreachable, 0 = player tile
let flowField = null;   // Uint16Array[MAP_W * MAP_H]
let flowField2 = null;  // for P2 in co-op
let flowFieldDirty = true;
const FF_UNREACHABLE = 65535;
const FF_RECOMPUTE_INTERVAL = 30; // frames between recomputes

function computeFlowField(targetWX, targetWY) {
  const ff = new Uint16Array(MAP_W * MAP_H);
  ff.fill(FF_UNREACHABLE);

  // Build a blocked grid that includes obstacles + buildings
  const tx = Math.floor(targetWX / TILE), ty = Math.floor(targetWY / TILE);
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return ff;

  // BFS queue — flat array with read pointer for speed
  const queue = new Int32Array(MAP_W * MAP_H * 2); // x,y pairs
  let qHead = 0, qTail = 0;

  ff[ty * MAP_W + tx] = 0;
  queue[qTail++] = tx; queue[qTail++] = ty;

  while (qHead < qTail) {
    const cx = queue[qHead++], cy = queue[qHead++];
    const cd = ff[cy * MAP_W + cx];
    const nd = cd + 1;
    // 8-directional neighbors
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = cx + dx, ny = cy + dy;
        if (nx < 0 || ny < 0 || nx >= MAP_W || ny >= MAP_H) continue;
        const ni = ny * MAP_W + nx;
        if (ff[ni] <= nd) continue; // already visited with equal or shorter path
        // Check walkability: obstacle grid + buildings
        if (obstacleGrid[ny] && obstacleGrid[ny][nx] !== 0) continue;
        // Check buildings occupying this tile
        const wx = nx * TILE, wy = ny * TILE;
        let bldBlocked = false;
        for (const b of buildings) {
          if (b.hp > 0 && b.x === wx && b.y === wy) { bldBlocked = true; break; }
        }
        if (bldBlocked) continue;
        // Diagonal: require both cardinal neighbors to be walkable (prevent corner cutting)
        if (dx !== 0 && dy !== 0) {
          if (obstacleGrid[cy] && obstacleGrid[cy][nx] !== 0) continue;
          if (obstacleGrid[ny] && obstacleGrid[ny][cx] !== 0) continue;
        }
        ff[ni] = nd;
        queue[qTail++] = nx; queue[qTail++] = ny;
      }
    }
  }
  return ff;
}

function getFlowAngle(wx, wy, ff) {
  const tx = Math.floor(wx / TILE), ty = Math.floor(wy / TILE);
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return null;
  const cur = ff[ty * MAP_W + tx];
  if (cur === 0) return null; // already at target
  if (cur === FF_UNREACHABLE) return null; // no path

  let bestD = cur, bestDX = 0, bestDY = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = tx + dx, ny = ty + dy;
      if (nx < 0 || ny < 0 || nx >= MAP_W || ny >= MAP_H) continue;
      const nd = ff[ny * MAP_W + nx];
      if (nd < bestD) { bestD = nd; bestDX = dx; bestDY = dy; }
    }
  }
  if (bestDX === 0 && bestDY === 0) return null;
  return Math.atan2(bestDY, bestDX);
}

function recomputeFlowFields() {
  flowField = computeFlowField(player.x, player.y);
  if (isCoop && player2 && player2.hp > 0) {
    flowField2 = computeFlowField(player2.x, player2.y);
  } else {
    flowField2 = null;
  }
}

function isBuildingAt(wx, wy) {
  const tx = Math.floor(wx / TILE) * TILE;
  const ty = Math.floor(wy / TILE) * TILE;
  return buildings.some(b => b.x === tx && b.y === ty);
}

function findValidPosition(x, y, radius) {
  if (!isObstacle(x, y) && !isBuildingAt(x, y)) return { x, y };
  // Try increasing rings of random offsets
  for (let ring = 0; ring < 4; ring++) {
    const minD = 40 + ring * 60;
    const maxD = minD + 60;
    for (let i = 0; i < 20; i++) {
      const a = Math.random() * Math.PI * 2;
      const d = minD + Math.random() * (maxD - minD);
      const nx = x + Math.cos(a) * d, ny = y + Math.sin(a) * d;
      if (nx > radius && nx < WORLD_W - radius && ny > radius && ny < WORLD_H - radius &&
          !isObstacle(nx, ny) && !isBuildingAt(nx, ny)) return { x: nx, y: ny };
    }
  }
  // Last resort: try along the line toward map center
  const cx = WORLD_W / 2, cy = WORLD_H / 2;
  const toCenter = Math.atan2(cy - y, cx - x);
  for (let d = 80; d < 600; d += 30) {
    const nx = x + Math.cos(toCenter) * d, ny = y + Math.sin(toCenter) * d;
    if (nx > radius && nx < WORLD_W - radius && ny > radius && ny < WORLD_H - radius &&
        !isObstacle(nx, ny) && !isBuildingAt(nx, ny)) return { x: nx, y: ny };
  }
  // Absolute fallback: safe zone near map center
  return { x: WORLD_W / 2 + (Math.random() - 0.5) * 200, y: WORLD_H / 2 + (Math.random() - 0.5) * 200 };
}

// ---- Init ----
function initGame() {
  generateObstacles();
  player = { x: WORLD_W / 2, y: WORLD_H / 2, hp: 100, maxHp: 100, angle: 0 };
  drone = { x: player.x, y: player.y };
  droneAngle = 0; playerFireCD = 0; droneFireCD = 0;
  bullets = []; enemies = []; buildings = []; orbs = []; particles = []; mines = []; spacemen = []; shockwaves = []; catapultBoulders = [];
  activePlanes = []; napalmFires = []; planeCooldownTimer = 0; planeWeaponSelect = false; planeTargetingWeapon = null;
  energy = 20; wave = 0; waveBannerTimer = 0; selectedBuild = null;
  generatorTimer = 0; frameCount = 0;
  gameOverShown = false; victoryShown = false;
  dashTimer = 0; dashCooldown = 0; dashDX = 0; dashDY = 0;
  wavePhase = 'countdown';
  betweenTimer = BETWEEN_WAVE_SECONDS * 60;
  enemiesSpawned = 0; totalWaveEnemies = 0; spawnTimer = 0; waveKills = 0;
  activeBoss = null; bossSpawned = false;
  gamePaused = false; totalKills = 0; upgradePoints = 0; showingUpgrades = false;
  playerUpgrades = { maxHp: 0, speed: 0, damage: 0, droneRate: 0, dashCD: 0, squad: 0 };
  endlessMode = false; endlessTimer = 0; endlessLevel = 0; endlessBossTimer = 0;
  // Co-op init
  if (isCoop) {
    player2 = { x: WORLD_W / 2 + 60, y: WORLD_H / 2, hp: 100, maxHp: 100, angle: 0 };
    drone2 = { x: player2.x, y: player2.y };
    droneAngle2 = Math.PI; droneFireCD2 = 0; playerFireCD2 = 0;
    dashTimer2 = 0; dashCooldown2 = 0; dashDX2 = 0; dashDY2 = 0;
    remoteInput = { keys: {}, mouseAngle: 0, clicked: false };
    p2Ready = false; hostReady = false;
  } else {
    player2 = null; drone2 = null;
  }
  document.getElementById('boss-bar').classList.remove('show');
  document.getElementById('endless-timer').classList.remove('show');
  for (let i = 0; i < 30; i++) spawnOrb();
  updateBuildButtons();
  updateWaveHUD();
  recomputeFlowFields();
}

// ---- Orbs ----
function spawnOrb() {
  let tries = 0;
  while (tries < 50) {
    const x = Math.random() * (WORLD_W - 40) + 20;
    const y = Math.random() * (WORLD_H - 40) + 20;
    if (!isObstacle(x, y)) {
      orbs.push({ x, y, pulse: Math.random() * Math.PI * 2 });
      return;
    }
    tries++;
  }
}

// ---- Waves ----
function startWave() {
  wave++;
  const cfg = WAVE_CONFIG[wave - 1];
  totalWaveEnemies = isCoop ? Math.ceil(cfg.count * COOP_MULT.enemyCount) : cfg.count;
  enemiesSpawned = 0; spawnTimer = 0; waveKills = 0;
  bossSpawned = false; activeBoss = null;
  wavePhase = 'active';
  document.getElementById('boss-bar').classList.remove('show');

  const banner = document.getElementById('wave-banner');
  const bossText = cfg.boss ? ' [BOSS WAVE]' : '';
  banner.innerHTML = `WAVE ${wave} / ${MAX_WAVES}<div class="wave-subtitle">${cfg.name}${bossText}</div>`;
  banner.classList.add('show');
  waveBannerTimer = 150;
  document.getElementById('wave-display').textContent = `${wave} / ${MAX_WAVES}`;
  const orbCount = Math.max(0, 15 - orbs.length);
  for (let i = 0; i < orbCount; i++) spawnOrb();
  updateWaveHUD();
}

function getSpawnPos() {
  for (let attempt = 0; attempt < 40; attempt++) {
    const side = Math.floor(Math.random() * 4);
    let x, y, checkX, checkY;
    switch (side) {
      case 0: x = Math.random() * WORLD_W; y = -20; checkX = x; checkY = 30; break;
      case 1: x = WORLD_W + 20; y = Math.random() * WORLD_H; checkX = WORLD_W - 30; checkY = y; break;
      case 2: x = Math.random() * WORLD_W; y = WORLD_H + 20; checkX = x; checkY = WORLD_H - 30; break;
      default: x = -20; y = Math.random() * WORLD_H; checkX = 30; checkY = y; break;
    }
    // Validate entry point + nearby tiles aren't blocked
    if (!isObstacle(checkX, checkY) && !isBuildingAt(checkX, checkY) &&
        !isObstacle(checkX + 20, checkY) && !isObstacle(checkX - 20, checkY) &&
        !isObstacle(checkX, checkY + 20) && !isObstacle(checkX, checkY - 20)) {
      return { x, y };
    }
  }
  // Fallback: spawn from top near center (center is always clear)
  return { x: WORLD_W / 2 + (Math.random() - 0.5) * 200, y: -20 };
}

function spawnEnemy(forceType) {
  const cfg = endlessMode ? getEndlessConfig() : WAVE_CONFIG[wave - 1];
  const pos = getSpawnPos();
  const types = cfg.types || ['normal'];
  const type = forceType || types[Math.floor(Math.random() * types.length)];
  const baseHp = 30 + Math.random() * 20;
  const size = cfg.sizeMin + Math.floor(Math.random() * (cfg.sizeMax - cfg.sizeMin + 1));
  // Scale enemy stats based on player upgrade level (compensate for player power)
  const upgradePower = Object.values(playerUpgrades).reduce((a,b) => a+b, 0);
  const upgradeScale = 1 + upgradePower * 0.04;
  const coopHpMult = isCoop ? COOP_MULT.enemyHp : 1;
  const coopDmgMult = isCoop ? COOP_MULT.enemyDmg : 1;
  const hp = Math.floor(baseHp * cfg.hpMult * upgradeScale * coopHpMult);
  enemies.push({
    x: pos.x, y: pos.y, size, hp, maxHp: hp,
    speed: ENEMY_BASE_SPEED * cfg.speedMult * (0.85 + Math.random() * 0.3),
    attackCD: 0, damage: Math.floor((5 + wave) * cfg.dmgMult * upgradeScale * coopDmgMult),
    type, isBoss: false, spawnFrame: frameCount, isRaged: false,
    // Laser enemy
    laserCharging: false, laserChargeTimer: 0, laserFiring: false, laserFireTimer: 0, laserCooldown: 0, laserAngle: 0,
    // Miner
    mineCD: 200 + Math.floor(Math.random() * 100),
    // Charger
    chargeWindup: 0, isCharging: false, chargeDX: 0, chargeDY: 0, chargeCooldown: 0, stunTimer: 0,
    // Splitter
    canSplit: type === 'splitter',
    // Phase-through stuck detection
    _prevX: pos.x, _prevY: pos.y, _phaseTimer: 0, _phasing: false,
  });
  if (!endlessMode) enemiesSpawned++;
}

function spawnBoss(bossKey) {
  const def = BOSS_DEFS[bossKey];
  const pos = getSpawnPos();
  const upgradePower = Object.values(playerUpgrades).reduce((a,b) => a+b, 0);
  const upgradeScale = 1 + upgradePower * 0.05;
  const coopBossHpMult = isCoop ? COOP_MULT.bossHp : 1;
  const hp = Math.floor(def.hp * upgradeScale * coopBossHpMult);
  const boss = {
    x: pos.x, y: pos.y, size: def.size, hp, maxHp: hp,
    speed: def.speed, attackCD: 0, damage: def.dmg,
    type: 'boss', isBoss: true, bossKey, spawnFrame: frameCount, isRaged: false,
    _prevX: pos.x, _prevY: pos.y, _phaseTimer: 0, _phasing: false,
    abilityCD1: 0, abilityCD2: 0, phase: 1,
    laserCharging: false, laserChargeTimer: 0, laserFiring: false, laserFireTimer: 0, laserCooldown: 0, laserAngle: 0,
    mineCD: 0, chargeWindup: 0, isCharging: false, chargeDX: 0, chargeDY: 0, chargeCooldown: 0, stunTimer: 0, canSplit: false,
  };
  enemies.push(boss);
  activeBoss = boss;
  document.getElementById('boss-name-text').textContent = def.name;
  document.getElementById('boss-bar').classList.add('show');
  const banner = document.getElementById('wave-banner');
  banner.innerHTML = `<div style="color:#ff2222;font-size:32px">${def.name}</div><div class="wave-subtitle">Boss incoming!</div>`;
  banner.classList.add('show');
  waveBannerTimer = 120;
}

function spawnMine(x, y, damage) {
  mines.push({ x, y, armTimer: MINE_ARM_TIME, lifetime: MINE_LIFETIME, damage: damage || MINE_DAMAGE, armed: false });
}

function getEndlessConfig() {
  const lv = endlessLevel;
  return {
    hpMult: 3.0 + lv * 0.8, speedMult: 1.3 + lv * 0.08, dmgMult: 2.0 + lv * 0.5,
    spawnRate: Math.max(3, 15 - lv), sizeMin: 14 + Math.min(lv, 6), sizeMax: 22 + Math.min(lv, 10),
    types: ['normal','laser','miner','charger','splitter'], boss: null,
  };
}

function startEndless() {
  endlessMode = true; endlessTimer = 0; endlessLevel = 0; endlessBossTimer = 0;
  wavePhase = 'endless'; spawnTimer = 0;
  document.getElementById('endless-timer').classList.add('show');
  const banner = document.getElementById('wave-banner');
  banner.innerHTML = '<div style="color:#ff0000;font-size:36px">ENDLESS SIEGE</div><div class="wave-subtitle">Survive as long as you can!</div>';
  banner.classList.add('show'); waveBannerTimer = 180;
  document.getElementById('wave-display').textContent = 'ENDLESS';
}

function getUpgradeCost(level) {
  return level < UPGRADE_COSTS.length ? UPGRADE_COSTS[level] : 999;
}

function applyUpgrades(boughtKey) {
  const newMaxHp = 100 + playerUpgrades.maxHp * 15;
  player.maxHp = newMaxHp;
  if (isCoop && player2) {
    player2.maxHp = newMaxHp;
  }
  // Only heal 25 HP when buying Max HP specifically
  if (boughtKey === 'maxHp') {
    player.hp = Math.min(player.hp + 25, player.maxHp);
    if (isCoop && player2) player2.hp = Math.min(player2.hp + 25, player2.maxHp);
  }
}

function updateWaveHUD() {
  const statusEl = document.getElementById('wave-status-text');
  const progressFill = document.getElementById('wave-progress-fill');
  const timerEl = document.getElementById('between-wave-timer');

  if (wavePhase === 'countdown') {
    const secs = Math.ceil(betweenTimer / 60);
    const nextW = wave + 1;
    if (nextW <= MAX_WAVES) {
      statusEl.innerHTML = `Next: <span>Wave ${nextW}</span> — ${WAVE_CONFIG[nextW - 1].name}`;
    }
    progressFill.style.width = '0%';
    timerEl.textContent = `Starting in ${secs}s`;
    timerEl.classList.add('show');
  } else if (wavePhase === 'active') {
    const alive = enemies.length;
    const remaining = (totalWaveEnemies - enemiesSpawned) + alive;
    statusEl.innerHTML = `Enemies remaining: <span>${remaining}</span>`;
    const killed = totalWaveEnemies - remaining;
    const pct = totalWaveEnemies > 0 ? (killed / totalWaveEnemies) * 100 : 0;
    progressFill.style.width = pct + '%';
    timerEl.classList.remove('show');
  } else if (wavePhase === 'cleared') {
    if (wave >= MAX_WAVES) {
      statusEl.innerHTML = '<span style="color:#44ff44">ALL WAVES CLEARED!</span>';
    } else {
      statusEl.innerHTML = '<span style="color:#44ff44">WAVE CLEARED!</span>';
      const secs = Math.ceil(betweenTimer / 60);
      timerEl.textContent = `Next wave in ${secs}s`;
      timerEl.classList.add('show');
    }
    progressFill.style.width = '100%';
  } else if (wavePhase === 'upgrades') {
    statusEl.innerHTML = '<span style="color:#44ff44">CHOOSE UPGRADES</span>';
    progressFill.style.width = '100%';
    timerEl.classList.remove('show');
  } else if (wavePhase === 'victory') {
    statusEl.innerHTML = '<span style="color:#44ff44">VICTORY!</span>';
    progressFill.style.width = '100%';
    timerEl.classList.remove('show');
  } else if (wavePhase === 'endless') {
    const alive = enemies.length;
    statusEl.innerHTML = `ENDLESS SIEGE — Level <span>${endlessLevel + 1}</span> — Enemies: <span>${alive}</span>`;
    progressFill.style.width = '100%';
    progressFill.style.background = 'linear-gradient(90deg, #ff0000, #ff6600)';
    timerEl.classList.remove('show');
  } else {
    statusEl.innerHTML = '';
    timerEl.classList.remove('show');
  }
}

// ---- Particles ----
function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = Math.random() * speed + 1;
    particles.push({
      x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: 20 + Math.random() * 20, maxLife: 20 + Math.random() * 20,
      color, size: 2 + Math.random() * 3
    });
  }
}

// ---- Collision helpers ----
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function circleRect(cx, cy, cr, rx, ry, rw, rh) {
  const nx = Math.max(rx, Math.min(cx, rx + rw));
  const ny = Math.max(ry, Math.min(cy, ry + rh));
  return Math.hypot(cx - nx, cy - ny) < cr;
}

function resolveCircleRect(cx, cy, cr, rx, ry, rw, rh) {
  const nx = Math.max(rx, Math.min(cx, rx + rw));
  const ny = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - nx, dy = cy - ny;
  const d = Math.hypot(dx, dy);
  if (d < cr && d > 0) {
    const push = (cr - d);
    return { x: cx + (dx / d) * push, y: cy + (dy / d) * push };
  }
  return null;
}

function moveWithCollision(entity, dx, dy, radius, ignoreObstacles) {
  let nx = entity.x + dx;
  let ny = entity.y + dy;
  nx = Math.max(radius, Math.min(WORLD_W - radius, nx));
  ny = Math.max(radius, Math.min(WORLD_H - radius, ny));
  if (!ignoreObstacles) {
    const tx0 = Math.max(0, Math.floor((nx - radius - TILE) / TILE));
    const ty0 = Math.max(0, Math.floor((ny - radius - TILE) / TILE));
    const tx1 = Math.min(MAP_W - 1, Math.floor((nx + radius + TILE) / TILE));
    const ty1 = Math.min(MAP_H - 1, Math.floor((ny + radius + TILE) / TILE));
    for (let pass = 0; pass < 3; pass++) {
      for (let ty = ty0; ty <= ty1; ty++) {
        for (let tx = tx0; tx <= tx1; tx++) {
          if (obstacleGrid[ty] && obstacleGrid[ty][tx] !== 0) {
            const res = resolveCircleRect(nx, ny, radius, tx * TILE, ty * TILE, TILE, TILE);
            if (res) { nx = res.x; ny = res.y; }
          }
        }
      }
      for (const b of buildings) {
        if (b.hp > 0) {
          const res = resolveCircleRect(nx, ny, radius, b.x, b.y, BUILD_SIZE, BUILD_SIZE);
          if (res) { nx = res.x; ny = res.y; }
        }
      }
    }
  }
  entity.x = nx;
  entity.y = ny;
}

// ---- Update ----
function update() {
  if (!gameRunning || gamePaused) return;

  // Client skips simulation entirely — receives state from host
  if (isClient) {
    frameCount++;
    // Send input to host every frame
    if (conn && conn.open) {
      conn.send({ type: 'input', input: {
        keys: { ...keys },
        mouseAngle: Math.atan2(mouse.y + camera.y - (player2 ? player2.y : player.y), mouse.x + camera.x - (player2 ? player2.x : player.x)),
        clicked: mouse.clicked
      }});
      mouse.clicked = false;
    }
    return;
  }

  frameCount++;

  // Recompute flow fields periodically for pathfinding
  if (frameCount % FF_RECOMPUTE_INTERVAL === 0) recomputeFlowFields();

  worldMouseX = mouse.x + camera.x;
  worldMouseY = mouse.y + camera.y;

  // Skip gameplay during upgrade screen
  if (showingUpgrades) return;

  // -- Player movement --
  const effectiveSpeed = PLAYER_SPEED + playerUpgrades.speed * 0.5;
  const effectiveDashCD = DASH_COOLDOWN - playerUpgrades.dashCD * 25;
  let pdx = 0, pdy = 0;
  if (dashTimer > 0) { pdx = dashDX; pdy = dashDY; dashTimer--; }
  else {
    if (keys['w'] || keys['arrowup']) pdy -= 1;
    if (keys['s'] || keys['arrowdown']) pdy += 1;
    if (keys['a'] || keys['arrowleft']) pdx -= 1;
    if (keys['d'] || keys['arrowright']) pdx += 1;
    if (pdx !== 0 || pdy !== 0) {
      const len = Math.hypot(pdx, pdy);
      pdx = (pdx / len) * effectiveSpeed;
      pdy = (pdy / len) * effectiveSpeed;
    }
  }
  if (dashCooldown > 0) dashCooldown--;
  const dashFill = document.getElementById('dash-bar-fill');
  if (dashCooldown > 0) {
    dashFill.style.width = ((1 - dashCooldown / effectiveDashCD) * 100) + '%';
    dashFill.classList.add('on-cooldown');
  } else { dashFill.style.width = '100%'; dashFill.classList.remove('on-cooldown'); }
  moveWithCollision(player, pdx, pdy, PLAYER_R);
  player.angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);

  // -- Player 2 movement (HOST-SIDE) --
  if (isHost && isCoop && player2 && player2.hp > 0) {
    const p2Speed = PLAYER_SPEED + playerUpgrades.speed * 0.5;
    const effectiveDashCD2 = DASH_COOLDOWN - playerUpgrades.dashCD * 25;
    let p2dx = 0, p2dy = 0;
    if (dashTimer2 > 0) { p2dx = dashDX2; p2dy = dashDY2; dashTimer2--; }
    else {
      const rk = remoteInput.keys || {};
      if (rk['w'] || rk['arrowup']) p2dy -= 1;
      if (rk['s'] || rk['arrowdown']) p2dy += 1;
      if (rk['a'] || rk['arrowleft']) p2dx -= 1;
      if (rk['d'] || rk['arrowright']) p2dx += 1;
      if (p2dx !== 0 || p2dy !== 0) {
        const len = Math.hypot(p2dx, p2dy);
        p2dx = (p2dx / len) * p2Speed;
        p2dy = (p2dy / len) * p2Speed;
      }
      // P2 dash
      if (rk[' '] && dashCooldown2 <= 0 && dashTimer2 <= 0) {
        let ddx = 0, ddy = 0;
        if (rk['w'] || rk['arrowup']) ddy -= 1;
        if (rk['s'] || rk['arrowdown']) ddy += 1;
        if (rk['a'] || rk['arrowleft']) ddx -= 1;
        if (rk['d'] || rk['arrowright']) ddx += 1;
        if (ddx === 0 && ddy === 0) { ddx = Math.cos(remoteInput.mouseAngle); ddy = Math.sin(remoteInput.mouseAngle); }
        const dlen = Math.hypot(ddx, ddy);
        if (dlen > 0) {
          dashDX2 = (ddx / dlen) * DASH_SPEED; dashDY2 = (ddy / dlen) * DASH_SPEED;
          dashTimer2 = DASH_DURATION; dashCooldown2 = effectiveDashCD2;
          spawnParticles(player2.x, player2.y, '#00ff88', 8, 4);
        }
      }
    }
    if (dashCooldown2 > 0) dashCooldown2--;
    moveWithCollision(player2, p2dx, p2dy, PLAYER_R);
    player2.angle = remoteInput.mouseAngle || 0;
  }

  // -- Player shooting (SEMI-AUTO) --
  const effectiveDmg = PLAYER_BULLET_DMG + playerUpgrades.damage * 6;
  if (playerFireCD > 0) playerFireCD--;
  if (mouse.clicked && playerFireCD <= 0 && !selectedBuild && planeTargetingWeapon === null) {
    mouse.clicked = false;
    playerFireCD = PLAYER_FIRE_COOLDOWN;
    const bx = player.x + Math.cos(player.angle) * (PLAYER_R + 6);
    const by = player.y + Math.sin(player.angle) * (PLAYER_R + 6);
    bullets.push({ x: bx, y: by, vx: Math.cos(player.angle) * BULLET_SPEED, vy: Math.sin(player.angle) * BULLET_SPEED,
      life: BULLET_LIFE, owner: 'player', damage: effectiveDmg });
    spawnParticles(bx, by, '#66ccff', 4, 3);
  }

  // -- Player 2 shooting (HOST-SIDE) --
  if (isHost && isCoop && player2 && player2.hp > 0) {
    if (playerFireCD2 > 0) playerFireCD2--;
    if (remoteInput.clicked && playerFireCD2 <= 0) {
      remoteInput.clicked = false;
      playerFireCD2 = PLAYER_FIRE_COOLDOWN;
      const a2 = remoteInput.mouseAngle || 0;
      const bx2 = player2.x + Math.cos(a2) * (PLAYER_R + 6);
      const by2 = player2.y + Math.sin(a2) * (PLAYER_R + 6);
      bullets.push({ x: bx2, y: by2, vx: Math.cos(a2) * BULLET_SPEED, vy: Math.sin(a2) * BULLET_SPEED,
        life: BULLET_LIFE, owner: 'player2', damage: effectiveDmg });
      spawnParticles(bx2, by2, '#44ff88', 4, 3);
    }
  }

  // -- Drone (fire rate improves with upgrades) --
  const effectiveDroneRate = DRONE_FIRE_RATE - playerUpgrades.droneRate * 3;
  droneAngle += 0.03;
  drone.x = player.x + Math.cos(droneAngle) * DRONE_ORBIT;
  drone.y = player.y + Math.sin(droneAngle) * DRONE_ORBIT;
  if (droneFireCD > 0) droneFireCD--;
  if (droneFireCD <= 0 && enemies.length > 0) {
    let closest = null, closestD = Infinity;
    for (const e of enemies) { const d = dist(drone, e); if (d < closestD && d < DRONE_RANGE) { closest = e; closestD = d; } }
    if (closest) {
      droneFireCD = effectiveDroneRate;
      const a = Math.atan2(closest.y - drone.y, closest.x - drone.x);
      bullets.push({ x: drone.x, y: drone.y, vx: Math.cos(a) * BULLET_SPEED * 0.8, vy: Math.sin(a) * BULLET_SPEED * 0.8,
        life: 60, owner: 'drone', damage: 8 + playerUpgrades.damage * 2 });
    }
  }

  // -- Drone 2 (HOST-SIDE) --
  if (isHost && isCoop && player2 && player2.hp > 0 && drone2) {
    droneAngle2 += 0.03;
    drone2.x = player2.x + Math.cos(droneAngle2) * DRONE_ORBIT;
    drone2.y = player2.y + Math.sin(droneAngle2) * DRONE_ORBIT;
    if (droneFireCD2 > 0) droneFireCD2--;
    if (droneFireCD2 <= 0 && enemies.length > 0) {
      let closest = null, closestD = Infinity;
      for (const e of enemies) { const d = dist(drone2, e); if (d < closestD && d < DRONE_RANGE) { closest = e; closestD = d; } }
      if (closest) {
        droneFireCD2 = effectiveDroneRate;
        const a = Math.atan2(closest.y - drone2.y, closest.x - drone2.x);
        bullets.push({ x: drone2.x, y: drone2.y, vx: Math.cos(a) * BULLET_SPEED * 0.8, vy: Math.sin(a) * BULLET_SPEED * 0.8,
          life: 60, owner: 'drone2', damage: 8 + playerUpgrades.damage * 2 });
      }
    }
  }

  // -- Turret shooting (level-scaled) --
  for (const b of buildings) {
    if (b.type !== 'turret' || b.hp <= 0) continue;
    const lv = b.level || 1;
    const tRange = TURRET_RANGE * (1 + (lv - 1) * 0.2);
    const tRate = Math.floor(TURRET_FIRE_RATE * Math.pow(0.8, lv - 1));
    const tDmg = Math.floor(18 * (1 + (lv - 1) * 0.25));
    if (b.fireCD > 0) { b.fireCD--; continue; }
    const bcx = b.x + BUILD_SIZE / 2, bcy = b.y + BUILD_SIZE / 2;
    let closest = null, closestD = Infinity;
    for (const e of enemies) { const d = Math.hypot(e.x - bcx, e.y - bcy); if (d < closestD && d < tRange) { closest = e; closestD = d; } }
    if (closest) {
      b.fireCD = tRate; const a = Math.atan2(closest.y - bcy, closest.x - bcx); b.angle = a;
      bullets.push({ x: bcx + Math.cos(a) * 18, y: bcy + Math.sin(a) * 18, vx: Math.cos(a) * TURRET_BULLET_SPEED, vy: Math.sin(a) * TURRET_BULLET_SPEED,
        life: 60, owner: 'turret', damage: tDmg });
      spawnParticles(bcx + Math.cos(a) * 18, bcy + Math.sin(a) * 18, '#ff8800', 2, 2);
    }
  }

  // -- Laser Tower (level-scaled) --
  for (const b of buildings) {
    if (b.type !== 'laser' || b.hp <= 0) continue;
    const lv = b.level || 1;
    const lRange = LASER_RANGE * (1 + (lv - 1) * 0.15);
    const lDps = LASER_DPS * (1 + (lv - 1) * 0.25);
    const bcx = b.x + BUILD_SIZE / 2, bcy = b.y + BUILD_SIZE / 2;
    let closest = null, closestD = Infinity;
    for (const e of enemies) { const d = Math.hypot(e.x - bcx, e.y - bcy); if (d < closestD && d < lRange) { closest = e; closestD = d; } }
    b.laserTarget = closest;
    if (closest) { b.angle = Math.atan2(closest.y - bcy, closest.x - bcx); closest.hp -= lDps;
      if (frameCount % 6 === 0) spawnParticles(closest.x, closest.y, '#ff44ff', 2, 2); }
  }

  // -- Catapult firing --
  for (const b of buildings) {
    if (b.type !== 'catapult' || b.hp <= 0) continue;
    const lv = b.level || 1;
    const cRange = CATAPULT_RANGE * (1 + (lv - 1) * 0.15);
    const cRate = Math.floor(CATAPULT_FIRE_RATE * Math.pow(0.85, lv - 1));
    const cDmg = Math.floor(CATAPULT_DAMAGE * (1 + (lv - 1) * 0.3));
    if (b.fireCD > 0) { b.fireCD--; continue; }
    const bcx = b.x + BUILD_SIZE / 2, bcy = b.y + BUILD_SIZE / 2;
    let closest = null, closestD = Infinity;
    for (const e of enemies) { const d = Math.hypot(e.x - bcx, e.y - bcy); if (d < closestD && d < cRange) { closest = e; closestD = d; } }
    if (closest) {
      b.fireCD = cRate;
      b.angle = Math.atan2(closest.y - bcy, closest.x - bcx);
      catapultBoulders.push({
        sx: bcx, sy: bcy, tx: closest.x, ty: closest.y,
        progress: 0, speed: 0.025, damage: cDmg
      });
      spawnParticles(bcx, bcy, '#ff6600', 4, 3);
    }
  }

  // -- Boulder arc update --
  for (let i = catapultBoulders.length - 1; i >= 0; i--) {
    const cb = catapultBoulders[i];
    cb.progress += cb.speed;
    if (cb.progress >= 1) {
      // Impact — area damage
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (Math.hypot(e.x - cb.tx, e.y - cb.ty) < CATAPULT_BLAST_RADIUS) {
          e.hp -= cb.damage;
          if (e.hp <= 0) killEnemy(e, j);
        }
      }
      spawnParticles(cb.tx, cb.ty, '#ff4400', 18, 6);
      spawnParticles(cb.tx, cb.ty, '#ffaa00', 12, 4);
      catapultBoulders.splice(i, 1);
    }
  }

  // -- Plane airstrike update --
  if (planeCooldownTimer > 0) planeCooldownTimer--;
  for (let i = activePlanes.length - 1; i >= 0; i--) {
    const pl = activePlanes[i];
    pl.x += Math.cos(pl.angle) * pl.speed;
    pl.y += Math.sin(pl.angle) * pl.speed;
    const totalD = Math.hypot(pl.ex - (pl.x - Math.cos(pl.angle) * pl.speed * 200), pl.ey - (pl.y - Math.sin(pl.angle) * pl.speed * 200));
    const atTarget = Math.hypot(pl.x - pl.tx, pl.y - pl.ty) < pl.speed * 3;
    // Fire weapon when passing over target
    if (!pl.fired && atTarget) {
      pl.fired = true;
      if (pl.weapon === 'bombs') {
        for (let b = 0; b < 3; b++) {
          const bx = pl.tx + (Math.random() - 0.5) * 80;
          const by = pl.ty + (Math.random() - 0.5) * 80;
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (Math.hypot(e.x - bx, e.y - by) < 120) {
              e.hp -= 50;
              if (e.hp <= 0) killEnemy(e, j);
            }
          }
          spawnParticles(bx, by, '#ff4400', 20, 7);
          spawnParticles(bx, by, '#ffaa00', 14, 5);
        }
      } else if (pl.weapon === 'napalm') {
        for (let n = -3; n <= 3; n++) {
          napalmFires.push({
            x: pl.tx + Math.cos(pl.angle) * n * 40,
            y: pl.ty + Math.sin(pl.angle) * n * 40,
            life: 300, dps: 8
          });
        }
      } else if (pl.weapon === 'machinegun') {
        for (let m = 0; m < 8; m++) {
          const mx = pl.tx + Math.cos(pl.angle) * (m - 4) * 30 + (Math.random() - 0.5) * 20;
          const my = pl.ty + Math.sin(pl.angle) * (m - 4) * 30 + (Math.random() - 0.5) * 20;
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (Math.hypot(e.x - mx, e.y - my) < e.size + 12) {
              e.hp -= 12;
              if (e.hp <= 0) killEnemy(e, j);
            }
          }
          spawnParticles(mx, my, '#ffcc00', 4, 3);
        }
      }
    }
    // Remove when far past target
    if (Math.hypot(pl.x - pl.ex, pl.y - pl.ey) < pl.speed * 2) {
      activePlanes.splice(i, 1);
    }
  }

  // -- Napalm fire damage --
  for (let i = napalmFires.length - 1; i >= 0; i--) {
    const nf = napalmFires[i];
    nf.life--;
    if (nf.life <= 0) { napalmFires.splice(i, 1); continue; }
    for (const e of enemies) {
      if (Math.hypot(e.x - nf.x, e.y - nf.y) < 40) {
        e.hp -= nf.dps / 60; // per-frame DPS
      }
    }
    const pd = Math.hypot(player.x - nf.x, player.y - nf.y);
    if (pd < 40) { player.hp -= nf.dps / 120; updateHpDisplay(); }
  }

  // -- Bullets (friendly + enemy) --
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if (b.x < 0 || b.x > WORLD_W || b.y < 0 || b.y > WORLD_H) { bullets.splice(i, 1); continue; }
    if (isObstacle(b.x, b.y)) { spawnParticles(b.x, b.y, '#888', 3, 2); bullets.splice(i, 1); continue; }
    if (b.life <= 0) { bullets.splice(i, 1); continue; }
    let hit = false;
    if (b.owner === 'enemy') {
      // Enemy bullets hit player and buildings
      if (Math.hypot(b.x - player.x, b.y - player.y) < PLAYER_R + BULLET_R) {
        player.hp -= b.damage; spawnParticles(player.x, player.y, '#ff0000', 4, 3);
        updateHpDisplay();
        hit = true;
      }
      // Enemy bullets hit P2
      if (!hit && isCoop && player2 && player2.hp > 0 && Math.hypot(b.x - player2.x, b.y - player2.y) < PLAYER_R + BULLET_R) {
        player2.hp -= b.damage; spawnParticles(player2.x, player2.y, '#ff0000', 4, 3);
        updateHpDisplay();
        hit = true;
      }
      if (!hit) for (const bld of buildings) {
        if (bld.hp <= 0) continue;
        if (circleRect(b.x, b.y, BULLET_R, bld.x, bld.y, BUILD_SIZE, BUILD_SIZE)) {
          bld.hp -= b.damage; spawnParticles(b.x, b.y, '#ffaa00', 3, 2); hit = true; break;
        }
      }
      if (!hit) for (const sm of spacemen) {
        if (Math.hypot(b.x - sm.x, b.y - sm.y) < sm.size + BULLET_R) {
          sm.hp -= b.damage; spawnParticles(b.x, b.y, '#4488ff', 3, 2); hit = true; break;
        }
      }
    } else if (b.owner === 'player' || b.owner === 'player2' || b.owner === 'drone' || b.owner === 'drone2' || b.owner === 'turret') {
      // Friendly bullets hit enemies
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + BULLET_R) {
          e.hp -= b.damage; spawnParticles(b.x, b.y, '#ff4444', 4, 3);
          if (e.hp <= 0) killEnemy(e, j);
          hit = true; break;
        }
      }
    }
    if (hit) { bullets.splice(i, 1); continue; }
  }

  // -- Check for laser kills --
  for (let j = enemies.length - 1; j >= 0; j--) {
    if (enemies[j].hp <= 0) killEnemy(enemies[j], j);
  }

  // -- Mines update --
  for (let i = mines.length - 1; i >= 0; i--) {
    const m = mines[i];
    m.lifetime--;
    if (m.armTimer > 0) { m.armTimer--; if (m.armTimer <= 0) m.armed = true; }
    if (m.lifetime <= 0) { mines.splice(i, 1); continue; }
    if (m.armed) {
      const dp = Math.hypot(m.x - player.x, m.y - player.y);
      const dd = Math.hypot(m.x - drone.x, m.y - drone.y);
      const dp2 = (isCoop && player2 && player2.hp > 0) ? Math.hypot(m.x - player2.x, m.y - player2.y) : Infinity;
      if (dp < MINE_RADIUS || dd < MINE_RADIUS || dp2 < MINE_RADIUS) {
        // Explode
        if (dp < MINE_RADIUS) { player.hp -= m.damage; updateHpDisplay(); }
        if (dp2 < MINE_RADIUS && player2) { player2.hp -= m.damage; updateHpDisplay(); }
        spawnParticles(m.x, m.y, '#ff4400', 15, 6);
        spawnParticles(m.x, m.y, '#ffaa00', 10, 4);
        // Damage buildings nearby
        for (const b of buildings) {
          if (Math.hypot(m.x - (b.x + BUILD_SIZE/2), m.y - (b.y + BUILD_SIZE/2)) < MINE_RADIUS) b.hp -= m.damage * 0.5;
        }
        mines.splice(i, 1);
      }
    }
  }

  // -- Shockwaves update --
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const sw = shockwaves[i];
    sw.radius += sw.speed;
    if (sw.radius >= sw.maxRadius) { shockwaves.splice(i, 1); continue; }
    // Damage player if caught in the ring (between radius-18 and radius+18)
    const pd = Math.hypot(sw.x - player.x, sw.y - player.y);
    if (!sw.hitPlayer && Math.abs(pd - sw.radius) < 18) {
      player.hp -= sw.damage; sw.hitPlayer = true;
      spawnParticles(player.x, player.y, '#aa44ff', 8, 4);
      updateHpDisplay();
    }
    // Damage P2
    if (isCoop && player2 && player2.hp > 0) {
      const pd2 = Math.hypot(sw.x - player2.x, sw.y - player2.y);
      if (!sw.hitPlayer2 && Math.abs(pd2 - sw.radius) < 18) {
        player2.hp -= sw.damage; sw.hitPlayer2 = true;
        spawnParticles(player2.x, player2.y, '#aa44ff', 8, 4);
        updateHpDisplay();
      }
    }
    // Damage spacemen
    for (const s of spacemen) {
      const sd = Math.hypot(sw.x - s.x, sw.y - s.y);
      if (Math.abs(sd - sw.radius) < 18) s.hp -= sw.damage * 0.4;
    }
    // Damage buildings
    for (const b of buildings) {
      if (b.hp <= 0) continue;
      const bd = Math.hypot(sw.x - (b.x + BUILD_SIZE/2), sw.y - (b.y + BUILD_SIZE/2));
      if (Math.abs(bd - sw.radius) < 25) b.hp -= sw.damage * 0.3;
    }
  }

  // -- Enemies AI (type-specific) --
  for (const e of enemies) {
    // Frenzy check
    if (!e.isRaged && (frameCount - e.spawnFrame) > FRENZY_TIME) {
      e.isRaged = true; e.speed *= FRENZY_SPEED_MULT; e.damage = Math.floor(e.damage * FRENZY_DMG_MULT);
    }
    if (e.stunTimer > 0) { e.stunTimer--; e.attackCD = Math.max(e.attackCD - 1, 0); continue; }

    let target = { x: player.x, y: player.y };
    let targetD = dist(e, player);
    let targetBuilding = null;
    // Also consider P2 as target
    if (isCoop && player2 && player2.hp > 0) {
      const d2 = dist(e, player2);
      if (d2 < targetD) { targetD = d2; target = { x: player2.x, y: player2.y }; }
    }
    for (const b of buildings) {
      if (b.hp <= 0) continue;
      const d = dist(e, { x: b.x + BUILD_SIZE / 2, y: b.y + BUILD_SIZE / 2 });
      if (d < targetD) { targetD = d; target = { x: b.x + BUILD_SIZE / 2, y: b.y + BUILD_SIZE / 2 }; targetBuilding = b; }
    }
    const a = Math.atan2(target.y - e.y, target.x - e.x);

    // === BOSS AI ===
    if (e.isBoss) {
      const bdef = BOSS_DEFS[e.bossKey];
      // Boss moves toward closest player
      let bossTarget = player;
      if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < dist(e, player)) bossTarget = player2;
      const ba = Math.atan2(bossTarget.y - e.y, bossTarget.x - e.x);
      let bSpeed = e.speed;
      // Core phase 2: rage at <30% hp
      if (e.bossKey === 'core' && e.hp < e.maxHp * 0.3) { e.phase = 2; bSpeed = e.speed * 1.6; }
      let bdx = Math.cos(ba) * bSpeed, bdy = Math.sin(ba) * bSpeed;

      // Sentinel: charge attack
      if (e.bossKey === 'sentinel') {
        e.abilityCD1--; if (e.abilityCD1 <= 0) {
          e.abilityCD1 = bdef.chargeCD;
          e.isCharging = true; e.chargeWindup = 40;
          e.chargeDX = Math.cos(ba) * CHARGER_SPEED * 0.8;
          e.chargeDY = Math.sin(ba) * CHARGER_SPEED * 0.8;
        }
        if (e.chargeWindup > 0) { e.chargeWindup--; bdx = 0; bdy = 0; }
        else if (e.isCharging) {
          bdx = e.chargeDX; bdy = e.chargeDY; e.chargeCooldown = (e.chargeCooldown || 15) - 1;
          if (e.chargeCooldown <= 0) e.isCharging = false;
        }
      }
      // Warden: shockwave slam
      if (e.bossKey === 'warden') {
        if (!e.slamWindup) e.slamWindup = 0;
        e.abilityCD1--;
        if (e.abilityCD1 <= 0 && e.slamWindup === 0) {
          e.slamWindup = 60; // 1 second windup — stops moving, pulses purple
          bdx = 0; bdy = 0;
        }
        if (e.slamWindup > 0) {
          e.slamWindup--; bdx = 0; bdy = 0; // freeze during windup
          if (e.slamWindup <= 0) {
            e.abilityCD1 = 240; // 4 second cooldown
            shockwaves.push({ x: e.x, y: e.y, radius: 0, maxRadius: 220, speed: 5, damage: 22 });
            spawnParticles(e.x, e.y, '#aa44ff', 20, 8);
            spawnParticles(e.x, e.y, '#8800cc', 15, 5);
          }
        }
      }
      // Overlord: shoot spread + summon
      if (e.bossKey === 'overlord') {
        e.abilityCD1--; if (e.abilityCD1 <= 0) {
          e.abilityCD1 = bdef.shootCD;
          for (let s = -1; s <= 1; s++) {
            const sa = ba + s * 0.25;
            bullets.push({ x: e.x, y: e.y, vx: Math.cos(sa)*6, vy: Math.sin(sa)*6, life: 80, owner: 'enemy', damage: 12 });
          }
          spawnParticles(e.x, e.y, '#4488ff', 6, 3);
        }
        e.abilityCD2--; if (e.abilityCD2 <= 0) {
          e.abilityCD2 = bdef.summonCD;
          for (let s = 0; s < 2; s++) { const mPos = findValidPosition(e.x + (Math.random()-0.5)*60, e.y + (Math.random()-0.5)*60, 11); enemies.push({
            x: mPos.x, y: mPos.y, size: 11, hp: 40, maxHp: 40,
            speed: 1.4, attackCD: 0, damage: 10, type: 'normal', isBoss: false, spawnFrame: frameCount, isRaged: false,
            laserCharging:false,laserChargeTimer:0,laserFiring:false,laserFireTimer:0,laserCooldown:0,laserAngle:0,
            mineCD:0,chargeWindup:0,isCharging:false,chargeDX:0,chargeDY:0,chargeCooldown:0,stunTimer:0,canSplit:false }); }
        }
      }
      // Core: spread shots + summon + phase 2 rage
      if (e.bossKey === 'core') {
        const spread = e.phase === 2 ? 4 : 2;
        const shootCD = e.phase === 2 ? 60 : bdef.shootCD;
        e.abilityCD1--; if (e.abilityCD1 <= 0) {
          e.abilityCD1 = shootCD;
          for (let s = -spread; s <= spread; s++) {
            const sa = ba + s * 0.2;
            bullets.push({ x: e.x, y: e.y, vx: Math.cos(sa)*7, vy: Math.sin(sa)*7, life: 90, owner: 'enemy', damage: 15 });
          }
          spawnParticles(e.x, e.y, '#ff2200', 10, 5);
        }
        const sumCD = e.phase === 2 ? 150 : bdef.summonCD;
        e.abilityCD2--; if (e.abilityCD2 <= 0) {
          e.abilityCD2 = sumCD;
          const sumCount = e.phase === 2 ? 4 : 2;
          for (let s = 0; s < sumCount; s++) { const mPos = findValidPosition(e.x + (Math.random()-0.5)*80, e.y + (Math.random()-0.5)*80, 12); enemies.push({
            x: mPos.x, y: mPos.y, size: 12, hp: 50, maxHp: 50,
            speed: 1.6, attackCD: 0, damage: 12, type: 'charger', isBoss: false, spawnFrame: frameCount, isRaged: false,
            laserCharging:false,laserChargeTimer:0,laserFiring:false,laserFireTimer:0,laserCooldown:0,laserAngle:0,
            mineCD:0,chargeWindup:0,isCharging:false,chargeDX:0,chargeDY:0,chargeCooldown:200,stunTimer:0,canSplit:false }); }
        }
      }
      // Boss pathfinding: use flow field when direct path is blocked
      const bossLook = 5;
      const bossAheadX = e.x + bdx * bossLook, bossAheadY = e.y + bdy * bossLook;
      let bossPathBlocked = isObstacle(bossAheadX, bossAheadY);
      if (!bossPathBlocked) { for (const bb of buildings) { if (bb.hp > 0 && circleRect(bossAheadX, bossAheadY, e.size, bb.x, bb.y, BUILD_SIZE, BUILD_SIZE)) { bossPathBlocked = true; break; } } }
      if (bossPathBlocked && (Math.abs(bdx) > 0.01 || Math.abs(bdy) > 0.01)) {
        // Try flow field first
        let bossUseFF = flowField;
        if (isCoop && player2 && player2.hp > 0 && flowField2 && dist(e, player2) < dist(e, player)) bossUseFF = flowField2;
        const bossFFAngle = bossUseFF ? getFlowAngle(e.x, e.y, bossUseFF) : null;
        const bSpd = Math.hypot(bdx, bdy);
        if (bossFFAngle !== null) {
          bdx = Math.cos(bossFFAngle) * bSpd; bdy = Math.sin(bossFFAngle) * bSpd;
        } else {
          // Fallback: try angled slides
          const bMoveA = Math.atan2(bdy, bdx);
          for (const off of [Math.PI/4, -Math.PI/4, Math.PI/2, -Math.PI/2, Math.PI*3/4, -Math.PI*3/4]) {
            const tryA = bMoveA + off;
            const tx = e.x + Math.cos(tryA) * bSpd * bossLook;
            const ty = e.y + Math.sin(tryA) * bSpd * bossLook;
            let clear = !isObstacle(tx, ty);
            if (clear) { for (const bb of buildings) { if (bb.hp > 0 && circleRect(tx, ty, e.size, bb.x, bb.y, BUILD_SIZE, BUILD_SIZE)) { clear = false; break; } } }
            if (clear) { bdx = Math.cos(tryA) * bSpd; bdy = Math.sin(tryA) * bSpd; break; }
          }
        }
      }
      moveWithCollision(e, bdx, bdy, e.size);
      // Boss melee
      if (dist(e, player) < e.size + PLAYER_R + 6 && e.attackCD <= 0) {
        player.hp -= e.damage; e.attackCD = 40;
        spawnParticles(player.x, player.y, '#ff0000', 8, 4);
        updateHpDisplay();
      }
      // Boss melee P2
      if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < e.size + PLAYER_R + 6 && e.attackCD <= 0) {
        player2.hp -= e.damage; e.attackCD = 40;
        spawnParticles(player2.x, player2.y, '#ff0000', 8, 4);
        updateHpDisplay();
      }
      // Boss melee spacemen
      if (e.attackCD <= 0) {
        for (const sm of spacemen) {
          if (sm.hp > 0 && dist(e, sm) < e.size + sm.size + 6) {
            sm.hp -= e.damage; e.attackCD = 40;
            spawnParticles(sm.x, sm.y, '#4488ff', 6, 3);
            break;
          }
        }
      }
      if (e.attackCD > 0) e.attackCD--;
      // Update boss HP bar
      if (activeBoss === e) {
        const pct = Math.max(0, e.hp / e.maxHp * 100);
        document.getElementById('boss-bar-fill').style.width = pct + '%';
      }
      continue; // skip normal AI
    }

    // === LASER ENEMY AI ===
    if (e.type === 'laser') {
      if (e.laserCooldown > 0) { e.laserCooldown--; }
      if (targetD < LASER_E_RANGE && !e.laserCharging && !e.laserFiring && e.laserCooldown <= 0) {
        e.laserCharging = true; e.laserChargeTimer = LASER_E_CHARGE; e.laserAngle = a;
      }
      if (e.laserCharging) {
        e.laserChargeTimer--; e.laserAngle = a;
        if (e.laserChargeTimer <= 0) { e.laserCharging = false; e.laserFiring = true; e.laserFireTimer = LASER_E_FIRE; }
      } else if (e.laserFiring) {
        e.laserFireTimer--;
        // Deal damage along beam
        const la = e.laserAngle;
        const playerDist = dist(e, player);
        if (Math.abs(Math.atan2(player.y - e.y, player.x - e.x) - la) < 0.3 && playerDist < LASER_E_RANGE) {
          player.hp -= LASER_E_DPS; updateHpDisplay();
        }
        // Laser hits P2
        if (isCoop && player2 && player2.hp > 0) {
          const p2Dist = dist(e, player2);
          if (Math.abs(Math.atan2(player2.y - e.y, player2.x - e.x) - la) < 0.3 && p2Dist < LASER_E_RANGE) {
            player2.hp -= LASER_E_DPS; updateHpDisplay();
          }
        }
        for (const b of buildings) {
          if (b.hp <= 0) continue;
          const bc = { x: b.x + BUILD_SIZE/2, y: b.y + BUILD_SIZE/2 };
          const bd = dist(e, bc);
          if (bd < LASER_E_RANGE && Math.abs(Math.atan2(bc.y - e.y, bc.x - e.x) - la) < 0.3) b.hp -= LASER_E_DPS * 0.5;
        }
        if (e.laserFireTimer <= 0) { e.laserFiring = false; e.laserCooldown = LASER_E_COOLDOWN; }
      }
      // Laser enemies stop moving when firing/charging, move slowly toward target otherwise
      if (!e.laserCharging && !e.laserFiring) {
        if (targetD > LASER_E_RANGE * 0.6) {
          // Use flow field for navigation
          let laserUseFF = flowField;
          if (isCoop && player2 && player2.hp > 0 && flowField2 && dist(e, player2) < dist(e, player)) laserUseFF = flowField2;
          const laserFFAngle = laserUseFF ? getFlowAngle(e.x, e.y, laserUseFF) : null;
          const laserMoveAngle = laserFFAngle !== null ? laserFFAngle : a;
          let ledx = Math.cos(laserMoveAngle) * e.speed * 0.7, ledy = Math.sin(laserMoveAngle) * e.speed * 0.7;
          moveWithCollision(e, ledx, ledy, e.size);
        }
      }
      if (e.attackCD > 0) e.attackCD--;
      continue;
    }

    // === CHARGER ENEMY AI ===
    if (e.type === 'charger') {
      if (e.chargeCooldown > 0) e.chargeCooldown--;
      if (e.isCharging) {
        moveWithCollision(e, e.chargeDX, e.chargeDY, e.size);
        e.chargeWindup--;
        if (e.chargeWindup <= 0) { e.isCharging = false; e.stunTimer = CHARGER_STUN; e.chargeCooldown = 200; }
        // Check wall collision for stun
        if (isObstacle(e.x + e.chargeDX * 2, e.y + e.chargeDY * 2)) {
          e.isCharging = false; e.stunTimer = CHARGER_STUN;
          spawnParticles(e.x, e.y, '#ffffff', 8, 4);
        }
        // Charger collision with player
        if (dist(e, player) < e.size + PLAYER_R + 4 && e.attackCD <= 0) {
          player.hp -= e.damage * 2; e.attackCD = 60;
          spawnParticles(player.x, player.y, '#ff0000', 10, 5);
          updateHpDisplay();
          e.isCharging = false; e.stunTimer = CHARGER_STUN;
        }
        // Charger collision with P2
        if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < e.size + PLAYER_R + 4 && e.attackCD <= 0) {
          player2.hp -= e.damage * 2; e.attackCD = 60;
          spawnParticles(player2.x, player2.y, '#ff0000', 10, 5);
          updateHpDisplay();
          e.isCharging = false; e.stunTimer = CHARGER_STUN;
        }
        if (e.attackCD > 0) e.attackCD--;
        continue;
      }
      if (e.chargeWindup > 0 && !e.isCharging) {
        e.chargeWindup--;
        if (e.chargeWindup <= 0) {
          e.isCharging = true; e.chargeWindup = 12;
          let chargeTarget = player;
          if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < dist(e, player)) chargeTarget = player2;
          const ca = Math.atan2(chargeTarget.y - e.y, chargeTarget.x - e.x);
          e.chargeDX = Math.cos(ca) * CHARGER_SPEED; e.chargeDY = Math.sin(ca) * CHARGER_SPEED;
        }
        if (e.attackCD > 0) e.attackCD--;
        continue;
      }
      if (targetD < 200 && e.chargeCooldown <= 0 && !e.isCharging) {
        e.chargeWindup = CHARGER_WINDUP; e.chargeCooldown = 300;
      }
      // Normal movement otherwise - fall through to default movement below
    }

    // === MINER ENEMY AI (drops mines) ===
    if (e.type === 'miner') {
      e.mineCD--; if (e.mineCD <= 0) { e.mineCD = 180 + Math.floor(Math.random() * 120); spawnMine(e.x, e.y, e.damage); }
    }

    // === HEAT EMITTER AI (radius damage aura) ===
    if (e.type === 'heat') {
      const pd = Math.hypot(e.x - player.x, e.y - player.y);
      if (pd < HEAT_RADIUS) {
        player.hp -= HEAT_DPS;
        updateHpDisplay();
      }
      if (isCoop && player2 && player2.hp > 0) {
        const p2d = Math.hypot(e.x - player2.x, e.y - player2.y);
        if (p2d < HEAT_RADIUS) { player2.hp -= HEAT_DPS; updateHpDisplay(); }
      }
      for (const b of buildings) {
        if (b.hp <= 0) continue;
        const bd = Math.hypot(e.x - (b.x + BUILD_SIZE / 2), e.y - (b.y + BUILD_SIZE / 2));
        if (bd < HEAT_RADIUS) b.hp -= HEAT_DPS * 0.3;
      }
    }

    // === PHASE-THROUGH STUCK DETECTION ===
    // If enemy barely moved since last frame, increment stuck timer
    const movedDist = Math.abs(e.x - e._prevX) + Math.abs(e.y - e._prevY);
    if (movedDist < 0.3) {
      e._phaseTimer++;
    } else {
      // Moving fine — if phasing, keep it for a bit to clear the obstacle
      if (!e._phasing) e._phaseTimer = Math.max(0, e._phaseTimer - 2);
    }
    // After 5 seconds stuck (300 frames), enable phasing
    if (e._phaseTimer >= 300) e._phasing = true;
    // Once phasing and moving freely again, disable after clearing
    if (e._phasing && movedDist > 1.0) {
      e._phaseTimer = Math.max(0, e._phaseTimer - 4);
      if (e._phaseTimer < 150) e._phasing = false;
    }
    e._prevX = e.x; e._prevY = e.y;

    // === DEFAULT MOVEMENT — Flow Field + Local Avoidance ===
    let edx = Math.cos(a) * e.speed, edy = Math.sin(a) * e.speed;

    // Pick the best flow field (closest player)
    let useFF = flowField;
    if (isCoop && player2 && player2.hp > 0 && flowField2) {
      const d1 = dist(e, player), d2 = dist(e, player2);
      if (d2 < d1) useFF = flowField2;
    }

    // Try flow field direction first
    const ffAngle = useFF ? getFlowAngle(e.x, e.y, useFF) : null;

    if (ffAngle !== null) {
      // Blend flow field direction with direct target angle for smoother movement
      // When close to target, prefer direct; when far/obstructed, prefer flow field
      const directBlocked = isObstacle(e.x + Math.cos(a) * e.speed * 6, e.y + Math.sin(a) * e.speed * 6);
      let moveAngle;
      if (directBlocked) {
        moveAngle = ffAngle; // trust the flow field
      } else {
        // Blend: 70% flow field, 30% direct (keeps them from getting too robotic)
        const ffDX = Math.cos(ffAngle), ffDY = Math.sin(ffAngle);
        const dirDX = Math.cos(a), dirDY = Math.sin(a);
        const blendX = ffDX * 0.7 + dirDX * 0.3;
        const blendY = ffDY * 0.7 + dirDY * 0.3;
        moveAngle = Math.atan2(blendY, blendX);
      }
      edx = Math.cos(moveAngle) * e.speed;
      edy = Math.sin(moveAngle) * e.speed;
    }

    // Local obstacle avoidance (skip if phasing through)
    if (!e._phasing) {
      const lookAhead = 4;
      const aheadX = e.x + edx * lookAhead, aheadY = e.y + edy * lookAhead;
      let localBlocked = isObstacle(aheadX, aheadY);
      if (!localBlocked) {
        for (const b of buildings) {
          if (b.hp > 0 && circleRect(aheadX, aheadY, e.size * 0.6, b.x, b.y, BUILD_SIZE, BUILD_SIZE)) { localBlocked = true; break; }
        }
      }
      if (localBlocked) {
        const curAngle = Math.atan2(edy, edx);
        let bestA = curAngle, bestScore = -1;
        for (const off of [Math.PI/6, -Math.PI/6, Math.PI/3, -Math.PI/3, Math.PI/2, -Math.PI/2, Math.PI*2/3, -Math.PI*2/3]) {
          const tryA = curAngle + off;
          const tx = e.x + Math.cos(tryA) * e.speed * lookAhead;
          const ty = e.y + Math.sin(tryA) * e.speed * lookAhead;
          let clear = !isObstacle(tx, ty);
          if (clear) { for (const b of buildings) { if (b.hp > 0 && circleRect(tx, ty, e.size * 0.6, b.x, b.y, BUILD_SIZE, BUILD_SIZE)) { clear = false; break; } } }
          if (clear) {
            const score = Math.cos(off) + 1;
            if (score > bestScore) { bestScore = score; bestA = tryA; }
          }
        }
        if (bestScore >= 0) { edx = Math.cos(bestA) * e.speed; edy = Math.sin(bestA) * e.speed; }
        else { edx = 0; edy = 0; }
      }
    } else {
      // Phasing — move directly toward target, ignoring obstacles
      edx = Math.cos(a) * e.speed;
      edy = Math.sin(a) * e.speed;
    }

    // Check if movement would collide with a building — if so, attack it (skip if phasing)
    let blocked = false;
    if (!e._phasing) {
      for (const b of buildings) {
        if (b.hp > 0 && circleRect(e.x + edx, e.y + edy, e.size, b.x, b.y, BUILD_SIZE, BUILD_SIZE)) {
          blocked = true;
          if (e.attackCD <= 0) { b.hp -= e.damage; e.attackCD = 30; spawnParticles(b.x + BUILD_SIZE/2, b.y + BUILD_SIZE/2, '#ffaa00', 4, 2); }
          break;
        }
      }
    }
    if (!blocked) moveWithCollision(e, edx, edy, e.size, e._phasing);
    if (e.attackCD > 0) e.attackCD--;
    if (targetBuilding && targetD < e.size + BUILD_SIZE * 0.7 && e.attackCD <= 0) {
      targetBuilding.hp -= e.damage; e.attackCD = 30;
      spawnParticles(targetBuilding.x + BUILD_SIZE/2, targetBuilding.y + BUILD_SIZE/2, '#ffaa00', 4, 2);
    }
    if (dist(e, player) < e.size + PLAYER_R + 4 && e.attackCD <= 0) {
      player.hp -= e.damage; e.attackCD = 30;
      spawnParticles(player.x, player.y, '#ff0000', 6, 3);
      updateHpDisplay();
    }
    // Normal melee P2
    if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < e.size + PLAYER_R + 4 && e.attackCD <= 0) {
      player2.hp -= e.damage; e.attackCD = 30;
      spawnParticles(player2.x, player2.y, '#ff0000', 6, 3);
      updateHpDisplay();
    }
    // Melee attack spacemen
    if (e.attackCD <= 0) {
      for (const sm of spacemen) {
        if (sm.hp > 0 && dist(e, sm) < e.size + sm.size + 4) {
          sm.hp -= e.damage; e.attackCD = 30;
          spawnParticles(sm.x, sm.y, '#4488ff', 4, 3);
          break;
        }
      }
    }
  }

  // Remove dead buildings
  for (let i = buildings.length - 1; i >= 0; i--) {
    if (buildings[i].hp <= 0) { spawnParticles(buildings[i].x + BUILD_SIZE/2, buildings[i].y + BUILD_SIZE/2, '#ff8800', 10, 4); buildings.splice(i, 1); }
  }

  // -- Collect orbs --
  for (let i = orbs.length - 1; i >= 0; i--) {
    const o = orbs[i]; o.pulse += 0.05;
    let collector = null;
    if (dist(player, o) < PLAYER_R + ENERGY_ORB_R + 4) { collector = player; }
    if (!collector && isCoop && player2 && player2.hp > 0 && dist(player2, o) < PLAYER_R + ENERGY_ORB_R + 4) { collector = player2; }
    if (collector) {
      energy += 5;
      // Heal the collector by 15 HP
      collector.hp = Math.min(collector.hp + 15, collector.maxHp);
      spawnParticles(o.x, o.y, '#ffdd00', 6, 3);
      spawnParticles(collector.x, collector.y, '#44ff44', 4, 2);
      orbs.splice(i, 1);
      document.getElementById('energy-display').textContent = energy; updateBuildButtons();
      updateHpDisplay();
    }
  }

  // -- Generators (level-scaled) --
  generatorTimer++;
  if (generatorTimer >= 90) {
    generatorTimer = 0;
    for (const b of buildings) {
      if (b.type === 'generator' && b.hp > 0) {
        const lv = b.level || 1;
        energy += 1 + lv; // level 1=2, level 2=3, level 3=4
        spawnParticles(b.x + BUILD_SIZE/2, b.y + BUILD_SIZE/2, '#ffdd00', 2 + lv, 2);
      }
    }
    document.getElementById('energy-display').textContent = energy; updateBuildButtons();
  }

  // -- Barracks: spawn spacemen (level-scaled) --
  for (const b of buildings) {
    if (b.type !== 'barracks' || b.hp <= 0) continue;
    const lv = b.level || 1;
    const maxPerBarracks = BARRACKS_MAX_MEN + playerUpgrades.squad + (lv - 1);
    const bSpawnRate = Math.floor(BARRACKS_SPAWN_RATE * Math.pow(0.85, lv - 1));
    if (!b.spawnTimer) b.spawnTimer = 0;
    b.spawnTimer++;
    const myMen = spacemen.filter(s => s.barracksRef === b).length;
    if (b.spawnTimer >= bSpawnRate && myMen < maxPerBarracks) {
      b.spawnTimer = 0;
      const sx = b.x + BUILD_SIZE / 2 + (Math.random() - 0.5) * 30;
      const sy = b.y + BUILD_SIZE + 10;
      const sPos = findValidPosition(sx, sy, SPACEMAN_R);
      const bonusDmg = playerUpgrades.squad * 3;
      const bonusHp = playerUpgrades.squad * 10;
      spacemen.push({
        x: sPos.x, y: sPos.y, hp: SPACEMAN_HP + bonusHp, maxHp: SPACEMAN_HP + bonusHp,
        speed: SPACEMAN_SPEED, damage: SPACEMAN_DMG + bonusDmg, attackCD: 0,
        size: SPACEMAN_R, barracksRef: b
      });
      spawnParticles(sPos.x, sPos.y, '#44aaff', 5, 3);
    }
  }

  // -- Spacemen AI --
  for (let i = spacemen.length - 1; i >= 0; i--) {
    const s = spacemen[i];
    if (s.hp <= 0) { spawnParticles(s.x, s.y, '#4488ff', 8, 3); spacemen.splice(i, 1); continue; }
    let closest = null, closestD = Infinity;
    for (const e of enemies) { const d = dist(s, e); if (d < closestD) { closest = e; closestD = d; } }
    if (closest) {
      const a = Math.atan2(closest.y - s.y, closest.x - s.x);
      if (closestD > closest.size + s.size + 4) {
        moveWithCollision(s, Math.cos(a) * s.speed, Math.sin(a) * s.speed, s.size);
      }
      if (closestD < closest.size + s.size + 8 && s.attackCD <= 0) {
        closest.hp -= s.damage; s.attackCD = SPACEMAN_ATTACK_CD;
        spawnParticles(closest.x, closest.y, '#44aaff', 3, 2);
        if (closest.hp <= 0) { const idx = enemies.indexOf(closest); if (idx >= 0) killEnemy(closest, idx); }
      }
    } else if (s.barracksRef && s.barracksRef.hp > 0) {
      const bx = s.barracksRef.x + BUILD_SIZE / 2, by = s.barracksRef.y + BUILD_SIZE / 2;
      if (dist(s, { x: bx, y: by }) > 80) {
        const a = Math.atan2(by - s.y, bx - s.x);
        moveWithCollision(s, Math.cos(a) * s.speed * 0.5, Math.sin(a) * s.speed * 0.5, s.size);
      }
    }
    if (s.attackCD > 0) s.attackCD--;
  }

  // -- Particles --
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.95; p.vy *= 0.95; p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // ========================================
  // WAVE STATE MACHINE
  // ========================================
  if (wavePhase === 'countdown') {
    betweenTimer--;
    if (betweenTimer <= 0) startWave();
    if (frameCount % 15 === 0) updateWaveHUD();
  } else if (wavePhase === 'active') {
    const cfg = WAVE_CONFIG[wave - 1];
    if (enemiesSpawned < totalWaveEnemies) {
      spawnTimer--; if (spawnTimer <= 0) { spawnEnemy(); spawnTimer = isCoop ? Math.floor(cfg.spawnRate * COOP_MULT.spawnRate) : cfg.spawnRate; }
    }
    // Spawn boss at 50% through the wave
    if (cfg.boss && !bossSpawned && enemiesSpawned >= Math.floor(totalWaveEnemies / 2)) {
      bossSpawned = true; spawnBoss(cfg.boss);
    }
    // Wave cleared when all enemies (including boss) are dead
    if (enemiesSpawned >= totalWaveEnemies && enemies.length === 0) {
      wavePhase = 'upgrades'; showingUpgrades = true; activeBoss = null;
      document.getElementById('boss-bar').classList.remove('show');
      updateWaveHUD();
    }
    if (frameCount % 10 === 0) updateWaveHUD();
  } else if (wavePhase === 'upgrades') {
    // Handled by draw + click - wait for player to dismiss
  } else if (wavePhase === 'cleared') {
    betweenTimer--;
    if (wave >= MAX_WAVES && betweenTimer <= 0) { wavePhase = 'victory'; showVictory(); }
    else if (wave < MAX_WAVES && betweenTimer <= 0) { wavePhase = 'countdown'; betweenTimer = BETWEEN_WAVE_SECONDS * 60; updateWaveHUD(); }
    if (frameCount % 15 === 0) updateWaveHUD();
  } else if (wavePhase === 'endless') {
    endlessTimer++;
    // Spawn enemies continuously
    const endlessSpawnRate = isCoop ? Math.floor(getEndlessConfig().spawnRate * COOP_MULT.spawnRate) : getEndlessConfig().spawnRate;
    spawnTimer--; if (spawnTimer <= 0) { spawnEnemy(); spawnTimer = endlessSpawnRate; }
    // Escalate difficulty every 30 seconds
    if (endlessTimer % 1800 === 0) endlessLevel++;
    // Spawn boss every 2 minutes
    endlessBossTimer++; if (endlessBossTimer >= 7200) {
      endlessBossTimer = 0;
      const bossKeys = ['sentinel','warden','overlord','core'];
      spawnBoss(bossKeys[Math.min(Math.floor(endlessLevel / 2), bossKeys.length - 1)]);
    }
    // Update endless timer display
    if (frameCount % 30 === 0) {
      const secs = Math.floor(endlessTimer / 60);
      const m = Math.floor(secs / 60), s = secs % 60;
      document.getElementById('endless-timer').textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    if (frameCount % 10 === 0) updateWaveHUD();
  }

  // -- Wave banner --
  if (waveBannerTimer > 0) { waveBannerTimer--; if (waveBannerTimer <= 0) document.getElementById('wave-banner').classList.remove('show'); }

  // -- Camera (follows local player) --
  const camTarget = (isClient && player2) ? player2 : player;
  camera.x = camTarget.x - W / 2; camera.y = camTarget.y - H / 2;
  camera.x = Math.max(0, Math.min(WORLD_W - W, camera.x));
  camera.y = Math.max(0, Math.min(WORLD_H - H, camera.y));

  // -- Score display --
  document.getElementById('score-display').textContent = `Kills: ${totalKills} | Points: ${upgradePoints}`;

  // -- Network state send (HOST) --
  if (isHost && isCoop && conn && conn.open && frameCount % NET_SEND_INTERVAL === 0) {
    conn.send({ type: 'state', state: packGameState() });
  }

  // -- Game over --
  const bothDead = isCoop ? (player.hp <= 0 && (!player2 || player2.hp <= 0)) : (player.hp <= 0);
  if (bothDead && !gameOverShown) {
    gameOverShown = true; gameRunning = false;
    const title = document.getElementById('go-title');
    if (endlessMode) {
      const secs = Math.floor(endlessTimer / 60);
      const m = Math.floor(secs / 60), s = secs % 60;
      const timeStr = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      title.textContent = 'ENDLESS SIEGE OVER';
      title.style.color = '#ff6600'; title.style.textShadow = '0 0 30px rgba(255,100,0,0.6)';
      const isHighScore = secs > highScore;
      if (isHighScore) { highScore = secs; localStorage.setItem('energySiegeHighScore', String(secs)); }
      const hsM = Math.floor(highScore / 60), hsS = highScore % 60;
      const hsStr = `${String(hsM).padStart(2,'0')}:${String(hsS).padStart(2,'0')}`;
      document.getElementById('go-stats').textContent = `Survived: ${timeStr} | Kills: ${totalKills}${isHighScore ? ' | NEW HIGH SCORE!' : ` | Best: ${hsStr}`}`;
    } else {
      title.textContent = 'OVERLOADED'; title.style.color = '#ff2222'; title.style.textShadow = '0 0 30px rgba(255,0,0,0.6)';
      document.getElementById('go-stats').textContent = `Destroyed on Wave ${wave} / ${MAX_WAVES} | Kills: ${totalKills}`;
    }
    document.getElementById('game-over').classList.add('show');
  }
}

function killEnemy(e, index) {
  const isBoss = e.isBoss;
  spawnParticles(e.x, e.y, isBoss ? '#ffaa00' : '#ff6600', isBoss ? 25 : 12, isBoss ? 8 : 5);
  const orbCount = isBoss ? 15 + Math.floor(Math.random() * 10) : 2 + Math.floor(Math.random() * 2);
  for (let k = 0; k < orbCount; k++) {
    orbs.push({ x: e.x + (Math.random()-0.5)*40, y: e.y + (Math.random()-0.5)*40, pulse: Math.random()*Math.PI*2 });
  }
  // Points: boss=5, special=2, normal=1
  const pts = isBoss ? 5 : (e.type !== 'normal' ? 2 : 1);
  upgradePoints += pts; totalKills++; waveKills++;
  // Splitter: spawn 2 smaller copies
  if (e.canSplit && e.type === 'splitter' && !isBoss) {
    for (let s = 0; s < 2; s++) {
      const angle = Math.random() * Math.PI * 2;
      const spPos = findValidPosition(e.x + Math.cos(angle)*15, e.y + Math.sin(angle)*15, 8);
      enemies.push({
        x: spPos.x, y: spPos.y, size: Math.max(8, Math.floor(e.size * 0.6)),
        hp: Math.floor(e.maxHp * 0.35), maxHp: Math.floor(e.maxHp * 0.35),
        speed: e.speed * 1.3, attackCD: 0, damage: Math.floor(e.damage * 0.6),
        type: 'splitter', isBoss: false, spawnFrame: frameCount, isRaged: false, canSplit: false,
        laserCharging:false,laserChargeTimer:0,laserFiring:false,laserFireTimer:0,laserCooldown:0,laserAngle:0,
        mineCD:0,chargeWindup:0,isCharging:false,chargeDX:0,chargeDY:0,chargeCooldown:0,stunTimer:0 });
    }
  }
  if (isBoss && activeBoss === e) { activeBoss = null; document.getElementById('boss-bar').classList.remove('show'); }
  enemies.splice(index, 1);
}

function showVictory() {
  victoryShown = true;
  updateWaveHUD();
  // Show story screen with lore
  document.getElementById('story-text').innerHTML =
    'The energy grid held. Against impossible odds, the siege was broken &mdash; wave after wave of overloaded drones, heat emitters, and colossal bosses repelled by one operator\'s resolve.' +
    '<br><br>But the readings are spiking again. The energy signatures beyond the perimeter are growing stronger, more chaotic. This wasn\'t the invasion &mdash; it was the scouting party.' +
    '<br><br>The Endless Siege has begun. There is no wave 11. There is only survival.';
  document.getElementById('story-stats').textContent = `${MAX_WAVES} waves cleared | ${totalKills} kills | ${upgradePoints} upgrade points earned`;
  document.getElementById('story-screen').classList.add('show');
}

function continueToEndless() {
  document.getElementById('story-screen').classList.remove('show');
  gameRunning = true; victoryShown = false; gameOverShown = false;
  // Heal player(s)
  player.hp = Math.min(player.hp + 50, player.maxHp);
  if (isCoop && player2) { player2.hp = Math.min(player2.hp + 50, player2.maxHp); }
  updateHpDisplay();
  startEndless();
}

// ---- Drawing ----
function draw() {
  const biome = BIOMES[currentBiome];
  ctx.fillStyle = biome.bgFill;
  ctx.fillRect(0, 0, W, H);
  if (!gameRunning && !gameOverShown && !victoryShown && !gamePaused) return;

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  // Grid
  ctx.strokeStyle = biome.gridStroke;
  ctx.lineWidth = 1;
  const gx0 = Math.floor(camera.x / TILE) * TILE;
  const gy0 = Math.floor(camera.y / TILE) * TILE;
  for (let x = gx0; x < camera.x + W + TILE; x += TILE) {
    ctx.beginPath(); ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + H); ctx.stroke();
  }
  for (let y = gy0; y < camera.y + H + TILE; y += TILE) {
    ctx.beginPath(); ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + W, y); ctx.stroke();
  }

  // Obstacles
  const [shR, shG, shB] = biome.lakeShimmerBase;
  for (const o of obstacles) {
    if (o.x + TILE < camera.x || o.x > camera.x + W || o.y + TILE < camera.y || o.y > camera.y + H) continue;
    if (o.type === 'tree') {
      // Tree: brown trunk + green canopy circle with sway
      const tcx = o.x + TILE / 2, tcy = o.y + TILE / 2;
      const sway = Math.sin(frameCount * 0.02 + o.x * 0.1) * 1.5;
      // Shadow behind canopy
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath(); ctx.arc(tcx + sway + 2, tcy - 6 + 2, 13, 0, Math.PI * 2); ctx.fill();
      // Trunk
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(tcx - 3, tcy + 2, 6, 14);
      // Canopy
      ctx.fillStyle = '#1a6a2a';
      ctx.beginPath(); ctx.arc(tcx + sway, tcy - 6, 13, 0, Math.PI * 2); ctx.fill();
      // Lighter canopy highlight
      ctx.fillStyle = '#2a8a3a';
      ctx.beginPath(); ctx.arc(tcx + sway - 3, tcy - 9, 7, 0, Math.PI * 2); ctx.fill();
    } else if (o.type === 'rock') {
      ctx.fillStyle = biome.rockFill;
      ctx.fillRect(o.x + 1, o.y + 1, TILE - 2, TILE - 2);
      ctx.strokeStyle = biome.rockStroke;
      ctx.strokeRect(o.x + 1, o.y + 1, TILE - 2, TILE - 2);
      ctx.fillStyle = biome.rockDetail;
      ctx.fillRect(o.x + 8, o.y + 6, 10, 6);
      ctx.fillRect(o.x + 20, o.y + 22, 12, 8);
      if (biome.decorateRock) biome.decorateRock(ctx, o.x, o.y, TILE, frameCount);
    } else {
      ctx.fillStyle = biome.lakeFill;
      ctx.fillRect(o.x + 1, o.y + 1, TILE - 2, TILE - 2);
      const shimmer = Math.sin(frameCount * 0.03 + o.x * 0.1) * 0.15 + 0.2;
      ctx.fillStyle = `rgba(${shR},${shG},${shB},${shimmer})`;
      ctx.fillRect(o.x + 4, o.y + 4, TILE - 8, TILE - 8);
      if (biome.decorateLake) biome.decorateLake(ctx, o.x, o.y, TILE, frameCount);
    }
  }

  // Buildings
  for (const b of buildings) {
    const bx = b.x, by = b.y;
    if (bx + BUILD_SIZE < camera.x || bx > camera.x + W || by + BUILD_SIZE < camera.y || by > camera.y + H) continue;
    if (b.type === 'wall') {
      ctx.fillStyle = '#556677';
      ctx.fillRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      ctx.strokeStyle = '#7799aa'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      ctx.strokeStyle = '#445566';
      ctx.beginPath();
      ctx.moveTo(bx + 2, by + 2); ctx.lineTo(bx + BUILD_SIZE - 2, by + BUILD_SIZE - 2);
      ctx.moveTo(bx + BUILD_SIZE - 2, by + 2); ctx.lineTo(bx + 2, by + BUILD_SIZE - 2);
      ctx.stroke();
    } else if (b.type === 'generator') {
      ctx.fillStyle = '#334400';
      ctx.fillRect(bx + 3, by + 3, BUILD_SIZE - 6, BUILD_SIZE - 6);
      ctx.strokeStyle = '#66aa00'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 3, by + 3, BUILD_SIZE - 6, BUILD_SIZE - 6);
      const glow = Math.sin(frameCount * 0.08) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,221,0,${glow})`;
      ctx.beginPath();
      ctx.moveTo(bx + 22, by + 6); ctx.lineTo(bx + 14, by + 20); ctx.lineTo(bx + 20, by + 20);
      ctx.lineTo(bx + 18, by + 34); ctx.lineTo(bx + 26, by + 18); ctx.lineTo(bx + 20, by + 18);
      ctx.closePath(); ctx.fill();
    } else if (b.type === 'turret') {
      ctx.fillStyle = '#443322';
      ctx.fillRect(bx + 4, by + 4, BUILD_SIZE - 8, BUILD_SIZE - 8);
      ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 4, by + 4, BUILD_SIZE - 8, BUILD_SIZE - 8);
      const ta = b.angle || 0;
      const tcx = bx + BUILD_SIZE / 2, tcy = by + BUILD_SIZE / 2;
      ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(tcx, tcy);
      ctx.lineTo(tcx + Math.cos(ta) * 18, tcy + Math.sin(ta) * 18); ctx.stroke();
      ctx.fillStyle = '#ff6600';
      ctx.beginPath(); ctx.arc(tcx, tcy, 5, 0, Math.PI * 2); ctx.fill();
    } else if (b.type === 'laser') {
      ctx.fillStyle = '#221133';
      ctx.fillRect(bx + 3, by + 3, BUILD_SIZE - 6, BUILD_SIZE - 6);
      ctx.strokeStyle = '#bb44ff'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 3, by + 3, BUILD_SIZE - 6, BUILD_SIZE - 6);
      const lcx = bx + BUILD_SIZE / 2, lcy = by + BUILD_SIZE / 2;
      const crystalGlow = Math.sin(frameCount * 0.1) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(200,100,255,${crystalGlow})`;
      ctx.beginPath();
      ctx.moveTo(lcx, lcy - 10); ctx.lineTo(lcx + 8, lcy);
      ctx.lineTo(lcx, lcy + 10); ctx.lineTo(lcx - 8, lcy);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#dd88ff'; ctx.lineWidth = 1; ctx.stroke();
      if (b.laserTarget) {
        const t = b.laserTarget;
        ctx.strokeStyle = `rgba(200,80,255,${0.15 + Math.sin(frameCount * 0.2) * 0.1})`;
        ctx.lineWidth = 8;
        ctx.beginPath(); ctx.moveTo(lcx, lcy); ctx.lineTo(t.x, t.y); ctx.stroke();
        ctx.strokeStyle = `rgba(255,150,255,${0.6 + Math.sin(frameCount * 0.3) * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(lcx, lcy); ctx.lineTo(t.x, t.y); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(lcx, lcy); ctx.lineTo(t.x, t.y); ctx.stroke();
      }
    } else if (b.type === 'barracks') {
      ctx.fillStyle = '#1a2a44';
      ctx.fillRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      ctx.strokeStyle = '#4488ff'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      ctx.fillStyle = '#2a4a6a';
      ctx.fillRect(bx + 14, by + 24, 12, 14);
      const bcx2 = bx + BUILD_SIZE / 2, bcy2 = by + 12;
      ctx.fillStyle = '#4488ff';
      ctx.beginPath(); ctx.arc(bcx2, bcy2, 7, Math.PI, 0); ctx.fill();
      ctx.fillStyle = '#88ccff';
      ctx.fillRect(bcx2 - 5, bcy2 - 1, 10, 4);
      const myMen = spacemen.filter(s => s.barracksRef === b).length;
      const bLv = b.level || 1;
      const maxM = BARRACKS_MAX_MEN + playerUpgrades.squad + (bLv - 1);
      ctx.fillStyle = '#88ccff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
      ctx.fillText(`${myMen}/${maxM}`, bx + BUILD_SIZE / 2, by - 2);
    } else if (b.type === 'catapult') {
      ctx.fillStyle = '#3a2a10';
      ctx.fillRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      ctx.strokeStyle = '#cc6600'; ctx.lineWidth = 2;
      ctx.strokeRect(bx + 2, by + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
      // Arm
      const ca = b.angle || 0;
      const ccx = bx + BUILD_SIZE / 2, ccy = by + BUILD_SIZE / 2;
      ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(ccx, ccy + 6);
      ctx.lineTo(ccx + Math.cos(ca) * 16, ccy + Math.sin(ca) * 16 - 8); ctx.stroke();
      // Bucket
      ctx.fillStyle = '#cc6600';
      ctx.beginPath(); ctx.arc(ccx + Math.cos(ca) * 16, ccy + Math.sin(ca) * 16 - 8, 5, 0, Math.PI * 2); ctx.fill();
      // Range indicator on hover handled separately
    }
    if (b.hp < b.maxHp) {
      const hpPct = b.hp / b.maxHp;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(bx, by - 8, BUILD_SIZE, 5);
      ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa00' : '#ff2222';
      ctx.fillRect(bx, by - 8, BUILD_SIZE * hpPct, 5);
    }
    // Level pips
    const bLvl = b.level || 1;
    if (bLvl > 1) {
      const pipY = by + BUILD_SIZE + 4;
      const pipStartX = bx + BUILD_SIZE / 2 - (bLvl - 1) * 5;
      for (let p = 0; p < bLvl; p++) {
        ctx.fillStyle = p < bLvl ? '#00ffcc' : '#333';
        ctx.beginPath(); ctx.arc(pipStartX + p * 10, pipY, 3, 0, Math.PI * 2); ctx.fill();
      }
    }
  }

  // Building hover tooltip (upgrade info)
  if (!selectedBuild && gameRunning && !gamePaused && !showingUpgrades) {
    const hoverB = getBuildingAt(worldMouseX, worldMouseY);
    if (hoverB) {
      const hbx = hoverB.x + BUILD_SIZE / 2, hby = hoverB.y - 18;
      const hLv = hoverB.level || 1;
      // Repair tooltip (if damaged)
      const isDamaged = hoverB.hp < hoverB.maxHp;
      if (isDamaged) {
        const repCost = Math.ceil((hoverB.maxHp - hoverB.hp) / hoverB.maxHp * COSTS[hoverB.type] * 0.5);
        const canRep = energy >= repCost;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(hbx - 55, hby - 44, 110, 18);
        ctx.strokeStyle = canRep ? '#00ff88' : '#666'; ctx.lineWidth = 1;
        ctx.strokeRect(hbx - 55, hby - 44, 110, 18);
        ctx.fillStyle = canRep ? '#00ff88' : '#888'; ctx.font = 'bold 10px Segoe UI'; ctx.textAlign = 'center';
        ctx.fillText(`[R] Repair — ${repCost}E`, hbx, hby - 31);
      }
      const tipY = isDamaged ? hby - 12 : hby - 28;
      if (hLv < BUILD_MAX_LEVEL) {
        const uCost = getUpgradeCostForBuilding(hoverB);
        const canAfford = energy >= uCost;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(hbx - 55, tipY, 110, 26);
        ctx.strokeStyle = canAfford ? '#00ffcc' : '#666'; ctx.lineWidth = 1;
        ctx.strokeRect(hbx - 55, tipY, 110, 26);
        ctx.fillStyle = canAfford ? '#00ffcc' : '#888'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
        ctx.fillText(`Upgrade Lv${hLv + 1} — ${uCost}E`, hbx, tipY + 12);
        ctx.fillStyle = '#888'; ctx.font = '9px Segoe UI';
        ctx.fillText('Right-click', hbx, tipY + 23);
      } else {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(hbx - 35, tipY, 70, 18);
        ctx.fillStyle = '#888'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
        ctx.fillText('MAX LEVEL', hbx, tipY + 13);
      }
      // Show range circle for turret/laser on hover
      if (hoverB.type === 'turret') {
        const tR = TURRET_RANGE * (1 + (hLv - 1) * 0.2);
        ctx.strokeStyle = 'rgba(255,136,0,0.2)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(hbx, hoverB.y + BUILD_SIZE / 2, tR, 0, Math.PI * 2); ctx.stroke();
      } else if (hoverB.type === 'laser') {
        const lR = LASER_RANGE * (1 + (hLv - 1) * 0.15);
        ctx.strokeStyle = 'rgba(200,80,255,0.2)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(hbx, hoverB.y + BUILD_SIZE / 2, lR, 0, Math.PI * 2); ctx.stroke();
      } else if (hoverB.type === 'catapult') {
        const cR = CATAPULT_RANGE * (1 + (hLv - 1) * 0.15);
        ctx.strokeStyle = 'rgba(204,102,0,0.2)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(hbx, hoverB.y + BUILD_SIZE / 2, cR, 0, Math.PI * 2); ctx.stroke();
      }
    }
  }

  // Build preview
  if (selectedBuild) {
    const mx = Math.floor(worldMouseX / TILE) * TILE;
    const my = Math.floor(worldMouseY / TILE) * TILE;
    const canPlace = !isObstacle(mx + TILE / 2, my + TILE / 2) && !isBuildingAt(mx + TILE / 2, my + TILE / 2);
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = canPlace ? '#00ff88' : '#ff2222';
    ctx.fillRect(mx + 2, my + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = canPlace ? '#00ff88' : '#ff2222';
    ctx.lineWidth = 2;
    ctx.strokeRect(mx + 2, my + 2, BUILD_SIZE - 4, BUILD_SIZE - 4);
    if (selectedBuild === 'turret') {
      ctx.strokeStyle = 'rgba(255,136,0,0.2)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(mx + BUILD_SIZE / 2, my + BUILD_SIZE / 2, TURRET_RANGE, 0, Math.PI * 2); ctx.stroke();
    } else if (selectedBuild === 'laser') {
      ctx.strokeStyle = 'rgba(200,80,255,0.2)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(mx + BUILD_SIZE / 2, my + BUILD_SIZE / 2, LASER_RANGE, 0, Math.PI * 2); ctx.stroke();
    } else if (selectedBuild === 'barracks') {
      ctx.strokeStyle = 'rgba(68,136,255,0.15)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(mx + BUILD_SIZE / 2, my + BUILD_SIZE / 2, 80, 0, Math.PI * 2); ctx.stroke();
    }
  }

  // Catapult boulders (arc trajectory)
  for (const cb of catapultBoulders) {
    const p = cb.progress;
    const cx = cb.sx + (cb.tx - cb.sx) * p;
    const cy = cb.sy + (cb.ty - cb.sy) * p;
    const arcH = Math.sin(p * Math.PI) * 120;
    const bx = cx, by = cy - arcH;
    // Shadow on ground
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath(); ctx.ellipse(cx, cy, 8, 4, 0, 0, Math.PI * 2); ctx.fill();
    // Fire trail
    ctx.fillStyle = `rgba(255,100,0,${0.6 - p * 0.4})`;
    ctx.beginPath(); ctx.arc(bx, by, 8 + Math.random() * 3, 0, Math.PI * 2); ctx.fill();
    // Boulder
    ctx.fillStyle = '#cc4400';
    ctx.beginPath(); ctx.arc(bx, by, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff8800';
    ctx.beginPath(); ctx.arc(bx - 1, by - 1, 3, 0, Math.PI * 2); ctx.fill();
  }

  // Energy orbs
  for (const o of orbs) {
    if (o.x < camera.x - 20 || o.x > camera.x + W + 20 || o.y < camera.y - 20 || o.y > camera.y + H + 20) continue;
    const pulse = Math.sin(o.pulse) * 3;
    const r = ENERGY_ORB_R + pulse;
    const grd = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, r * 2.5);
    grd.addColorStop(0, 'rgba(255,221,0,0.3)'); grd.addColorStop(1, 'rgba(255,221,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(o.x, o.y, r * 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffdd00';
    ctx.beginPath(); ctx.arc(o.x, o.y, r, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(o.x, o.y, r * 0.4, 0, Math.PI * 2); ctx.fill();
  }

  // Bullets
  for (const b of bullets) {
    if (b.x < camera.x - 10 || b.x > camera.x + W + 10 || b.y < camera.y - 10 || b.y > camera.y + H + 10) continue;
    let col, trail;
    if (b.owner === 'enemy') { col = '#ff2222'; trail = 'rgba(255,34,34,0.3)'; }
    else if (b.owner === 'player') { col = '#66ccff'; trail = 'rgba(102,204,255,0.3)'; }
    else if (b.owner === 'player2') { col = '#44ff88'; trail = 'rgba(68,255,136,0.3)'; }
    else if (b.owner === 'drone') { col = '#00ffcc'; trail = 'rgba(0,255,204,0.3)'; }
    else if (b.owner === 'drone2') { col = '#66ff99'; trail = 'rgba(102,255,153,0.3)'; }
    else { col = '#ff8800'; trail = 'rgba(255,136,0,0.3)'; }
    ctx.fillStyle = col;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.owner === 'enemy' ? BULLET_R + 1 : BULLET_R, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = trail;
    ctx.beginPath(); ctx.arc(b.x - b.vx * 0.5, b.y - b.vy * 0.5, BULLET_R * 0.7, 0, Math.PI * 2); ctx.fill();
  }

  // Mines
  for (const m of mines) {
    if (m.x < camera.x - 20 || m.x > camera.x + W + 20 || m.y < camera.y - 20 || m.y > camera.y + H + 20) continue;
    const pulse = m.armed ? Math.sin(frameCount * 0.15) * 0.3 + 0.7 : 0.4;
    ctx.fillStyle = m.armed ? `rgba(255,60,0,${pulse})` : 'rgba(180,80,0,0.4)';
    ctx.beginPath(); ctx.arc(m.x, m.y, 8, 0, Math.PI * 2); ctx.fill();
    if (m.armed) { ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, 12 + Math.sin(frameCount*0.2)*3, 0, Math.PI*2); ctx.stroke(); }
    ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(m.x, m.y, 3, 0, Math.PI * 2); ctx.fill();
  }

  // Enemies (type-specific rendering)
  for (const e of enemies) {
    const cullR = (e.type === 'laser' && (e.laserCharging || e.laserFiring)) ? LASER_E_RANGE + 20 : 80;
    if (e.x < camera.x - cullR || e.x > camera.x + W + cullR || e.y < camera.y - cullR || e.y > camera.y + H + cullR) continue;
    const rage = e.isRaged ? Math.sin(frameCount * 0.2) * 0.3 + 0.7 : 0;

    if (e.isBoss) {
      // Boss rendering
      const def = BOSS_DEFS[e.bossKey];
      const bPulse = Math.sin(frameCount * 0.08) * 0.2 + 0.8;
      ctx.shadowColor = def.color; ctx.shadowBlur = 20;
      ctx.fillStyle = def.color;
      ctx.fillRect(e.x - e.size, e.y - e.size, e.size * 2, e.size * 2);
      ctx.shadowBlur = 0;
      // Inner glow
      ctx.fillStyle = '#000';
      ctx.fillRect(e.x - e.size + 5, e.y - e.size + 5, e.size * 2 - 10, e.size * 2 - 10);
      ctx.globalAlpha = bPulse;
      ctx.fillStyle = def.color;
      ctx.fillRect(e.x - e.size + 8, e.y - e.size + 8, e.size * 2 - 16, e.size * 2 - 16);
      ctx.globalAlpha = 1;
      // Boss eyes (larger)
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x - e.size * 0.3, e.y - e.size * 0.2, e.size * 0.2, e.size * 0.15);
      ctx.fillRect(e.x + e.size * 0.1, e.y - e.size * 0.2, e.size * 0.2, e.size * 0.15);
      // Phase 2 indicator for core
      if (e.bossKey === 'core' && e.phase === 2) {
        ctx.strokeStyle = `rgba(255,0,0,${Math.sin(frameCount*0.15)*0.4+0.6})`; ctx.lineWidth = 3;
        ctx.strokeRect(e.x - e.size - 4, e.y - e.size - 4, e.size*2+8, e.size*2+8);
      }
      // Charge windup indicator (Sentinel)
      if (e.chargeWindup > 0 && !e.isCharging) {
        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 10, 0, Math.PI * 2 * (1 - e.chargeWindup / 40)); ctx.stroke();
      }
      // Warden shockwave windup
      if (e.bossKey === 'warden' && e.slamWindup > 0) {
        const pct = 1 - e.slamWindup / 60;
        const pulseR = e.size + 10 + pct * 30;
        ctx.strokeStyle = `rgba(170,68,255,${0.3 + pct * 0.5})`; ctx.lineWidth = 3 + pct * 4;
        ctx.beginPath(); ctx.arc(e.x, e.y, pulseR, 0, Math.PI * 2); ctx.stroke();
        // Fill telegraph circle showing blast radius
        ctx.fillStyle = `rgba(136,0,204,${pct * 0.12})`;
        ctx.beginPath(); ctx.arc(e.x, e.y, 220 * pct, 0, Math.PI * 2); ctx.fill();
        // Exclamation warning
        ctx.fillStyle = `rgba(255,100,255,${Math.sin(frameCount*0.3)*0.3+0.7})`;
        ctx.font = 'bold 18px Segoe UI'; ctx.textAlign = 'center';
        ctx.fillText('SLAM!', e.x, e.y - e.size - 20);
      }
    } else {
      // Regular enemy rendering by type
      let outerColor = '#cc2222', innerColor = '#ff4444';
      if (e.type === 'laser') { outerColor = '#cc22cc'; innerColor = '#ff44ff'; }
      else if (e.type === 'miner') { outerColor = '#cc8800'; innerColor = '#ffaa22'; }
      else if (e.type === 'charger') { outerColor = '#22cccc'; innerColor = '#44ffff'; }
      else if (e.type === 'splitter') { outerColor = '#22cc22'; innerColor = '#44ff44'; }
      else if (e.type === 'heat') { outerColor = '#cc4400'; innerColor = '#ff6622'; }

      ctx.shadowColor = e.isRaged ? '#ff8800' : outerColor; ctx.shadowBlur = e.isRaged ? 15 : 10;

      if (e.type === 'splitter') {
        // Diamond shape for splitters
        ctx.fillStyle = outerColor; ctx.beginPath();
        ctx.moveTo(e.x, e.y - e.size); ctx.lineTo(e.x + e.size, e.y);
        ctx.lineTo(e.x, e.y + e.size); ctx.lineTo(e.x - e.size, e.y); ctx.closePath(); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = innerColor; ctx.beginPath();
        ctx.moveTo(e.x, e.y - e.size + 3); ctx.lineTo(e.x + e.size - 3, e.y);
        ctx.lineTo(e.x, e.y + e.size - 3); ctx.lineTo(e.x - e.size + 3, e.y); ctx.closePath(); ctx.fill();
      } else if (e.type === 'charger') {
        // Triangle for chargers
        ctx.fillStyle = outerColor;
        let chargerFace = player;
        if (isCoop && player2 && player2.hp > 0 && dist(e, player2) < dist(e, player)) chargerFace = player2;
        const ca = Math.atan2(chargerFace.y - e.y, chargerFace.x - e.x);
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(ca);
        ctx.beginPath(); ctx.moveTo(e.size, 0); ctx.lineTo(-e.size, -e.size*0.8); ctx.lineTo(-e.size, e.size*0.8); ctx.closePath(); ctx.fill();
        ctx.shadowBlur = 0; ctx.fillStyle = innerColor;
        ctx.beginPath(); ctx.moveTo(e.size-4, 0); ctx.lineTo(-e.size+4, -e.size*0.5); ctx.lineTo(-e.size+4, e.size*0.5); ctx.closePath(); ctx.fill();
        ctx.restore();
        // Windup indicator
        if (e.chargeWindup > 0 && !e.isCharging) {
          ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 8, 0, Math.PI*2*(1-e.chargeWindup/CHARGER_WINDUP)); ctx.stroke();
        }
      } else {
        // Square for normal, laser, miner
        ctx.fillStyle = outerColor;
        ctx.fillRect(e.x - e.size, e.y - e.size, e.size * 2, e.size * 2);
        ctx.shadowBlur = 0;
        ctx.fillStyle = innerColor;
        ctx.fillRect(e.x - e.size + 3, e.y - e.size + 3, e.size * 2 - 6, e.size * 2 - 6);
      }
      ctx.shadowBlur = 0;

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x - 4, e.y - 3, 3, 3);
      ctx.fillRect(e.x + 2, e.y - 3, 3, 3);

      // Laser enemy: charging/firing beam
      if (e.type === 'laser' && (e.laserCharging || e.laserFiring)) {
        const la = e.laserAngle;
        if (e.laserCharging) {
          const chPct = 1 - e.laserChargeTimer / LASER_E_CHARGE;
          ctx.strokeStyle = `rgba(255,0,255,${chPct * 0.5})`; ctx.lineWidth = 2 + chPct * 3;
          ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + Math.cos(la)*LASER_E_RANGE*chPct, e.y + Math.sin(la)*LASER_E_RANGE*chPct); ctx.stroke();
        } else if (e.laserFiring) {
          ctx.strokeStyle = `rgba(255,100,255,0.3)`; ctx.lineWidth = 10;
          ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + Math.cos(la)*LASER_E_RANGE, e.y + Math.sin(la)*LASER_E_RANGE); ctx.stroke();
          ctx.strokeStyle = '#ff44ff'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + Math.cos(la)*LASER_E_RANGE, e.y + Math.sin(la)*LASER_E_RANGE); ctx.stroke();
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + Math.cos(la)*LASER_E_RANGE, e.y + Math.sin(la)*LASER_E_RANGE); ctx.stroke();
        }
      }

      // Miner: show mine symbol
      if (e.type === 'miner') {
        ctx.fillStyle = '#ffaa00'; ctx.font = `${e.size}px monospace`; ctx.textAlign = 'center';
        ctx.fillText('M', e.x, e.y + e.size * 0.3);
      }

      // Heat emitter: pulsing heat ring
      if (e.type === 'heat') {
        ctx.fillStyle = '#ffcc00'; ctx.font = `${e.size}px monospace`; ctx.textAlign = 'center';
        ctx.fillText('H', e.x, e.y + e.size * 0.3);
        const pulse = Math.sin(frameCount * 0.08) * 0.12 + 0.18;
        ctx.strokeStyle = `rgba(255,100,0,${pulse + 0.1})`; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(e.x, e.y, HEAT_RADIUS, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = `rgba(255,60,0,${pulse * 0.4})`;
        ctx.beginPath(); ctx.arc(e.x, e.y, HEAT_RADIUS, 0, Math.PI * 2); ctx.fill();
      }

      // Rage glow
      if (e.isRaged) {
        ctx.strokeStyle = `rgba(255,140,0,${rage})`; ctx.lineWidth = 2;
        ctx.strokeRect(e.x - e.size - 2, e.y - e.size - 2, e.size*2+4, e.size*2+4);
      }
    }

    // HP bar (all enemies including bosses)
    if (e.hp < e.maxHp) {
      const hpPct = Math.max(0, e.hp / e.maxHp);
      const barW = e.size * 2 + 4;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(e.x - barW / 2, e.y - e.size - 10, barW, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa00' : '#ff2222';
      ctx.fillRect(e.x - barW / 2, e.y - e.size - 10, barW * hpPct, 4);
    }
  }

  // Dash trail
  if (dashTimer > 0) {
    for (let i = 1; i <= 4; i++) {
      ctx.globalAlpha = 0.15 / i;
      ctx.fillStyle = '#00ffff';
      ctx.beginPath();
      ctx.arc(player.x - dashDX * i * 2, player.y - dashDY * i * 2, PLAYER_R - i, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Player
  ctx.shadowColor = dashTimer > 0 ? '#00ffff' : '#4488ff';
  ctx.shadowBlur = dashTimer > 0 ? 25 : 15;
  ctx.fillStyle = dashTimer > 0 ? '#00aacc' : '#2266cc';
  ctx.beginPath(); ctx.arc(player.x, player.y, PLAYER_R, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = dashTimer > 0 ? '#44eeff' : '#4499ff';
  ctx.beginPath(); ctx.arc(player.x, player.y, PLAYER_R - 3, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#88ccff'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(player.x, player.y);
  ctx.lineTo(player.x + Math.cos(player.angle) * (PLAYER_R + 8), player.y + Math.sin(player.angle) * (PLAYER_R + 8));
  ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(player.x + Math.cos(player.angle) * 6, player.y + Math.sin(player.angle) * 6, 4, 0, Math.PI * 2); ctx.fill();
  if (player.hp < player.maxHp) {
    const hpPct = Math.max(0, player.hp / player.maxHp);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(player.x - 20, player.y - PLAYER_R - 12, 40, 5);
    ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa00' : '#ff2222';
    ctx.fillRect(player.x - 20, player.y - PLAYER_R - 12, 40 * hpPct, 5);
  }
  // P1 label in co-op
  if (isCoop) {
    ctx.fillStyle = '#88ccff'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText('P1', player.x, player.y + PLAYER_R + 14);
  }

  // Player 2
  if (isCoop && player2) {
    const p2alive = player2.hp > 0;
    if (p2alive) {
      // Dash trail P2
      if (dashTimer2 > 0) {
        for (let i = 1; i <= 4; i++) {
          ctx.globalAlpha = 0.15 / i;
          ctx.fillStyle = '#00ff88';
          ctx.beginPath();
          ctx.arc(player2.x - dashDX2 * i * 2, player2.y - dashDY2 * i * 2, PLAYER_R - i, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      ctx.shadowColor = dashTimer2 > 0 ? '#00ff88' : '#22cc44';
      ctx.shadowBlur = dashTimer2 > 0 ? 25 : 15;
      ctx.fillStyle = dashTimer2 > 0 ? '#00aa44' : '#228833';
      ctx.beginPath(); ctx.arc(player2.x, player2.y, PLAYER_R, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = dashTimer2 > 0 ? '#44ff88' : '#44cc66';
      ctx.beginPath(); ctx.arc(player2.x, player2.y, PLAYER_R - 3, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#88ffaa'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(player2.x, player2.y);
      ctx.lineTo(player2.x + Math.cos(player2.angle) * (PLAYER_R + 8), player2.y + Math.sin(player2.angle) * (PLAYER_R + 8));
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(player2.x + Math.cos(player2.angle) * 6, player2.y + Math.sin(player2.angle) * 6, 4, 0, Math.PI * 2); ctx.fill();
      if (player2.hp < player2.maxHp) {
        const hpPct2 = Math.max(0, player2.hp / player2.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(player2.x - 20, player2.y - PLAYER_R - 12, 40, 5);
        ctx.fillStyle = hpPct2 > 0.5 ? '#44ff44' : hpPct2 > 0.25 ? '#ffaa00' : '#ff2222';
        ctx.fillRect(player2.x - 20, player2.y - PLAYER_R - 12, 40 * hpPct2, 5);
      }
      ctx.fillStyle = '#88ffaa'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
      ctx.fillText('P2', player2.x, player2.y + PLAYER_R + 14);
    } else {
      // Dead P2 marker
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#444';
      ctx.beginPath(); ctx.arc(player2.x, player2.y, PLAYER_R, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#888'; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
      ctx.fillText('P2 DOWN', player2.x, player2.y + 4);
    }
  }

  // Drone
  ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 8;
  ctx.fillStyle = '#00ccaa';
  ctx.beginPath(); ctx.arc(drone.x, drone.y, DRONE_R, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#44ffdd';
  ctx.beginPath(); ctx.arc(drone.x, drone.y, DRONE_R - 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,255,200,0.15)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(drone.x, drone.y); ctx.stroke();

  // Drone 2
  if (isCoop && player2 && player2.hp > 0 && drone2) {
    ctx.shadowColor = '#44ff88'; ctx.shadowBlur = 8;
    ctx.fillStyle = '#22cc66';
    ctx.beginPath(); ctx.arc(drone2.x, drone2.y, DRONE_R, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#66ff99';
    ctx.beginPath(); ctx.arc(drone2.x, drone2.y, DRONE_R - 2, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = 'rgba(68,255,136,0.15)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(player2.x, player2.y); ctx.lineTo(drone2.x, drone2.y); ctx.stroke();
  }

  // Shockwaves
  for (const sw of shockwaves) {
    if (sw.x + sw.radius < camera.x || sw.x - sw.radius > camera.x + W ||
        sw.y + sw.radius < camera.y || sw.y - sw.radius > camera.y + H) continue;
    const alpha = 1 - sw.radius / sw.maxRadius;
    // Outer glow ring
    ctx.strokeStyle = `rgba(136,0,204,${alpha * 0.5})`; ctx.lineWidth = 16;
    ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke();
    // Bright inner ring
    ctx.strokeStyle = `rgba(200,100,255,${alpha * 0.8})`; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke();
    // White core edge
    ctx.strokeStyle = `rgba(255,200,255,${alpha * 0.6})`; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke();
  }

  // Napalm fires
  for (const nf of napalmFires) {
    if (nf.x < camera.x - 50 || nf.x > camera.x + W + 50 || nf.y < camera.y - 50 || nf.y > camera.y + H + 50) continue;
    const flicker = Math.sin(frameCount * 0.15 + nf.x) * 0.15 + 0.4;
    const lifeAlpha = Math.min(1, nf.life / 60);
    ctx.fillStyle = `rgba(255,80,0,${flicker * lifeAlpha})`;
    ctx.beginPath(); ctx.arc(nf.x, nf.y, 35, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = `rgba(255,200,50,${flicker * 0.6 * lifeAlpha})`;
    ctx.beginPath(); ctx.arc(nf.x, nf.y, 18, 0, Math.PI * 2); ctx.fill();
  }

  // Active planes
  for (const pl of activePlanes) {
    // Shadow on ground
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath(); ctx.ellipse(pl.x + 20, pl.y + 30, 20, 8, pl.angle, 0, Math.PI * 2); ctx.fill();
    // Plane body (triangle)
    ctx.save();
    ctx.translate(pl.x, pl.y);
    ctx.rotate(pl.angle);
    ctx.fillStyle = '#aabbcc';
    ctx.beginPath();
    ctx.moveTo(18, 0); ctx.lineTo(-12, -10); ctx.lineTo(-8, 0); ctx.lineTo(-12, 10);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#667788';
    ctx.beginPath(); ctx.moveTo(-10, -8); ctx.lineTo(-18, -14); ctx.lineTo(-14, -6); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(-10, 8); ctx.lineTo(-18, 14); ctx.lineTo(-14, 6); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // Spacemen
  for (const s of spacemen) {
    if (s.x < camera.x - 20 || s.x > camera.x + W + 20 || s.y < camera.y - 20 || s.y > camera.y + H + 20) continue;
    ctx.fillStyle = '#e8e8e8';
    ctx.beginPath(); ctx.arc(s.x, s.y + 2, s.size - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#2266cc';
    ctx.beginPath(); ctx.arc(s.x, s.y - 3, s.size - 2, Math.PI, 0); ctx.fill();
    ctx.fillStyle = '#66bbff';
    ctx.fillRect(s.x - 3, s.y - 5, 6, 3);
    ctx.shadowColor = '#4488ff'; ctx.shadowBlur = 6;
    ctx.strokeStyle = '#4488ff'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.stroke();
    ctx.shadowBlur = 0;
    if (s.hp < s.maxHp) {
      const hpPct = Math.max(0, s.hp / s.maxHp);
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(s.x - 8, s.y - s.size - 6, 16, 3);
      ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : '#ff4444';
      ctx.fillRect(s.x - 8, s.y - s.size - 6, 16 * hpPct, 3);
    }
  }

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
  drawMinimap();

  // Plane cooldown bar (near dash indicator)
  if (gameRunning && !gamePaused) {
    const pcX = W / 2 - 60, pcY = H - 38;
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(pcX, pcY, 120, 16);
    ctx.strokeStyle = 'rgba(0,255,255,0.2)'; ctx.lineWidth = 1; ctx.strokeRect(pcX, pcY, 120, 16);
    if (planeCooldownTimer > 0) {
      const pct = 1 - planeCooldownTimer / PLANE_COOLDOWN;
      ctx.fillStyle = '#555'; ctx.fillRect(pcX + 1, pcY + 1, 118 * pct, 14);
    } else {
      ctx.fillStyle = energy >= PLANE_COST ? '#0ff' : '#444';
      ctx.fillRect(pcX + 1, pcY + 1, 118, 14);
    }
    ctx.fillStyle = planeCooldownTimer > 0 ? '#888' : (energy >= PLANE_COST ? '#fff' : '#666');
    ctx.font = '9px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText(planeCooldownTimer > 0 ? `Plane ${Math.ceil(planeCooldownTimer/60)}s` : `[Q] Airstrike ${PLANE_COST}E`, pcX + 60, pcY + 12);
  }

  // Plane weapon select popup
  if (planeWeaponSelect && gameRunning && !gamePaused) {
    const wpX = W / 2 - 130, wpY = H / 2 - 50;
    ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.fillRect(wpX, wpY, 260, 110);
    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.strokeRect(wpX, wpY, 260, 110);
    ctx.fillStyle = '#0ff'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText('SELECT WEAPON, THEN CLICK TO TARGET', wpX + 130, wpY + 22);
    ctx.font = '13px Segoe UI';
    ctx.fillStyle = '#ff6600'; ctx.fillText('[1] Bombs — Area Blast', wpX + 130, wpY + 45);
    ctx.fillStyle = '#ff4400'; ctx.fillText('[2] Napalm — Fire Trail', wpX + 130, wpY + 63);
    ctx.fillStyle = '#ffcc00'; ctx.fillText('[3] Machine Gun — Strafing', wpX + 130, wpY + 81);
    ctx.fillStyle = '#888'; ctx.font = '11px Segoe UI';
    ctx.fillText('[Q] Cancel', wpX + 130, wpY + 100);
  }

  // Plane targeting reticle
  if (planeTargetingWeapon !== null && gameRunning && !gamePaused) {
    const pulse = Math.sin(frameCount * 0.12) * 0.3 + 0.7;
    const rSize = 18 + Math.sin(frameCount * 0.08) * 4;
    const rmx = mouse.x, rmy = mouse.y;
    // Crosshair lines
    ctx.strokeStyle = `rgba(255,100,0,${pulse})`; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(rmx - rSize, rmy); ctx.lineTo(rmx - 6, rmy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(rmx + 6, rmy); ctx.lineTo(rmx + rSize, rmy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(rmx, rmy - rSize); ctx.lineTo(rmx, rmy - 6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(rmx, rmy + 6); ctx.lineTo(rmx, rmy + rSize); ctx.stroke();
    // Outer circle
    ctx.strokeStyle = `rgba(255,140,0,${pulse * 0.6})`; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(rmx, rmy, rSize + 4, 0, Math.PI * 2); ctx.stroke();
    // Inner dot
    ctx.fillStyle = `rgba(255,200,0,${pulse})`;
    ctx.beginPath(); ctx.arc(rmx, rmy, 2.5, 0, Math.PI * 2); ctx.fill();
    // Label
    const weaponLabel = planeTargetingWeapon === 'bombs' ? 'BOMBS' : planeTargetingWeapon === 'napalm' ? 'NAPALM' : 'MACHINE GUN';
    ctx.fillStyle = `rgba(255,200,100,${pulse})`; ctx.font = 'bold 11px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText('CLICK TO STRIKE', rmx, rmy + rSize + 20);
    ctx.fillStyle = `rgba(255,140,0,${pulse})`; ctx.font = '10px Segoe UI';
    ctx.fillText(weaponLabel + ' | [Q/ESC] Cancel', rmx, rmy + rSize + 34);
  }

  // Pause overlay
  if (gamePaused) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#0ff'; ctx.font = 'bold 48px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W/2, H/2 - 100);
    ctx.fillStyle = '#aaa'; ctx.font = '18px Segoe UI';
    ctx.fillText(`Wave: ${endlessMode ? 'ENDLESS' : wave + '/' + MAX_WAVES} | Kills: ${totalKills} | Energy: ${energy}`, W/2, H/2 - 50);
    ctx.fillText(`HP: ${Math.floor(player.hp)}/${player.maxHp} | Points: ${upgradePoints}`, W/2, H/2 - 20);
    const upStrs = UPGRADE_DEFS.map(u => `${u.name}: Lv${playerUpgrades[u.key]}`).join(' | ');
    ctx.font = '14px Segoe UI'; ctx.fillText(upStrs, W/2, H/2 + 20);
    ctx.fillStyle = '#888'; ctx.font = '16px Segoe UI';
    ctx.fillText('WASD: Move | Click: Shoot | SPACE: Dash | 1-5: Build | Right-Click: Upgrade', W/2, H/2 + 70);
    ctx.fillText('Press ESC to resume', W/2, H/2 + 110);
  }

  // Upgrade menu
  if (showingUpgrades) {
    ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#44ff44'; ctx.font = 'bold 36px Segoe UI'; ctx.textAlign = 'center';
    ctx.fillText('WAVE CLEARED — UPGRADES', W/2, 80);
    ctx.fillStyle = '#ffdd00'; ctx.font = '20px Segoe UI';
    ctx.fillText(`Available Points: ${upgradePoints}`, W/2, 120);

    const boxW = 170, boxH = 120, gap = 12;
    const totalW = UPGRADE_DEFS.length * boxW + (UPGRADE_DEFS.length - 1) * gap;
    const startX = (W - totalW) / 2;
    const startY = H/2 - 80;

    for (let i = 0; i < UPGRADE_DEFS.length; i++) {
      const u = UPGRADE_DEFS[i];
      const lv = playerUpgrades[u.key];
      const cost = getUpgradeCost(lv);
      const canBuy = lv < u.max && upgradePoints >= cost;
      const maxed = lv >= u.max;
      const bx = startX + i * (boxW + gap), by = startY;

      // Box
      ctx.fillStyle = canBuy ? 'rgba(0,255,100,0.1)' : 'rgba(100,100,100,0.1)';
      ctx.fillRect(bx, by, boxW, boxH);
      ctx.strokeStyle = canBuy ? '#44ff44' : maxed ? '#888' : '#666'; ctx.lineWidth = 2;
      ctx.strokeRect(bx, by, boxW, boxH);

      // Name
      ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Segoe UI'; ctx.textAlign = 'center';
      ctx.fillText(u.name, bx + boxW/2, by + 25);

      // Level pips
      for (let p = 0; p < u.max; p++) {
        ctx.fillStyle = p < lv ? '#44ff44' : '#333';
        ctx.fillRect(bx + boxW/2 - u.max*10 + p*20 + 2, by + 38, 16, 8);
      }

      // Cost or MAX
      ctx.font = '14px Segoe UI';
      if (maxed) { ctx.fillStyle = '#888'; ctx.fillText('MAXED', bx + boxW/2, by + 72); }
      else { ctx.fillStyle = canBuy ? '#ffdd00' : '#666'; ctx.fillText(`Cost: ${cost} pts`, bx + boxW/2, by + 72); }

      // Effect description
      ctx.fillStyle = '#aaa'; ctx.font = '12px Segoe UI';
      const desc = u.key === 'maxHp' ? `+${u.per} HP per level` : u.key === 'speed' ? `+${u.per} speed per level` :
        u.key === 'damage' ? `+${u.per} dmg per level` : u.key === 'droneRate' ? `-${u.per}f fire delay` :
        u.key === 'dashCD' ? `-${u.per}f dash CD` : u.key === 'squad' ? `+${u.per} men & +3 dmg` : '';
      ctx.fillText(desc, bx + boxW/2, by + 95);

      // Click hint
      if (canBuy) { ctx.fillStyle = '#44ff44'; ctx.font = '11px Segoe UI'; ctx.fillText('[CLICK TO BUY]', bx + boxW/2, by + 112); }
    }

    // Ready button
    const rbW = 200, rbH = 50;
    const rbX = W/2 - rbW/2, rbY = startY + boxH + 50;
    ctx.fillStyle = 'rgba(0,255,255,0.15)'; ctx.fillRect(rbX, rbY, rbW, rbH);
    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.strokeRect(rbX, rbY, rbW, rbH);
    ctx.fillStyle = '#0ff'; ctx.font = 'bold 22px Segoe UI'; ctx.textAlign = 'center';
    if (isCoop) {
      const localReady = isHost ? hostReady : p2Ready;
      const remoteReady = isHost ? p2Ready : hostReady;
      if (localReady && !remoteReady) {
        ctx.fillStyle = '#888';
        ctx.fillText(isHost ? 'WAITING FOR P2...' : 'WAITING FOR HOST...', W/2, rbY + 33);
      } else {
        ctx.fillText('READY [ENTER]', W/2, rbY + 33);
      }
    } else {
      ctx.fillText('READY [ENTER]', W/2, rbY + 33);
    }

    // Store positions for click detection
    window._upgradeBoxes = { startX, startY, boxW, boxH, gap, readyX: rbX, readyY: rbY, readyW: rbW, readyH: rbH };
  }
}

function drawMinimap() {
  const biome = BIOMES[currentBiome];
  const mmW = 160, mmH = 160;
  const mmX = W - mmW - 12, mmY = H - mmH - 60;
  const scaleX = mmW / WORLD_W, scaleY = mmH / WORLD_H;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);
  ctx.fillStyle = biome.minimapBg;
  ctx.fillRect(mmX, mmY, mmW, mmH);
  ctx.strokeStyle = 'rgba(0,255,255,0.3)'; ctx.lineWidth = 1;
  ctx.strokeRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);
  ctx.fillStyle = biome.minimapRock;
  for (const o of obstacles) {
    if (o.type === 'rock' || o.type === 'tree') ctx.fillRect(mmX + o.x * scaleX, mmY + o.y * scaleY, Math.max(1, TILE * scaleX), Math.max(1, TILE * scaleY));
  }
  ctx.fillStyle = biome.minimapLake;
  for (const o of obstacles) {
    if (o.type === 'lake') ctx.fillRect(mmX + o.x * scaleX, mmY + o.y * scaleY, Math.max(1, TILE * scaleX), Math.max(1, TILE * scaleY));
  }
  for (const b of buildings) {
    ctx.fillStyle = b.type === 'wall' ? '#7799aa' : b.type === 'generator' ? '#66aa00' : b.type === 'laser' ? '#bb44ff' : b.type === 'barracks' ? '#4488ff' : b.type === 'catapult' ? '#cc6600' : '#ff6600';
    ctx.fillRect(mmX + b.x * scaleX, mmY + b.y * scaleY, 3, 3);
  }
  ctx.fillStyle = '#88ccff';
  for (const s of spacemen) ctx.fillRect(mmX + s.x * scaleX - 1, mmY + s.y * scaleY - 1, 2, 2);
  ctx.fillStyle = '#ff4444';
  for (const e of enemies) ctx.fillRect(mmX + e.x * scaleX - 1, mmY + e.y * scaleY - 1, 2, 2);
  ctx.fillStyle = '#4499ff';
  ctx.beginPath(); ctx.arc(mmX + player.x * scaleX, mmY + player.y * scaleY, 3, 0, Math.PI * 2); ctx.fill();
  // P2 on minimap
  if (isCoop && player2 && player2.hp > 0) {
    ctx.fillStyle = '#44ff88';
    ctx.beginPath(); ctx.arc(mmX + player2.x * scaleX, mmY + player2.y * scaleY, 3, 0, Math.PI * 2); ctx.fill();
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.strokeRect(mmX + camera.x * scaleX, mmY + camera.y * scaleY, W * scaleX, H * scaleY);
}

// ---- Build ----
function selectBuild(type) {
  selectedBuild = selectedBuild === type ? null : type;
  updateBuildButtons();
}

function updateBuildButtons() {
  document.querySelectorAll('.build-btn').forEach(btn => {
    const type = btn.dataset.type;
    btn.classList.toggle('active', selectedBuild === type);
    btn.classList.toggle('disabled', energy < COSTS[type]);
  });
}

function placeBuild() {
  if (!selectedBuild) return;
  if (energy < COSTS[selectedBuild]) return;
  const wmx = mouse.x + camera.x;
  const wmy = mouse.y + camera.y;
  const tx = Math.floor(wmx / TILE) * TILE;
  const ty = Math.floor(wmy / TILE) * TILE;
  if (isObstacle(tx + TILE / 2, ty + TILE / 2)) return;
  if (isBuildingAt(tx + TILE / 2, ty + TILE / 2)) return;
  if (circleRect(player.x, player.y, PLAYER_R, tx, ty, BUILD_SIZE, BUILD_SIZE)) return;
  energy -= COSTS[selectedBuild];
  buildings.push({
    x: tx, y: ty, type: selectedBuild, level: 1,
    hp: BUILD_HP[selectedBuild], maxHp: BUILD_HP[selectedBuild],
    fireCD: 0, angle: 0, laserTarget: null
  });
  spawnParticles(tx + BUILD_SIZE / 2, ty + BUILD_SIZE / 2, '#00ff88', 8, 3);
  document.getElementById('energy-display').textContent = energy;
  updateBuildButtons();
}

function getBuildingAt(wx, wy) {
  const tx = Math.floor(wx / TILE) * TILE;
  const ty = Math.floor(wy / TILE) * TILE;
  return buildings.find(b => b.x === tx && b.y === ty && b.hp > 0) || null;
}

function getUpgradeCostForBuilding(b) {
  if (!b || b.level >= BUILD_MAX_LEVEL) return Infinity;
  return BUILD_UPGRADE_COST[b.type][b.level - 1];
}

function upgradeBuilding(b) {
  if (!b || b.level >= BUILD_MAX_LEVEL) return false;
  const cost = getUpgradeCostForBuilding(b);
  if (energy < cost) return false;
  energy -= cost;
  b.level++;
  // Scale HP: add 50% of base HP per level
  const hpBonus = BUILD_HP[b.type] * 0.5;
  b.maxHp += hpBonus;
  b.hp += hpBonus; // Heal the bonus amount
  spawnParticles(b.x + BUILD_SIZE / 2, b.y + BUILD_SIZE / 2, '#00ffcc', 12, 4);
  document.getElementById('energy-display').textContent = energy;
  updateBuildButtons();
  return true;
}

// ---- Input ----
window.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  keys[k] = true;

  // Escape: cancel targeting / cancel build / pause toggle
  if (e.key === 'Escape') {
    if (showingUpgrades) return; // can't pause during upgrades
    if (planeTargetingWeapon !== null) {
      // Cancel targeting, refund energy
      energy += PLANE_COST;
      document.getElementById('energy-display').textContent = energy;
      updateBuildButtons();
      planeTargetingWeapon = null;
    } else if (planeWeaponSelect) { planeWeaponSelect = false; }
    else if (selectedBuild) { selectedBuild = null; updateBuildButtons(); }
    else if (gameRunning) { gamePaused = !gamePaused; }
    return;
  }

  if (gamePaused || showingUpgrades) {
    // Enter to dismiss upgrade menu
    if (e.key === 'Enter' && showingUpgrades) { dismissUpgradeMenu(); }
    return;
  }

  if (e.key === '1') selectBuild('wall');
  if (e.key === '2') selectBuild('generator');
  if (e.key === '3') selectBuild('turret');
  if (e.key === '4') selectBuild('laser');
  if (e.key === '5') selectBuild('barracks');
  if (e.key === '6' && !planeWeaponSelect) selectBuild('catapult');

  // Plane airstrike: Q toggles weapon select, 1/2/3 picks weapon while selecting
  if (k === 'q' && gameRunning) {
    if (planeTargetingWeapon !== null) {
      // Cancel targeting, refund energy
      energy += PLANE_COST;
      document.getElementById('energy-display').textContent = energy;
      updateBuildButtons();
      planeTargetingWeapon = null;
    } else if (planeCooldownTimer > 0 || energy < PLANE_COST) { planeWeaponSelect = false; }
    else { planeWeaponSelect = !planeWeaponSelect; if (planeWeaponSelect) selectedBuild = null; }
  }
  if (planeWeaponSelect && (e.key === '1' || e.key === '2' || e.key === '3')) {
    const weaponType = e.key === '1' ? 'bombs' : e.key === '2' ? 'napalm' : 'machinegun';
    energy -= PLANE_COST;
    document.getElementById('energy-display').textContent = energy;
    updateBuildButtons();
    planeWeaponSelect = false;
    planeTargetingWeapon = weaponType; // enter targeting mode
    selectedBuild = null; // cancel any build mode
  }

  if (e.key === 'b' || e.key === 'B') {
    if (!selectedBuild) selectBuild('wall');
    else if (selectedBuild === 'wall') selectBuild('generator');
    else if (selectedBuild === 'generator') selectBuild('turret');
    else if (selectedBuild === 'turret') selectBuild('laser');
    else if (selectedBuild === 'laser') selectBuild('barracks');
    else if (selectedBuild === 'barracks') selectBuild('catapult');
    else selectBuild('wall');
  }

  // Repair building (R key)
  if (k === 'r' && gameRunning) {
    const rb = getBuildingAt(worldMouseX, worldMouseY);
    if (rb && rb.hp < rb.maxHp) {
      const repairCost = Math.ceil((rb.maxHp - rb.hp) / rb.maxHp * COSTS[rb.type] * 0.5);
      if (repairCost > 0 && energy >= repairCost) {
        energy -= repairCost;
        rb.hp = rb.maxHp;
        spawnParticles(rb.x + BUILD_SIZE / 2, rb.y + BUILD_SIZE / 2, '#00ff88', 10, 3);
        document.getElementById('energy-display').textContent = energy;
      }
    }
  }

  // Dash
  const effectiveDashCD = DASH_COOLDOWN - playerUpgrades.dashCD * 25;
  if (k === ' ' && gameRunning && dashCooldown <= 0 && dashTimer <= 0) {
    e.preventDefault();
    let ddx = 0, ddy = 0;
    if (keys['w'] || keys['arrowup']) ddy -= 1;
    if (keys['s'] || keys['arrowdown']) ddy += 1;
    if (keys['a'] || keys['arrowleft']) ddx -= 1;
    if (keys['d'] || keys['arrowright']) ddx += 1;
    if (ddx === 0 && ddy === 0) { ddx = Math.cos(player.angle); ddy = Math.sin(player.angle); }
    const len = Math.hypot(ddx, ddy);
    if (len > 0) {
      dashDX = (ddx / len) * DASH_SPEED; dashDY = (ddy / len) * DASH_SPEED;
      dashTimer = DASH_DURATION; dashCooldown = effectiveDashCD;
      spawnParticles(player.x, player.y, '#00ffff', 8, 4);
    }
  }
});

window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

canvas.addEventListener('mousedown', e => {
  if (gamePaused) return;

  // Upgrade menu click handling
  if (showingUpgrades && e.button === 0 && window._upgradeBoxes) {
    const ub = window._upgradeBoxes;
    const mx = e.clientX, my = e.clientY;
    // Check upgrade boxes
    for (let i = 0; i < UPGRADE_DEFS.length; i++) {
      const bx = ub.startX + i * (ub.boxW + ub.gap);
      if (mx >= bx && mx <= bx + ub.boxW && my >= ub.startY && my <= ub.startY + ub.boxH) {
        if (isClient) {
          // Client sends upgrade request to host
          if (conn && conn.open) conn.send({ type: 'upgrade', index: i });
        } else {
          const u = UPGRADE_DEFS[i]; const lv = playerUpgrades[u.key]; const cost = getUpgradeCost(lv);
          if (lv < u.max && upgradePoints >= cost) {
            upgradePoints -= cost; playerUpgrades[u.key]++;
            applyUpgrades(u.key);
            updateHpDisplay();
          }
        }
        return;
      }
    }
    // Check ready button
    if (mx >= ub.readyX && mx <= ub.readyX + ub.readyW && my >= ub.readyY && my <= ub.readyY + ub.readyH) {
      dismissUpgradeMenu(); return;
    }
    return;
  }

  if (e.button === 0) {
    // Plane targeting click — spawn plane at clicked world position
    if (planeTargetingWeapon !== null) {
      const wmx = mouse.x + camera.x, wmy = mouse.y + camera.y;
      const tx = wmx, ty = wmy;
      const flyAngle = Math.random() * Math.PI * 2;
      const d = Math.max(W, H) * 0.8;
      const sx = tx - Math.cos(flyAngle) * d;
      const sy = ty - Math.sin(flyAngle) * d;
      const ex = tx + Math.cos(flyAngle) * d;
      const ey = ty + Math.sin(flyAngle) * d;
      activePlanes.push({
        x: sx, y: sy, ex, ey, tx, ty,
        speed: 8, weapon: planeTargetingWeapon, fired: false,
        angle: flyAngle, progress: 0
      });
      planeCooldownTimer = PLANE_COOLDOWN;
      planeTargetingWeapon = null;
    } else if (selectedBuild) {
      if (isClient) {
        // Client sends build request to host
        const wmx = mouse.x + camera.x, wmy = mouse.y + camera.y;
        const tx = Math.floor(wmx / TILE) * TILE, ty = Math.floor(wmy / TILE) * TILE;
        if (conn && conn.open) conn.send({ type: 'build', buildType: selectedBuild, tx, ty });
      } else {
        placeBuild();
      }
    }
    else { mouse.clicked = true; }
  }
  if (e.button === 2) {
    if (selectedBuild) {
      if (isClient) {
        const wmx = mouse.x + camera.x, wmy = mouse.y + camera.y;
        const tx = Math.floor(wmx / TILE) * TILE, ty = Math.floor(wmy / TILE) * TILE;
        if (conn && conn.open) conn.send({ type: 'build', buildType: selectedBuild, tx, ty });
      } else {
        placeBuild();
      }
    }
    else {
      // Right-click: try to upgrade building under cursor
      const wmx = mouse.x + camera.x, wmy = mouse.y + camera.y;
      if (isClient) {
        const tx = Math.floor(wmx / TILE) * TILE, ty = Math.floor(wmy / TILE) * TILE;
        if (conn && conn.open) conn.send({ type: 'upgradeBuild', bx: tx, by: ty });
      } else {
        const b = getBuildingAt(wmx, wmy);
        if (b) upgradeBuilding(b);
      }
    }
  }
});

function dismissUpgradeMenu() {
  if (isCoop) {
    if (isHost) {
      hostReady = true;
      if (!p2Ready) return; // wait for P2
    } else {
      // Client sends ready to host
      if (conn && conn.open) conn.send({ type: 'ready' });
      p2Ready = true;
      return; // host will dismiss when both ready
    }
    // Both ready — reset
    hostReady = false; p2Ready = false;
  }
  showingUpgrades = false;
  wavePhase = 'cleared';
  if (wave >= MAX_WAVES) { betweenTimer = 120; }
  else { betweenTimer = BETWEEN_WAVE_FAST * 60; }
  updateWaveHUD();
}

canvas.addEventListener('contextmenu', e => e.preventDefault());

// ============================================================
// MULTIPLAYER — Connection, Sync, Helpers
// ============================================================

function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // no I/1/O/0
  let code = '';
  for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function hostGame() {
  roomCode = generateRoomCode();
  isCoop = true; isHost = true; isClient = false;
  document.getElementById('lobby-room-code').textContent = roomCode;
  document.getElementById('lobby-title').textContent = 'HOST — CO-OP LOBBY';
  document.getElementById('lobby-status').textContent = 'Waiting for Player 2...';
  document.getElementById('lobby-start-btn').disabled = true;
  document.getElementById('lobby-overlay').classList.add('show');

  peer = new Peer('energysiege-' + roomCode, { debug: 0 });
  peer.on('open', () => {
    document.getElementById('lobby-status').textContent = 'Room open. Share code: ' + roomCode;
  });
  peer.on('connection', c => {
    conn = c;
    document.getElementById('lobby-status').textContent = 'Player 2 connected!';
    document.getElementById('lobby-start-btn').disabled = false;
    conn.on('data', handleNetData);
    conn.on('close', handleDisconnect);
  });
  peer.on('error', err => {
    document.getElementById('lobby-status').textContent = 'Error: ' + err.type;
  });
}

function joinGame() {
  const code = document.getElementById('join-code-input').value.toUpperCase().trim();
  if (code.length !== 6) return;
  roomCode = code;
  isCoop = true; isHost = false; isClient = true;
  document.getElementById('lobby-room-code').textContent = roomCode;
  document.getElementById('lobby-title').textContent = 'JOIN — CO-OP LOBBY';
  document.getElementById('lobby-status').textContent = 'Connecting to host...';
  document.getElementById('lobby-start-btn').disabled = true;
  document.getElementById('lobby-start-btn').style.display = 'none';
  document.getElementById('lobby-overlay').classList.add('show');

  peer = new Peer(undefined, { debug: 0 });
  peer.on('open', () => {
    conn = peer.connect('energysiege-' + roomCode, { reliable: true });
    conn.on('open', () => {
      document.getElementById('lobby-status').textContent = 'Connected! Waiting for host to start...';
      conn.on('data', handleNetData);
      conn.on('close', handleDisconnect);
    });
  });
  peer.on('error', err => {
    document.getElementById('lobby-status').textContent = 'Error: ' + err.type;
  });
}

function startCoopGame() {
  if (!isHost || !conn) return;
  conn.send({ type: 'start', biome: currentBiome });
  document.getElementById('lobby-overlay').classList.remove('show');
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('coop-badge').classList.add('show');
  initGame();
  gameRunning = true;
}

function cancelLobby() {
  document.getElementById('lobby-overlay').classList.remove('show');
  document.getElementById('lobby-start-btn').style.display = '';
  if (conn) { conn.close(); conn = null; }
  if (peer) { peer.destroy(); peer = null; }
  isCoop = false; isHost = false; isClient = false; roomCode = '';
}

function handleDisconnect() {
  if (!isCoop) return;
  conn = null;
  if (isClient) {
    // Client: game over
    gameRunning = false; gameOverShown = true;
    document.getElementById('go-title').textContent = 'DISCONNECTED';
    document.getElementById('go-title').style.color = '#ff6600';
    document.getElementById('go-stats').textContent = 'Lost connection to host';
    document.getElementById('game-over').classList.add('show');
  } else {
    // Host: continue solo, show toast
    player2 = null; drone2 = null;
    const toast = document.getElementById('disconnect-toast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 4000);
  }
}

function handleNetData(data) {
  if (!data || !data.type) return;
  switch(data.type) {
    case 'start':
      if (isClient) {
        if (data.biome && BIOMES[data.biome]) currentBiome = data.biome;
        document.getElementById('lobby-overlay').classList.remove('show');
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('coop-badge').classList.add('show');
        initGame();
        gameRunning = true;
      }
      break;
    case 'input':
      if (isHost) {
        remoteInput = data.input;
      }
      break;
    case 'state':
      if (isClient) {
        applyHostState(data.state);
      }
      break;
    case 'upgrade':
      if (isHost && showingUpgrades) {
        const u = UPGRADE_DEFS[data.index];
        if (u) {
          const lv = playerUpgrades[u.key];
          const cost = getUpgradeCost(lv);
          if (lv < u.max && upgradePoints >= cost) {
            upgradePoints -= cost;
            playerUpgrades[u.key]++;
            applyUpgrades(u.key);
          }
        }
      }
      break;
    case 'ready':
      if (isHost) {
        p2Ready = true;
        // If host is also ready, dismiss
        if (hostReady && showingUpgrades) dismissUpgradeMenu();
      }
      break;
    case 'build':
      if (isHost) { placeBuildAt(data.buildType, data.tx, data.ty); }
      break;
    case 'upgradeBuild':
      if (isHost) {
        const b = getBuildingAt(data.bx + TILE/2, data.by + TILE/2);
        if (b) upgradeBuilding(b);
      }
      break;
  }
}

function placeBuildAt(buildType, tx, ty) {
  if (!buildType || energy < COSTS[buildType]) return;
  if (isObstacle(tx + TILE / 2, ty + TILE / 2)) return;
  if (isBuildingAt(tx + TILE / 2, ty + TILE / 2)) return;
  if (circleRect(player.x, player.y, PLAYER_R, tx, ty, BUILD_SIZE, BUILD_SIZE)) return;
  if (player2 && circleRect(player2.x, player2.y, PLAYER_R, tx, ty, BUILD_SIZE, BUILD_SIZE)) return;
  energy -= COSTS[buildType];
  buildings.push({
    x: tx, y: ty, type: buildType, level: 1,
    hp: BUILD_HP[buildType], maxHp: BUILD_HP[buildType],
    fireCD: 0, angle: 0, laserTarget: null
  });
  spawnParticles(tx + BUILD_SIZE / 2, ty + BUILD_SIZE / 2, '#00ff88', 8, 3);
  document.getElementById('energy-display').textContent = energy;
  updateBuildButtons();
}

function packGameState() {
  const packEnemy = e => ({
    x: e.x, y: e.y, size: e.size, hp: e.hp, maxHp: e.maxHp, type: e.type,
    isBoss: e.isBoss, bossKey: e.bossKey, isRaged: e.isRaged, isCharging: e.isCharging,
    chargeWindup: e.chargeWindup, stunTimer: e.stunTimer,
    laserCharging: e.laserCharging, laserChargeTimer: e.laserChargeTimer,
    laserFiring: e.laserFiring, laserFireTimer: e.laserFireTimer, laserAngle: e.laserAngle,
    phase: e.phase, slamWindup: e.slamWindup, speed: e.speed,
    chargeDX: e.chargeDX, chargeDY: e.chargeDY
  });
  return {
    p1: { x: player.x, y: player.y, hp: player.hp, maxHp: player.maxHp, angle: player.angle },
    p2: player2 ? { x: player2.x, y: player2.y, hp: player2.hp, maxHp: player2.maxHp, angle: player2.angle } : null,
    d1: { x: drone.x, y: drone.y },
    d2: drone2 ? { x: drone2.x, y: drone2.y } : null,
    enemies: enemies.map(packEnemy),
    bullets: bullets.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, life: b.life, owner: b.owner, damage: b.damage })),
    buildings: buildings.map(b => ({ x: b.x, y: b.y, type: b.type, level: b.level, hp: b.hp, maxHp: b.maxHp, fireCD: b.fireCD, angle: b.angle,
      laserTarget: b.laserTarget ? { x: b.laserTarget.x, y: b.laserTarget.y } : null })),
    orbs: orbs.map(o => ({ x: o.x, y: o.y, pulse: o.pulse })),
    mines: mines.map(m => ({ x: m.x, y: m.y, armed: m.armed, armTimer: m.armTimer, lifetime: m.lifetime })),
    shockwaves: shockwaves.map(s => ({ x: s.x, y: s.y, radius: s.radius, maxRadius: s.maxRadius, speed: s.speed, damage: s.damage })),
    spacemen: spacemen.map(s => ({ x: s.x, y: s.y, hp: s.hp, maxHp: s.maxHp, size: s.size })),
    hud: {
      energy, wave, wavePhase, upgradePoints, totalKills, showingUpgrades,
      endlessMode, endlessTimer, endlessLevel, playerUpgrades: { ...playerUpgrades },
      activeBossHp: activeBoss ? activeBoss.hp / activeBoss.maxHp : -1,
      activeBossName: activeBoss ? BOSS_DEFS[activeBoss.bossKey].name : '',
      dashCooldown, dashTimer,
      dashCooldown2: dashCooldown2, dashTimer2: dashTimer2,
      hostReady, p2Ready
    },
    frameCount
  };
}

function applyHostState(s) {
  if (!s) return;
  // Players
  player.x = s.p1.x; player.y = s.p1.y; player.hp = s.p1.hp; player.maxHp = s.p1.maxHp; player.angle = s.p1.angle;
  if (s.p2) {
    if (!player2) player2 = { x: 0, y: 0, hp: 100, maxHp: 100, angle: 0 };
    player2.x = s.p2.x; player2.y = s.p2.y; player2.hp = s.p2.hp; player2.maxHp = s.p2.maxHp; player2.angle = s.p2.angle;
  } else { player2 = null; }
  // Drones
  drone.x = s.d1.x; drone.y = s.d1.y;
  if (s.d2) {
    if (!drone2) drone2 = { x: 0, y: 0 };
    drone2.x = s.d2.x; drone2.y = s.d2.y;
  }
  // Entities
  enemies = s.enemies;
  bullets = s.bullets;
  buildings = s.buildings;
  orbs = s.orbs;
  mines = s.mines;
  shockwaves = s.shockwaves;
  spacemen = s.spacemen;
  // HUD
  energy = s.hud.energy;
  wave = s.hud.wave;
  wavePhase = s.hud.wavePhase;
  upgradePoints = s.hud.upgradePoints;
  totalKills = s.hud.totalKills;
  showingUpgrades = s.hud.showingUpgrades;
  endlessMode = s.hud.endlessMode;
  endlessTimer = s.hud.endlessTimer;
  endlessLevel = s.hud.endlessLevel;
  playerUpgrades = s.hud.playerUpgrades;
  hostReady = s.hud.hostReady;
  p2Ready = s.hud.p2Ready;
  dashCooldown = s.hud.dashCooldown;
  dashTimer = s.hud.dashTimer;
  dashCooldown2 = s.hud.dashCooldown2;
  dashTimer2 = s.hud.dashTimer2;
  frameCount = s.frameCount;
  // Camera follows P2 on client
  if (player2) {
    camera.x = player2.x - W / 2;
    camera.y = player2.y - H / 2;
    camera.x = Math.max(0, Math.min(WORLD_W - W, camera.x));
    camera.y = Math.max(0, Math.min(WORLD_H - H, camera.y));
  }
  // Update HUD elements
  document.getElementById('energy-display').textContent = energy;
  document.getElementById('wave-display').textContent = endlessMode ? 'ENDLESS' : `${wave} / ${MAX_WAVES}`;
  updateHpDisplay();
  updateBuildButtons();
  updateWaveHUD();
  // Boss bar
  if (s.hud.activeBossHp >= 0) {
    document.getElementById('boss-bar').classList.add('show');
    document.getElementById('boss-name-text').textContent = s.hud.activeBossName;
    document.getElementById('boss-bar-fill').style.width = (s.hud.activeBossHp * 100) + '%';
  } else {
    document.getElementById('boss-bar').classList.remove('show');
  }
  // Endless timer
  if (endlessMode) {
    document.getElementById('endless-timer').classList.add('show');
    const secs = Math.floor(endlessTimer / 60);
    const m = Math.floor(secs / 60), sec = secs % 60;
    document.getElementById('endless-timer').textContent = `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
  // Game over check for client
  if (player.hp <= 0 && player2 && player2.hp <= 0 && !gameOverShown) {
    gameOverShown = true; gameRunning = false;
    document.getElementById('go-title').textContent = 'OVERLOADED';
    document.getElementById('go-title').style.color = '#ff2222';
    document.getElementById('go-stats').textContent = `Destroyed on Wave ${wave} / ${MAX_WAVES} | Kills: ${totalKills}`;
    document.getElementById('game-over').classList.add('show');
  }
}

function updateHpDisplay() {
  if (isCoop && player2) {
    const p1hp = Math.max(0, Math.floor(player.hp));
    const p2hp = Math.max(0, Math.floor(player2.hp));
    document.getElementById('hp-display').textContent = `P1:${p1hp} P2:${p2hp}`;
  } else {
    document.getElementById('hp-display').textContent = Math.max(0, Math.floor(player.hp));
  }
}

// ---- Game Loop ----
function gameLoop() {
  update();
  draw(); // draw runs even when paused (to show pause overlay)
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('start-screen').classList.add('hidden');
  initGame();
  gameRunning = true;
}

function restartGame() {
  document.getElementById('game-over').classList.remove('show');
  if (isCoop) {
    // Disconnect and return to start screen
    if (conn) { conn.close(); conn = null; }
    if (peer) { peer.destroy(); peer = null; }
    isCoop = false; isHost = false; isClient = false; roomCode = '';
    player2 = null; drone2 = null;
    document.getElementById('coop-badge').classList.remove('show');
    document.getElementById('start-screen').classList.remove('hidden');
    gameRunning = false;
    return;
  }
  initGame();
  gameRunning = true;
}

document.getElementById('version-display').textContent = GAME_VERSION;

// ---- Build Biome Selector Cards ----
(function() {
  const container = document.getElementById('biome-selector');
  Object.entries(BIOMES).forEach(([key, b]) => {
    const card = document.createElement('div');
    card.className = 'biome-card' + (key === currentBiome ? ' selected' : '');
    card.dataset.biome = key;
    // Mini SVG preview showing bg, rock/tree, lake, grid
    const obstaclesSVG = b.noRocks
      ? `<rect x="17" y="28" width="6" height="10" fill="#3a2a1a"/><circle cx="20" cy="22" r="9" fill="#1a6a2a"/>
         <rect x="67" y="48" width="6" height="10" fill="#3a2a1a"/><circle cx="70" cy="42" r="9" fill="#1a6a2a"/>`
      : `<rect x="10" y="15" width="20" height="20" rx="2" fill="${b.rockFill}" stroke="${b.rockStroke}" stroke-width="1"/>
         <rect x="60" y="35" width="20" height="20" rx="2" fill="${b.rockFill}" stroke="${b.rockStroke}" stroke-width="1"/>`;
    card.innerHTML = `
      <svg viewBox="0 0 100 80" xmlns="http://www.w3.org/2000/svg">
        <rect width="100" height="80" fill="${b.previewBg}"/>
        <line x1="25" y1="0" x2="25" y2="80" stroke="${b.gridStroke}" stroke-width="1"/>
        <line x1="50" y1="0" x2="50" y2="80" stroke="${b.gridStroke}" stroke-width="1"/>
        <line x1="75" y1="0" x2="75" y2="80" stroke="${b.gridStroke}" stroke-width="1"/>
        <line x1="0" y1="20" x2="100" y2="20" stroke="${b.gridStroke}" stroke-width="1"/>
        <line x1="0" y1="40" x2="100" y2="40" stroke="${b.gridStroke}" stroke-width="1"/>
        <line x1="0" y1="60" x2="100" y2="60" stroke="${b.gridStroke}" stroke-width="1"/>
        ${obstaclesSVG}
        <rect x="30" y="45" width="22" height="18" rx="2" fill="${b.lakeFill}"/>
      </svg>
      <div class="biome-name">${b.name}</div>
      <div class="biome-desc">${b.desc}</div>`;
    card.onclick = () => {
      container.querySelectorAll('.biome-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      currentBiome = key;
    };
    container.appendChild(card);
  });
})();

gameLoop();
</script>
</body>
</html>
