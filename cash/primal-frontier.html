<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alone</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;font-family:'Segoe UI',Tahoma,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;}
canvas{display:block;image-rendering:pixelated;cursor:none;}
#ui{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}
#title-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:default;}
#title-screen h1{font-size:64px;color:#e8a030;text-shadow:0 0 30px rgba(232,160,48,.5),0 4px 8px rgba(0,0,0,.8);letter-spacing:4px;margin-bottom:8px;}
#title-screen .subtitle{color:#888;font-size:18px;margin-bottom:50px;letter-spacing:2px;}
#title-screen .menu-btn{background:none;border:2px solid #555;color:#ccc;font-size:22px;padding:14px 50px;margin:8px;cursor:pointer;border-radius:6px;font-family:inherit;transition:all .2s;pointer-events:auto;min-width:260px;}
#title-screen .menu-btn:hover{border-color:#e8a030;color:#e8a030;background:rgba(232,160,48,.08);box-shadow:0 0 20px rgba(232,160,48,.2);}
#title-screen .menu-btn.disabled{opacity:.35;cursor:not-allowed;}
#title-screen .menu-btn.disabled:hover{border-color:#555;color:#555;background:none;box-shadow:none;}
#title-screen .hint{color:#555;font-size:13px;margin-top:40px;}
#death-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(80,0,0,.85);z-index:90;display:none;flex-direction:column;align-items:center;justify-content:center;}
#death-screen h2{font-size:52px;color:#ff4444;margin-bottom:20px;text-shadow:0 0 20px rgba(255,0,0,.5);}
#death-screen p{color:#ccc;font-size:18px;margin-bottom:30px;}
#death-screen button{background:none;border:2px solid #ff4444;color:#ff4444;font-size:20px;padding:12px 40px;cursor:pointer;border-radius:6px;font-family:inherit;pointer-events:auto;}
#death-screen button:hover{background:rgba(255,68,68,.15);}
#crafting-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #555;border-radius:12px;padding:20px;z-index:80;display:none;min-width:420px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
#crafting-menu h3{color:#e8a030;font-size:20px;margin-bottom:14px;text-align:center;}
.recipe-row{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border:1px solid #333;border-radius:6px;margin-bottom:6px;transition:all .15s;}
.recipe-row:hover{border-color:#e8a030;background:rgba(232,160,48,.05);}
.recipe-name{color:#ddd;font-size:14px;font-weight:600;min-width:120px;}
.recipe-cost{color:#888;font-size:12px;flex:1;margin:0 12px;}
.recipe-craft{background:none;border:1px solid #4a4;color:#4a4;padding:4px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-family:inherit;pointer-events:auto;}
.recipe-craft:hover{background:rgba(68,170,68,.15);}
.recipe-craft.cannot{border-color:#555;color:#555;cursor:not-allowed;}
.recipe-craft.cannot:hover{background:none;}
#backpack-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #44aaff;border-radius:12px;padding:20px;z-index:80;display:none;min-width:460px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
#backpack-menu h3{color:#44aaff;font-size:20px;margin-bottom:14px;text-align:center;}
.bp-slot{display:inline-flex;flex-direction:column;align-items:center;justify-content:center;width:54px;height:60px;border:1px solid #444;border-radius:6px;cursor:pointer;transition:all .15s;background:rgba(30,30,50,.8);vertical-align:top;margin:2px;}
.bp-slot:hover{border-color:#44aaff;background:rgba(68,170,255,.1);}
#trade-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #e8a030;border-radius:12px;padding:20px;z-index:80;display:none;min-width:480px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui"></div>
<div id="title-screen">
  <h1>ALONE</h1>
  <div class="subtitle">FIRST-PERSON SURVIVAL â€” v1.0.2</div>
  <div id="save-slots" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-bottom:20px;max-width:800px;"></div>
  <div class="hint">WASD move &bull; Shift sprint &bull; Mouse look &bull; Left-click mine/attack &bull; Right-click place/eat/use<br>E open crafting &bull; B build menu (craft &amp; place structures) &bull; Tab backpack &bull; M map &bull; 1-8 hotbar</div>
</div>
<div id="death-screen">
  <h2>YOU DIED</h2>
  <p>The frontier claims another soul... All items lost!</p>
  <button onclick="respawn()">Respawn (Start Fresh)</button>
</div>
<div id="crafting-menu">
  <h3>Crafting</h3>
  <div id="recipe-list"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Press E or Escape to close</div>
</div>
<div id="backpack-menu">
  <h3>Backpack</h3>
  <div id="backpack-slots"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Click items to move between hotbar and backpack &bull; Tab or Escape to close</div>
</div>
<div id="trade-menu">
  <div id="trade-list"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Press E or Escape to close</div>
</div>
<div id="smelt-menu" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #FF6600;border-radius:12px;padding:20px;z-index:80;display:none;min-width:480px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;">
  <h3 style="color:#FF6600;font-size:20px;margin-bottom:14px;text-align:center;">Furnace â€” Smelting</h3>
  <div id="smelt-list"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Press E or Escape to close</div>
</div>

<script>
// ============================================================
// ALONE - First-Person Survival Game
// DDA Raycasting Engine + Mining + Building + Creatures + Taming
// ============================================================

const C = document.getElementById('game');
const ctx = C.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
C.width = W; C.height = H;

// ---- CONSTANTS ----
const MAP_SIZE = 2048;
const TEX_SIZE = 16;
const TILE_EMPTY = 0;
const MOVE_SPEED = 2.0;
const SPRINT_SPEED = 3.5;
const ROT_SPEED = 0.003;
const MINE_RANGE = 3.5;
const PLACE_DIST = 1.8;
const BUILD_PLACE_DIST = 3.5;
const HUNGER_RATE = 0.06; // per second (was 0.4)
const SPRINT_HUNGER = 0.3; // extra hunger when sprinting
const STARVE_DMG = 2;
const AUTOSAVE_INTERVAL = 60000;
const MAX_CREATURES = 400;
const CREATURE_SPAWN_DIST = 6;
const ATTACK_RANGE = 2.5;
const ATTACK_COOLDOWN = 0.5;
const BACKPACK_SIZE = 10;
const TOWN_COUNT = 5;

// ---- TILE TYPES ----
const T = {
  AIR:0, DIRT:1, STONE:2, IRON:3, GOLD:4, CRYSTAL:5,
  WOOD:6, LEAVES:7, SAND:8, SNOW:9, OBSIDIAN:10, LAVA:11,
  WOOD_WALL:20, STONE_WALL:21, FENCE:22, DOOR:23, TORCH:24, WELL:25,
  BRICK:26, WATER:27,
  COPPER:12, SILVER:13,
  HOUSE_WALL:28, THATCH_ROOF:29, MARKET_STALL:30, GLASS:31,
  CAMPFIRE:32, CHEST:33,
  SAPLING:34, YOUNG_TREE:35, OAK:36, PINE:37, JUNGLE_TREE:38, PALM:39,
  FURNACE:40, REINFORCED_STONE:41, REINFORCED_IRON:42, STEEL_BLOCK:43, GOLD_BLOCK:44,
  HOLE:45,
  CONCRETE:46,
  FEEDING_TROUGH:47
};

const TILE_INFO = {
  [T.DIRT]:{name:'Dirt',color:[0x8B,0x6B,0x4B],hits:3,drop:'dirt',dropAmt:1,wh:1.0},
  [T.STONE]:{name:'Stone',color:[0x80,0x80,0x80],hits:6,drop:'stone',dropAmt:1,wh:1.0},
  [T.IRON]:{name:'Iron Ore',color:[0x90,0x70,0x50],hits:8,drop:'iron',dropAmt:1,wh:1.0},
  [T.GOLD]:{name:'Gold Ore',color:[0xD4,0xA0,0x17],hits:10,drop:'gold',dropAmt:1,wh:1.0},
  [T.CRYSTAL]:{name:'Crystal',color:[0x80,0x40,0xD0],hits:12,drop:'crystal',dropAmt:1,wh:1.0},
  [T.WOOD]:{name:'Wood',color:[0x6B,0x4B,0x2B],hits:4,drop:'wood',dropAmt:2,wh:1.0},
  [T.LEAVES]:{name:'Leaves',color:[0x22,0x8B,0x22],hits:1,drop:'berries',dropAmt:2,wh:1.0},
  [T.SAND]:{name:'Sand',color:[0xD2,0xB4,0x8C],hits:2,drop:'sand',dropAmt:1,wh:1.0},
  [T.SNOW]:{name:'Snow',color:[0xE8,0xE8,0xF0],hits:2,drop:'snow',dropAmt:1,wh:1.0},
  [T.OBSIDIAN]:{name:'Obsidian',color:[0x20,0x10,0x30],hits:15,drop:'obsidian',dropAmt:1,wh:1.0},
  [T.LAVA]:{name:'Lava',color:[0xFF,0x44,0x00],hits:999,wh:0.3},
  [T.WOOD_WALL]:{name:'Wood Wall',color:[0x8B,0x6B,0x3B],hits:5,drop:'wood',dropAmt:1,wh:0.8},
  [T.STONE_WALL]:{name:'Stone Wall',color:[0x70,0x70,0x70],hits:8,drop:'stone',dropAmt:1,wh:0.8},
  [T.FENCE]:{name:'Fence',color:[0x9B,0x7B,0x4B],hits:3,drop:'wood',dropAmt:1,wh:0.5},
  [T.DOOR]:{name:'Door',color:[0x6B,0x4B,0x1B],hits:3,drop:'wood',dropAmt:1,wh:0.85},
  [T.TORCH]:{name:'Torch',color:[0xFF,0xA5,0x00],hits:1,drop:'wood',dropAmt:1,wh:0.4},
  [T.WELL]:{name:'Well',color:[0x40,0x60,0x90],hits:8,drop:'stone',dropAmt:2,wh:0.6},
  [T.BRICK]:{name:'Brick',color:[0xA0,0x50,0x30],hits:10,drop:'stone',dropAmt:1,wh:1.0},
  [T.WATER]:{name:'Water',color:[0x20,0x60,0xC0],hits:999,wh:0.15},
  [T.HOUSE_WALL]:{name:'House Wall',color:[0xE0,0xD8,0xC0],hits:10,drop:'stone',dropAmt:2,wh:1.0},
  [T.THATCH_ROOF]:{name:'Thatch Roof',color:[0xAA,0x88,0x44],hits:4,drop:'wood',dropAmt:2,wh:0.9},
  [T.MARKET_STALL]:{name:'Market Stall',color:[0xBB,0x66,0x22],hits:5,drop:'wood',dropAmt:3,wh:0.7},
  [T.GLASS]:{name:'Glass',color:[0x88,0xCC,0xEE],hits:1,drop:null,dropAmt:0,wh:0.85},
  [T.COPPER]:{name:'Copper Ore',color:[0xB0,0x60,0x30],hits:7,drop:'copper',dropAmt:1,wh:1.0},
  [T.SILVER]:{name:'Silver Ore',color:[0xC0,0xC0,0xC8],hits:9,drop:'silver',dropAmt:1,wh:1.0},
  [T.CAMPFIRE]:{name:'Campfire',color:[0xFF,0x66,0x00],hits:3,drop:'wood',dropAmt:1,wh:0.25},
  [T.CHEST]:{name:'Chest',color:[0x8B,0x6B,0x2B],hits:5,drop:'wood',dropAmt:3,wh:0.45},
  [T.SAPLING]:{name:'Sapling',color:[0x44,0x88,0x22],hits:1,drop:null,dropAmt:0,wh:0.15},
  [T.YOUNG_TREE]:{name:'Young Tree',color:[0x55,0x77,0x33],hits:3,drop:'wood',dropAmt:1,wh:0.6},
  [T.OAK]:{name:'Oak Tree',color:[0x6B,0x4B,0x2B],hits:5,drop:'wood',dropAmt:3,wh:1.3},
  [T.PINE]:{name:'Pine Tree',color:[0x2B,0x55,0x2B],hits:5,drop:'wood',dropAmt:3,wh:1.5},
  [T.JUNGLE_TREE]:{name:'Jungle Tree',color:[0x33,0x66,0x11],hits:6,drop:'wood',dropAmt:4,wh:1.4},
  [T.PALM]:{name:'Palm Tree',color:[0x8B,0x7B,0x3B],hits:4,drop:'wood',dropAmt:2,wh:1.2},
  [T.FURNACE]:{name:'Furnace',color:[0x60,0x60,0x60],hits:10,drop:'stone',dropAmt:5,wh:0.7},
  [T.REINFORCED_STONE]:{name:'Reinforced Stone',color:[0x60,0x65,0x70],hits:20,drop:'stone',dropAmt:2,wh:1.0},
  [T.REINFORCED_IRON]:{name:'Reinforced Iron',color:[0x70,0x60,0x55],hits:30,drop:'iron',dropAmt:2,wh:1.0},
  [T.STEEL_BLOCK]:{name:'Steel Block',color:[0x88,0x88,0x90],hits:40,drop:'iron',dropAmt:3,wh:1.0},
  [T.GOLD_BLOCK]:{name:'Gold Block',color:[0xD4,0xA8,0x20],hits:25,drop:'gold',dropAmt:2,wh:1.0},
  [T.HOLE]:{name:'Hole',color:[0x33,0x22,0x11],hits:999,wh:0.2},
  [T.CONCRETE]:{name:'Concrete',color:[0x99,0x99,0x99],hits:20,drop:'concrete',dropAmt:1,wh:1.0},
  [T.FEEDING_TROUGH]:{name:'Feeding Trough',color:[0x8B,0x73,0x55],hits:4,drop:'wood',dropAmt:3,wh:0.4},
};

// ---- ITEMS ----
const ITEMS = {
  dirt:{name:'Dirt',color:'#8B6B4B',placeTile:T.DIRT,stack:64},
  stone:{name:'Stone',color:'#808080',stack:64},
  iron:{name:'Iron',color:'#B08050',stack:64},
  gold:{name:'Gold',color:'#D4A017',stack:64},
  crystal:{name:'Crystal',color:'#A040FF',stack:64},
  wood:{name:'Wood',color:'#8B6B3B',stack:64},
  sand:{name:'Sand',color:'#D2B48C',stack:64},
  snow:{name:'Snow',color:'#E0E0F0',stack:64},
  obsidian:{name:'Obsidian',color:'#302030',stack:64},
  berries:{name:'Berries',color:'#DD3366',stack:32,food:10},
  raw_meat:{name:'Raw Meat',color:'#CC4444',stack:16,food:10},
  cooked_meat:{name:'Cooked Meat',color:'#AA6633',stack:16,food:40},
  bread:{name:'Bread',color:'#DAA520',stack:16,food:30},
  wood_pickaxe:{name:'Wood Pick',color:'#8B6B3B',stack:1,tool:'pickaxe',tier:1},
  stone_pickaxe:{name:'Stone Pick',color:'#808080',stack:1,tool:'pickaxe',tier:2},
  iron_pickaxe:{name:'Iron Pick',color:'#B08050',stack:1,tool:'pickaxe',tier:3},
  wood_sword:{name:'Wood Sword',color:'#8B6B3B',stack:1,tool:'sword',tier:1,dmg:8},
  stone_sword:{name:'Stone Sword',color:'#808080',stack:1,tool:'sword',tier:2,dmg:15},
  iron_sword:{name:'Iron Sword',color:'#B08050',stack:1,tool:'sword',tier:3,dmg:25},
  wood_wall:{name:'Wood Wall',color:'#8B6B3B',placeTile:T.WOOD_WALL,stack:64},
  stone_wall:{name:'Stone Wall',color:'#707070',placeTile:T.STONE_WALL,stack:64},
  fence:{name:'Fence',color:'#9B7B4B',placeTile:T.FENCE,stack:64},
  door:{name:'Door',color:'#6B4B1B',placeTile:T.DOOR,stack:16},
  torch:{name:'Torch',color:'#FFA500',placeTile:T.TORCH,stack:32},
  well:{name:'Well',color:'#4060A0',placeTile:T.WELL,stack:4},
  house_wall:{name:'House Wall',color:'#E0D8C0',placeTile:T.HOUSE_WALL,stack:64},
  thatch_roof:{name:'Thatch Roof',color:'#AA8844',placeTile:T.THATCH_ROOF,stack:64},
  market_stall:{name:'Market Stall',color:'#BB6622',placeTile:T.MARKET_STALL,stack:16},
  glass:{name:'Glass',color:'#88CCEE',placeTile:T.GLASS,stack:32},
  gold_coin:{name:'Gold Coin',color:'#FFD700',stack:999},
  copper:{name:'Copper',color:'#B06030',stack:64},
  silver:{name:'Silver',color:'#C0C0C8',stack:64},
  gold_pickaxe:{name:'Gold Pick',color:'#D4A017',stack:1,tool:'pickaxe',tier:4},
  gold_sword:{name:'Gold Sword',color:'#D4A017',stack:1,tool:'sword',tier:4,dmg:35},
  campfire_item:{name:'Campfire',color:'#FF6600',placeTile:T.CAMPFIRE,stack:16},
  chest_item:{name:'Chest',color:'#8B6B2B',placeTile:T.CHEST,stack:16},
  health_potion:{name:'Health Potion',color:'#FF4466',stack:8,heal:50},
  speed_potion:{name:'Speed Potion',color:'#44AAFF',stack:8,speedBoost:true},
  strength_potion:{name:'Str Potion',color:'#FF8800',stack:8,strBoost:true},
  stew:{name:'Stew',color:'#AA6633',stack:16,food:50},
  fur_coat:{name:'Fur Coat',color:'#8B6B3B',stack:1,warmth:30},
  horse_whistle:{name:'Horse Whistle',color:'#8B5A2B',stack:1,summon:'horse'},
  chicken_egg:{name:'Tame Chicken',color:'#FFFFFF',stack:4,summon:'chicken'},
  wolf_pup:{name:'Wolf Pup',color:'#808080',stack:1,summon:'wolf'},
  oak_seed:{name:'Oak Seed',color:'#6B8B3B',stack:16,placeTile:T.SAPLING,seedSpecies:'oak'},
  pine_seed:{name:'Pine Seed',color:'#3B6B3B',stack:16,placeTile:T.SAPLING,seedSpecies:'pine'},
  jungle_seed:{name:'Jungle Seed',color:'#228B22',stack:16,placeTile:T.SAPLING,seedSpecies:'jungle'},
  palm_seed:{name:'Palm Seed',color:'#8B7B2B',stack:16,placeTile:T.SAPLING,seedSpecies:'palm'},
  wood_shovel:{name:'Wood Shovel',color:'#8B6B3B',stack:1,tool:'shovel',tier:1},
  stone_shovel:{name:'Stone Shovel',color:'#808080',stack:1,tool:'shovel',tier:2},
  iron_shovel:{name:'Iron Shovel',color:'#B08050',stack:1,tool:'shovel',tier:3},
  iron_ingot:{name:'Iron Ingot',color:'#A0A0A0',stack:64},
  gold_ingot:{name:'Gold Ingot',color:'#FFD700',stack:64},
  steel_ingot:{name:'Steel Ingot',color:'#B0B0B8',stack:64},
  reinforced_stone:{name:'Reinforced Stone',color:'#606570',placeTile:T.REINFORCED_STONE,stack:64},
  reinforced_iron:{name:'Reinforced Iron',color:'#706055',placeTile:T.REINFORCED_IRON,stack:64},
  steel_block:{name:'Steel Block',color:'#888890',placeTile:T.STEEL_BLOCK,stack:64},
  gold_block:{name:'Gold Block',color:'#D4A820',placeTile:T.GOLD_BLOCK,stack:64},
  furnace_item:{name:'Furnace',color:'#606060',placeTile:T.FURNACE,stack:16},
  boat:{name:'Boat',color:'#8B6B3B',stack:1,tool:'boat'},
  milk:{name:'Milk',color:'#EEEEEE',stack:16,food:15},
  wool:{name:'Wool',color:'#E8E0D0',stack:64},
  feathers:{name:'Feathers',color:'#CCBBAA',stack:64},
  raw_fish:{name:'Raw Fish',color:'#6688BB',stack:16,food:8},
  cooked_fish:{name:'Cooked Fish',color:'#AA8855',stack:16,food:35},
  empty_bucket:{name:'Empty Bucket',color:'#A0A0A0',stack:1},
  water_bucket:{name:'Water Bucket',color:'#4488CC',stack:1},
  matches:{name:'Matches',color:'#CC6633',stack:16},
  cheese:{name:'Cheese',color:'#DDCC44',stack:16,food:25},
  bacon:{name:'Bacon',color:'#CC5533',stack:16,food:20},
  ribs:{name:'Ribs',color:'#AA3322',stack:16,food:30},
  concrete:{name:'Concrete',color:'#999999',placeTile:T.CONCRETE,stack:64},
  feeding_trough:{name:'Feeding Trough',color:'#8B7355',placeTile:T.FEEDING_TROUGH,stack:4},
};

// ---- RECIPES ----
const RECIPES = [
  {result:'wood_pickaxe',amt:1,cost:{wood:5},cat:'Tools'},
  {result:'stone_pickaxe',amt:1,cost:{wood:3,stone:5},cat:'Tools'},
  {result:'iron_pickaxe',amt:1,cost:{wood:2,iron:5},cat:'Tools'},
  {result:'gold_pickaxe',amt:1,cost:{wood:2,gold:8},cat:'Tools'},
  {result:'wood_sword',amt:1,cost:{wood:6},cat:'Tools'},
  {result:'stone_sword',amt:1,cost:{wood:3,stone:6},cat:'Tools'},
  {result:'iron_sword',amt:1,cost:{wood:2,iron:6},cat:'Tools'},
  {result:'gold_sword',amt:1,cost:{wood:2,gold:8},cat:'Tools'},
  {result:'wood_wall',amt:4,cost:{wood:2},cat:'Building'},
  {result:'stone_wall',amt:4,cost:{stone:2},cat:'Building'},
  {result:'fence',amt:4,cost:{wood:3},cat:'Building'},
  {result:'door',amt:1,cost:{wood:4},cat:'Building'},
  {result:'torch',amt:4,cost:{wood:1,berries:1},cat:'Building'},
  {result:'well',amt:1,cost:{stone:8,iron:2},cat:'Building'},
  {result:'campfire_item',amt:1,cost:{wood:5,stone:3},cat:'Building'},
  {result:'chest_item',amt:1,cost:{wood:8,iron:2},cat:'Building'},
  {result:'house_wall',amt:4,cost:{stone:3,wood:2},cat:'Building'},
  {result:'thatch_roof',amt:4,cost:{wood:4},cat:'Building'},
  {result:'glass',amt:2,cost:{sand:4,crystal:1},cat:'Building'},
  {result:'market_stall',amt:1,cost:{wood:8,iron:2},cat:'Building'},
  {result:'health_potion',amt:1,cost:{berries:5,crystal:1},cat:'Potions'},
  {result:'speed_potion',amt:1,cost:{berries:3,copper:2,crystal:1},cat:'Potions'},
  {result:'strength_potion',amt:1,cost:{berries:3,iron:2,crystal:1},cat:'Potions'},
  {result:'stew',amt:2,cost:{raw_meat:2,berries:3},cat:'Food'},
  {result:'bread',amt:2,cost:{berries:4,wood:1},cat:'Food'},
  {result:'fur_coat',amt:1,cost:{raw_meat:3,wood:2},cat:'Misc'},
  {result:'gold_coin',amt:1,cost:{gold:2},cat:'Misc'},
  {result:'wood_shovel',amt:1,cost:{wood:5},cat:'Tools'},
  {result:'stone_shovel',amt:1,cost:{wood:3,stone:4},cat:'Tools'},
  {result:'iron_shovel',amt:1,cost:{wood:2,iron:4},cat:'Tools'},
  {result:'furnace_item',amt:1,cost:{stone:10,iron:5},cat:'Building'},
  {result:'boat',amt:1,cost:{wood:20,iron:5},cat:'Misc'},
  {result:'empty_bucket',amt:1,cost:{iron:3,wood:2},cat:'Tools'},
  {result:'matches',amt:4,cost:{wood:2,stone:1},cat:'Tools'},
  {result:'cheese',amt:2,cost:{milk:2},cat:'Food'},
  {result:'concrete',amt:4,cost:{stone:4,sand:4},cat:'Building'},
  {result:'feeding_trough',amt:1,cost:{wood:6,iron:2},cat:'Building'},
];

const SMELT_RECIPES = [
  {input:{iron:1},fuel:{wood:2},result:'iron_ingot',amt:1,name:'Smelt Iron Ingot'},
  {input:{gold:1},fuel:{wood:3},result:'gold_ingot',amt:1,name:'Smelt Gold Ingot'},
  {input:{iron_ingot:1},fuel:{wood:4},result:'steel_ingot',amt:1,name:'Forge Steel Ingot'},
  {input:{stone:2,iron_ingot:1},fuel:{wood:2},result:'reinforced_stone',amt:2,name:'Reinforced Stone'},
  {input:{iron_ingot:1,wood:2},fuel:{wood:2},result:'reinforced_iron',amt:2,name:'Reinforced Iron'},
  {input:{steel_ingot:1,wood:2},fuel:{wood:2},result:'steel_block',amt:2,name:'Steel Block'},
  {input:{gold_ingot:1,wood:2},fuel:{wood:2},result:'gold_block',amt:2,name:'Gold Block'},
  {input:{raw_fish:1},fuel:{wood:1},result:'cooked_fish',amt:1,name:'Cook Fish'},
];

// ---- CREATURE TYPES ----
const CREATURE_TYPES = {
  rabbit:{name:'Rabbit',hp:10,dmg:0,speed:1.8,color:'#C0A080',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.4},
  chicken:{name:'Chicken',hp:8,dmg:0,speed:1.2,color:'#FFFFFF',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.35},
  wolf:{name:'Wolf',hp:35,dmg:8,speed:2.2,color:'#808080',hostile:true,tameable:true,drop:'raw_meat',biome:'meadow',size:0.6},
  lizard:{name:'Lizard',hp:15,dmg:3,speed:1.5,color:'#669944',hostile:false,tameable:true,drop:'raw_meat',biome:'desert',size:0.4},
  scorpion:{name:'Scorpion',hp:25,dmg:10,speed:1.8,color:'#884422',hostile:true,tameable:false,drop:'raw_meat',biome:'desert',size:0.45},
  bear:{name:'Bear',hp:60,dmg:15,speed:1.6,color:'#5A3A1A',hostile:true,tameable:true,drop:'raw_meat',biome:'tundra',size:0.8},
  snow_fox:{name:'Snow Fox',hp:18,dmg:4,speed:2.5,color:'#E8E8F0',hostile:false,tameable:true,drop:'raw_meat',biome:'tundra',size:0.45},
  raptor:{name:'Raptor',hp:50,dmg:18,speed:2.8,color:'#446622',hostile:true,tameable:true,drop:'raw_meat',biome:'jungle',size:0.75},
  triceratops:{name:'Triceratops',hp:100,dmg:12,speed:1.2,color:'#667744',hostile:false,tameable:true,drop:'raw_meat',biome:'jungle',size:1.0},
  fire_drake:{name:'Fire Drake',hp:80,dmg:22,speed:2.0,color:'#DD4400',hostile:true,tameable:true,drop:'raw_meat',biome:'volcanic',size:0.9},
  elemental:{name:'Elemental',hp:60,dmg:16,speed:1.4,color:'#FF6600',hostile:true,tameable:false,drop:'obsidian',biome:'volcanic',size:0.7},
  horse:{name:'Horse',hp:40,dmg:0,speed:3.5,color:'#8B5A2B',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.85},
  deer:{name:'Deer',hp:25,dmg:0,speed:2.4,color:'#B08860',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.7},
  boar:{name:'Boar',hp:40,dmg:10,speed:2.0,color:'#6B4B2B',hostile:true,tameable:false,drop:'raw_meat',biome:'meadow',size:0.6},
  parrot:{name:'Parrot',hp:12,dmg:0,speed:1.8,color:'#22CC44',hostile:false,tameable:true,drop:'raw_meat',biome:'jungle',size:0.3},
  mountain_lion:{name:'Mountain Lion',hp:45,dmg:14,speed:2.6,color:'#C0A060',hostile:true,tameable:true,drop:'raw_meat',biome:'tundra',size:0.7},
  camel:{name:'Camel',hp:50,dmg:0,speed:1.6,color:'#D4B478',hostile:false,tameable:true,drop:'raw_meat',biome:'desert',size:0.9},
  cow:{name:'Cow',hp:50,dmg:0,speed:1.0,color:'#8B6B4B',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.85,specialDrop:'milk'},
  pig:{name:'Pig',hp:30,dmg:0,speed:1.4,color:'#DDA0A0',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.6},
  sheep:{name:'Sheep',hp:25,dmg:0,speed:1.2,color:'#E8E0D0',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.6,specialDrop:'wool'},
  goat:{name:'Goat',hp:30,dmg:3,speed:1.6,color:'#B0A090',hostile:false,tameable:true,drop:'raw_meat',biome:'tundra',size:0.55},
  eagle:{name:'Eagle',hp:20,dmg:6,speed:3.0,color:'#6B4B2B',hostile:true,tameable:false,drop:'feathers',biome:'tundra',size:0.4},
  crow:{name:'Crow',hp:10,dmg:0,speed:2.5,color:'#222222',hostile:false,tameable:false,drop:'feathers',biome:'meadow',size:0.3},
  fish:{name:'Fish',hp:5,dmg:0,speed:1.5,color:'#6688BB',hostile:false,tameable:false,drop:'raw_fish',biome:'meadow',size:0.2,aquatic:true},

};

// ---- BIOME DEFINITIONS ----
const BIOMES = {
  meadow:{name:'Meadow',ground:[0x55,0x88,0x33],sky1:'#5588CC',sky2:'#88BBEE',wall:T.DIRT,ore1:T.STONE,ore2:T.IRON,ore3:T.COPPER,tree:true,baseTemp:65},
  desert:{name:'Desert',ground:[0xC0,0xA0,0x60],sky1:'#CC9944',sky2:'#EEDD88',wall:T.SAND,ore1:T.STONE,ore2:T.GOLD,ore3:T.SILVER,tree:false,baseTemp:95},
  tundra:{name:'Tundra',ground:[0xCC,0xCC,0xDD],sky1:'#8899AA',sky2:'#BBCCDD',wall:T.SNOW,ore1:T.STONE,ore2:T.IRON,ore3:T.SILVER,tree:true,baseTemp:25},
  jungle:{name:'Jungle',ground:[0x22,0x66,0x22],sky1:'#336633',sky2:'#66AA66',wall:T.DIRT,ore1:T.IRON,ore2:T.CRYSTAL,ore3:T.COPPER,tree:true,baseTemp:80},
  volcanic:{name:'Volcanic',ground:[0x44,0x22,0x11],sky1:'#442200',sky2:'#884400',wall:T.OBSIDIAN,ore1:T.IRON,ore2:T.GOLD,ore3:T.COPPER,tree:false,baseTemp:85},
};

// ---- NPC TYPES ----
const NPC_TYPES = {
  merchant:{name:'Merchant',color:'#DDAA44',size:0.65,
    trades:[
      {give:{gold_coin:3},get:{cooked_meat:2}},
      {give:{gold_coin:5},get:{bread:3}},
      {give:{gold_coin:2},get:{torch:4}},
      {give:{gold_coin:8},get:{iron:5}},
      {give:{wood:20},get:{gold_coin:2}},
      {give:{stone:20},get:{gold_coin:2}},
      {give:{gold_coin:15},get:{boat:1}},
    ]},
  blacksmith:{name:'Blacksmith',color:'#AA6644',size:0.7,
    trades:[
      {give:{gold_coin:10},get:{iron_pickaxe:1}},
      {give:{gold_coin:12},get:{iron_sword:1}},
      {give:{gold_coin:6},get:{stone_pickaxe:1}},
      {give:{gold_coin:7},get:{stone_sword:1}},
      {give:{iron:10},get:{gold_coin:3}},
      {give:{gold:5},get:{gold_coin:8}},
    ]},
  farmer:{name:'Farmer',color:'#66AA44',size:0.6,
    trades:[
      {give:{gold_coin:1},get:{berries:5}},
      {give:{gold_coin:3},get:{bread:2}},
      {give:{gold_coin:2},get:{cooked_meat:1}},
      {give:{berries:10},get:{gold_coin:1}},
      {give:{raw_meat:5},get:{gold_coin:2}},
    ]},
  rancher:{name:'Rancher',color:'#886644',size:0.65,
    trades:[
      {give:{gold_coin:20},get:{horse_whistle:1}},
      {give:{gold_coin:8},get:{chicken_egg:1}},
      {give:{gold_coin:12},get:{wolf_pup:1}},
      {give:{gold_coin:4},get:{raw_meat:5}},
      {give:{raw_meat:10},get:{gold_coin:3}},
    ]},
  guard:{name:'Guard',color:'#4466AA',size:0.7,
    trades:[
      {give:{gold_coin:15},get:{iron_sword:1}},
      {give:{gold_coin:10},get:{iron_pickaxe:1}},
      {give:{gold_coin:8},get:{health_potion:1}},
      {give:{gold_coin:15},get:{boat:1}},
      {give:{gold_coin:5},get:{strength_potion:1}},
    ]},
  villager:{name:'Villager',color:'#AA9977',size:0.6,
    trades:[
      {give:{gold_coin:2},get:{torch:6}},
      {give:{gold_coin:1},get:{bread:1}},
      {give:{berries:5},get:{gold_coin:1}},
      {give:{wood:10},get:{gold_coin:1}},
    ]},
  innkeeper:{name:'Innkeeper',color:'#BB7744',size:0.65,
    trades:[
      {give:{gold_coin:2},get:{cooked_meat:2}},
      {give:{gold_coin:3},get:{bread:3}},
      {give:{gold_coin:5},get:{health_potion:1}},
      {give:{gold_coin:3},get:{cooked_fish:2}},
      {give:{gold_coin:8},get:{strength_potion:1}},
    ]},
  stablemaster:{name:'Stablemaster',color:'#776644',size:0.7,
    trades:[
      {give:{gold_coin:15},get:{horse_whistle:1}},
      {give:{gold_coin:10},get:{raw_meat:10}},
      {give:{gold_coin:5},get:{milk:5}},
      {give:{wool:10},get:{gold_coin:3}},
      {give:{feathers:20},get:{gold_coin:2}},
    ]},
};

// ---- TOWN TEMPLATES ----
const TOWN_NAMES = ['Hearthville','Dustwatch','Frostholm','Ironhaven','Ashridge'];

// ---- SEASONS ----
const SEASONS = [
  {name:'Spring', tempMod:0, color:'#88CC88', icon:'ðŸŒ±'},
  {name:'Summer', tempMod:15, color:'#FFAA44', icon:'â˜€ï¸'},
  {name:'Autumn', tempMod:-5, color:'#CC8844', icon:'ðŸ‚'},
  {name:'Winter', tempMod:-20, color:'#88BBEE', icon:'â„ï¸'},
];
const SEASON_DURATION = 300; // 5 minutes per season
const FREEZE_TEMP = 32;
const HEAT_TEMP = 110;
const SAVE_KEY_PREFIX = 'primal_frontier_slot_';

// ============================================================
// AUDIO SFX (Web Audio API oscillator tones)
// ============================================================
let audioCtx = null;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playTone(freq, dur, type, vol) {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type || 'square';
    o.frequency.value = freq;
    g.gain.value = vol || 0.1;
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
const SFX = {
  mine: () => playTone(200 + Math.random()*100, 0.08, 'square', 0.08),
  blockBreak: () => { playTone(150, 0.1, 'square', 0.12); setTimeout(() => playTone(100, 0.15, 'sawtooth', 0.06), 50); },
  attack: () => playTone(300, 0.12, 'sawtooth', 0.1),
  hurt: () => playTone(150, 0.2, 'sawtooth', 0.12),
  eat: () => { playTone(400, 0.06, 'sine', 0.08); setTimeout(() => playTone(500, 0.06, 'sine', 0.08), 80); },
  craft: () => { playTone(500, 0.08, 'square', 0.08); setTimeout(() => playTone(700, 0.1, 'square', 0.08), 100); },
  build: () => playTone(250, 0.15, 'square', 0.1),
  death: () => { playTone(200, 0.3, 'sawtooth', 0.15); setTimeout(() => playTone(100, 0.5, 'sawtooth', 0.12), 300); },
  potion: () => { playTone(600, 0.1, 'sine', 0.1); setTimeout(() => playTone(800, 0.15, 'sine', 0.1), 120); },
  trade: () => { playTone(500, 0.06, 'sine', 0.08); setTimeout(() => playTone(600, 0.06, 'sine', 0.08), 70); setTimeout(() => playTone(700, 0.08, 'sine', 0.08), 140); },
  levelUp: () => { playTone(400, 0.1, 'square', 0.1); setTimeout(() => playTone(500, 0.1, 'square', 0.1), 120); setTimeout(() => playTone(600, 0.1, 'square', 0.1), 240); setTimeout(() => playTone(800, 0.2, 'square', 0.12), 360); },
  tame: () => { playTone(500, 0.15, 'sine', 0.1); setTimeout(() => playTone(700, 0.2, 'sine', 0.1), 180); },
};

// ============================================================
// TEXTURE GENERATION
// ============================================================
const textures = {};

function genTex(id, baseR, baseG, baseB, pattern) {
  const data = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
  for (let y = 0; y < TEX_SIZE; y++) {
    for (let x = 0; x < TEX_SIZE; x++) {
      let r = baseR, g = baseG, b = baseB;
      const i = (y * TEX_SIZE + x) * 3;
      const noise = ((x * 7 + y * 13 + x * y) % 17) - 8;
      r += noise; g += noise; b += noise;
      if (pattern === 'brick') {
        const row = y >> 2;
        const off = (row & 1) ? 4 : 0;
        if (y % 4 === 0 || (x + off) % 8 === 0) { r -= 30; g -= 30; b -= 30; }
      } else if (pattern === 'ore') {
        if ((x + y * 3) % 11 < 2 && (x * y) % 7 < 3) { r += 40; g += 40; b += 20; }
      } else if (pattern === 'crystal') {
        if (Math.abs(x - 8) + Math.abs(y - 8) < 5 + ((x * y) % 3)) { r += 50; g -= 10; b += 60; }
      } else if (pattern === 'wood') {
        const ring = (y + (x >> 2)) % 5;
        if (ring < 1) { r -= 20; g -= 15; b -= 15; }
      } else if (pattern === 'leaves') {
        if ((x + y) % 3 === 0) { r -= 20; g += 10; b -= 20; }
      } else if (pattern === 'plank') {
        if (x % 5 === 0 || y === 0 || y === 15) { r -= 25; g -= 25; b -= 25; }
      } else if (pattern === 'cobble') {
        const bx = ((x + ((y >> 2) * 3)) % 6); const by = y % 4;
        if (bx === 0 || by === 0) { r -= 20; g -= 20; b -= 20; }
      } else if (pattern === 'lava') {
        const wave = Math.sin(x * 0.8 + y * 0.5) * 30;
        r = Math.min(255, r + wave); g = Math.max(0, g + wave * 0.3);
      } else if (pattern === 'water') {
        const wave = Math.sin(x * 0.6 + y * 0.4) * 20;
        b = Math.min(255, b + wave); g = Math.max(0, g + wave * 0.3);
      } else if (pattern === 'snow') {
        if ((x + y * 5) % 13 < 2) { r += 10; g += 10; b += 15; }
      } else if (pattern === 'fence') {
        if (x < 3 || x > 12 || (y > 5 && y < 10)) { /* keep */ } else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'door') {
        if (x === 0 || x === 15 || y === 0 || y === 15) { r -= 30; g -= 30; b -= 30; }
        if (x > 10 && x < 14 && y > 7 && y < 10) { r += 40; g += 30; b -= 10; }
      } else if (pattern === 'torch') {
        const cx = Math.abs(x - 8), cy = Math.abs(y - 4);
        if (cx < 2 && y > 4) { r = 0x6B; g = 0x4B; b = 0x2B; }
        else if (cx + cy < 4 && y < 8) { r = 0xFF; g = 0xAA + ((x * y) % 30); b = 0x20; }
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'well') {
        if (y < 4) { r = 0x50; g = 0x50; b = 0x60; }
        else if (y > 11) { r = 0x50; g = 0x50; b = 0x60; }
        else if (x < 3 || x > 12) { r = 0x50; g = 0x50; b = 0x60; }
        else { r = 0x20; g = 0x50; b = 0xB0; }
      } else if (pattern === 'plaster') {
        const speckle = ((x * 13 + y * 7) % 11) - 5;
        r += speckle; g += speckle - 2; b += speckle - 5;
        if (y === 0 || y === 15) { r -= 20; g -= 20; b -= 15; }
        if (x === 0 || x === 15) { r -= 15; g -= 15; b -= 10; }
      } else if (pattern === 'thatch') {
        const strand = (x + y * 2) % 4;
        if (strand === 0) { r -= 20; g -= 15; b -= 10; }
        if ((x + y) % 7 === 0) { r += 15; g += 10; }
      } else if (pattern === 'glass') {
        const shine = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 20;
        r += shine; g += shine; b += shine * 0.5;
        if (x === 0 || x === 15 || y === 0 || y === 15) { r -= 40; g -= 30; b -= 20; }
      } else if (pattern === 'campfire') {
        const cx2 = Math.abs(x - 8), cy2 = Math.abs(y - 8);
        if (cx2 < 3 && y > 10) { r = 0x6B; g = 0x4B; b = 0x2B; }
        else if (cx2 + cy2 < 6) { r = 0xFF; g = 0x88 + ((x * y) % 40); b = 0x10; }
        else { r = 0x44; g = 0x22; b = 0x11; }
      } else if (pattern === 'chest') {
        if (y === 0 || y === 15 || x === 0 || x === 15) { r -= 30; g -= 30; b -= 20; }
        else if (y < 3) { r += 15; g += 10; b += 5; }
        if (x > 6 && x < 10 && y > 6 && y < 9) { r = 0xD4; g = 0xA0; b = 0x17; }
      } else if (pattern === 'sapling') {
        // Small green sprout on dirt
        if (y > 10) { r = 0x8B; g = 0x6B; b = 0x4B; } // dirt base
        else if (Math.abs(x - 8) < 1 && y > 4) { r = 0x4B; g = 0x33; b = 0x1B; } // thin stem
        else if (Math.abs(x - 8) + Math.abs(y - 3) < 3) { r = 0x44; g = 0xAA; b = 0x22; } // leaf tuft
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'young_tree') {
        // Medium trunk + small canopy
        if (Math.abs(x - 8) < 2 && y > 8) { r = 0x6B; g = 0x4B; b = 0x2B; } // trunk
        else if (Math.abs(x - 8) + Math.abs(y - 5) < 5) { r = 0x33 + ((x * y) % 15); g = 0x88 + ((x + y) % 15); b = 0x22; } // canopy
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'oak') {
        // Wide brown trunk, big green top
        if (Math.abs(x - 8) < 3 && y > 10) { r = 0x6B; g = 0x4B; b = 0x2B; const ring = (y + (x >> 2)) % 4; if (ring < 1) { r -= 15; g -= 10; b -= 10; } }
        else if (Math.abs(x - 8) + Math.abs(y - 5) < 7) { r = 0x22 + ((x * y) % 12); g = 0x8B + ((x + y * 3) % 18); b = 0x22; if ((x + y) % 4 === 0) g += 10; }
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'pine') {
        // Narrow trunk, dark triangle
        if (Math.abs(x - 8) < 1 && y > 11) { r = 0x5B; g = 0x3B; b = 0x1B; }
        else { const w = Math.floor((15 - y) * 0.5); if (Math.abs(x - 8) <= w && y < 13 && y > 1) { r = 0x1B; g = 0x44 + ((x * y) % 12); b = 0x1B; if (y % 3 === 0) { r -= 5; g += 8; } } else { r = 0; g = 0; b = 0; } }
      } else if (pattern === 'jungle_tree') {
        // Thick trunk, lush canopy
        if (Math.abs(x - 8) < 3 && y > 9) { r = 0x4B; g = 0x3B; b = 0x1B; if ((x + y) % 3 === 0) g += 10; }
        else if (Math.abs(x - 8) + Math.abs(y - 4) < 7) { r = 0x11 + ((x * y) % 10); g = 0x77 + ((x + y) % 25); b = 0x11; if ((x * y) % 5 === 0) { r += 5; g += 15; } }
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'palm') {
        // Thin curved trunk, frond top
        if (Math.abs(x - 8 + (y > 8 ? (y - 8) * 0.2 : 0)) < 1.5 && y > 6) { r = 0x8B; g = 0x7B; b = 0x3B; }
        else if (y < 7 && (Math.abs(x - 8 + (y - 3) * 1.2) < 2 || Math.abs(x - 8 - (y - 3) * 1.2) < 2)) { r = 0x22; g = 0x88 + ((x + y) % 15); b = 0x11; }
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'furnace') {
        // Stone base with fire opening
        if (y < 3 || y > 13 || x < 2 || x > 13) { r = 0x55; g = 0x55; b = 0x55; }
        else if (y > 6 && y < 12 && x > 5 && x < 11) { r = 0xFF; g = 0x66 + ((x * y) % 30); b = 0x10; }
        else { r = 0x70; g = 0x70; b = 0x70; const spk = ((x * 7 + y * 11) % 9) - 4; r += spk; g += spk; b += spk; }
      } else if (pattern === 'reinforced') {
        // Metal-banded stone
        const bx2 = ((x + ((y >> 3) * 4)) % 8); const by2 = y % 4;
        if (bx2 === 0 || by2 === 0) { r -= 25; g -= 25; b -= 20; }
        if (y === 4 || y === 11) { r += 30; g += 25; b += 20; }
      } else if (pattern === 'steel') {
        // Polished metal look
        const shine2 = Math.sin(x * 0.4 + y * 0.3) * 15;
        r += shine2; g += shine2; b += shine2 + 5;
        if (x === 0 || x === 15 || y === 0 || y === 15) { r -= 20; g -= 20; b -= 15; }
      } else if (pattern === 'gold_block') {
        // Shiny gold
        const gleam = Math.sin(x * 0.6) * Math.cos(y * 0.4) * 20;
        r = Math.min(255, r + gleam); g = Math.min(255, g + gleam * 0.7);
        if ((x + y) % 5 === 0) { r += 15; g += 10; }
      } else if (pattern === 'hole') {
        // Dark circular pit
        const hcx = x - 8, hcy = y - 8;
        const hdist = Math.sqrt(hcx * hcx + hcy * hcy);
        if (hdist < 6) { r = 0x11; g = 0x0A; b = 0x05; }
        else if (hdist < 7) { r = 0x44; g = 0x33; b = 0x22; }
        else { r = 0; g = 0; b = 0; }
      }
      data[i] = Math.max(0, Math.min(255, r));
      data[i + 1] = Math.max(0, Math.min(255, g));
      data[i + 2] = Math.max(0, Math.min(255, b));
    }
  }
  textures[id] = data;
}

function initTextures() {
  genTex(T.DIRT, 0x8B, 0x6B, 0x4B, 'noise');
  genTex(T.STONE, 0x80, 0x80, 0x80, 'cobble');
  genTex(T.IRON, 0x80, 0x70, 0x50, 'ore');
  genTex(T.GOLD, 0xB0, 0x90, 0x20, 'ore');
  genTex(T.CRYSTAL, 0x70, 0x30, 0xB0, 'crystal');
  genTex(T.WOOD, 0x6B, 0x4B, 0x2B, 'wood');
  genTex(T.LEAVES, 0x22, 0x7B, 0x22, 'leaves');
  genTex(T.SAND, 0xC2, 0xA4, 0x7C, 'noise');
  genTex(T.SNOW, 0xDD, 0xDD, 0xE8, 'snow');
  genTex(T.OBSIDIAN, 0x20, 0x10, 0x30, 'cobble');
  genTex(T.LAVA, 0xEE, 0x44, 0x00, 'lava');
  genTex(T.WOOD_WALL, 0x8B, 0x6B, 0x3B, 'plank');
  genTex(T.STONE_WALL, 0x70, 0x70, 0x70, 'cobble');
  genTex(T.FENCE, 0x9B, 0x7B, 0x4B, 'fence');
  genTex(T.DOOR, 0x6B, 0x4B, 0x1B, 'door');
  genTex(T.TORCH, 0xFF, 0xA5, 0x00, 'torch');
  genTex(T.WELL, 0x40, 0x60, 0x90, 'well');
  genTex(T.BRICK, 0xA0, 0x50, 0x30, 'brick');
  genTex(T.WATER, 0x20, 0x60, 0xC0, 'water');
  genTex(T.HOUSE_WALL, 0xE0, 0xD8, 0xC0, 'plaster');
  genTex(T.THATCH_ROOF, 0xAA, 0x88, 0x44, 'thatch');
  genTex(T.MARKET_STALL, 0xBB, 0x66, 0x22, 'plank');
  genTex(T.GLASS, 0x88, 0xCC, 0xEE, 'glass');
  genTex(T.COPPER, 0xB0, 0x60, 0x30, 'ore');
  genTex(T.SILVER, 0xC0, 0xC0, 0xC8, 'ore');
  genTex(T.CAMPFIRE, 0xFF, 0x66, 0x00, 'campfire');
  genTex(T.CHEST, 0x8B, 0x6B, 0x2B, 'chest');
  genTex(T.SAPLING, 0x44, 0x88, 0x22, 'sapling');
  genTex(T.YOUNG_TREE, 0x55, 0x77, 0x33, 'young_tree');
  genTex(T.OAK, 0x6B, 0x4B, 0x2B, 'oak');
  genTex(T.PINE, 0x2B, 0x55, 0x2B, 'pine');
  genTex(T.JUNGLE_TREE, 0x33, 0x66, 0x11, 'jungle_tree');
  genTex(T.PALM, 0x8B, 0x7B, 0x3B, 'palm');
  genTex(T.FURNACE, 0x60, 0x60, 0x60, 'furnace');
  genTex(T.REINFORCED_STONE, 0x60, 0x65, 0x70, 'reinforced');
  genTex(T.REINFORCED_IRON, 0x70, 0x60, 0x55, 'reinforced');
  genTex(T.STEEL_BLOCK, 0x88, 0x88, 0x90, 'steel');
  genTex(T.GOLD_BLOCK, 0xD4, 0xA8, 0x20, 'gold_block');
  genTex(T.HOLE, 0x33, 0x22, 0x11, 'hole');
  genTex(T.CONCRETE, 0x99, 0x99, 0x99, 'cobble');
  genTex(T.FEEDING_TROUGH, 0x8B, 0x73, 0x55, 'plank');
}

// ============================================================
// SEEDED RANDOM
// ============================================================
let seed = 12345;
function setSeed(s) { seed = s; }
function rng() {
  seed = (seed * 1103515245 + 12345) & 0x7fffffff;
  return (seed >> 16) / 32768;
}
function rngInt(min, max) { return Math.floor(rng() * (max - min + 1)) + min; }

// ============================================================
// WORLD GENERATION
// ============================================================
let worldMap = null;
let blockChanges = {}; // delta storage for save
let undergroundMap = null;
let undergroundBlockChanges = {};

function getBiome(x, y) {
  const cx = MAP_SIZE / 2, cy = MAP_SIZE / 2;
  const dx = x - cx, dy = y - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < MAP_SIZE * 0.12) return 'meadow';
  const angle = Math.atan2(dy, dx);
  if (angle > -0.5 && angle < 1.0) return 'desert';
  if (angle >= 1.0 || angle < -2.5) return 'jungle';
  if (angle >= -2.5 && angle < -1.5) return 'volcanic';
  return 'tundra';
}

let townPositions = []; // [{x,y,name}]

function generateWorld(worldSeed) {
  setSeed(worldSeed);
  worldMap = new Uint8Array(MAP_SIZE * MAP_SIZE);
  const half = MAP_SIZE / 2;

  // Fill with biome-appropriate terrain
  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const idx = y * MAP_SIZE + x;

      // Border walls
      if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) {
        worldMap[idx] = T.STONE; continue;
      }

      const biome = getBiome(x, y);
      const bd = BIOMES[biome];

      // Noise-based walls (scaled frequencies for larger map)
      const sx = x * 0.03, sy = y * 0.03;
      const n1 = Math.sin(sx * 5) * Math.cos(sy * 4) * 0.5;
      const n2 = Math.sin(sx * 2.7 + 42) * Math.cos(sy * 3 + 17) * 0.3;
      const n3 = Math.sin(sx * 7.3 + sy * 6) * 0.2;
      const density = n1 + n2 + n3;

      if (density > 0.25) {
        const oreRoll = rng();
        if (oreRoll < 0.02) worldMap[idx] = T.CRYSTAL;
        else if (oreRoll < 0.05) worldMap[idx] = bd.ore2;
        else if (oreRoll < 0.09) worldMap[idx] = bd.ore3 || bd.ore1;
        else if (oreRoll < 0.15) worldMap[idx] = bd.ore1;
        else worldMap[idx] = bd.wall;
      } else if (density > 0.15 && bd.tree && rng() < 0.08) {
        const treeRoll = rng();
        if (biome === 'meadow') worldMap[idx] = treeRoll < 0.7 ? T.OAK : T.YOUNG_TREE;
        else if (biome === 'tundra') worldMap[idx] = treeRoll < 0.7 ? T.PINE : T.YOUNG_TREE;
        else if (biome === 'jungle') worldMap[idx] = treeRoll < 0.7 ? T.JUNGLE_TREE : T.YOUNG_TREE;
        else worldMap[idx] = treeRoll < 0.5 ? T.WOOD : T.LEAVES;
      } else {
        worldMap[idx] = T.AIR;
      }
    }
  }

  // Clear spawn area
  const spawnX = Math.floor(half), spawnY = Math.floor(half);
  for (let dy = -4; dy <= 4; dy++) {
    for (let dx = -4; dx <= 4; dx++) {
      worldMap[(spawnY + dy) * MAP_SIZE + (spawnX + dx)] = T.AIR;
    }
  }

  // Water pools (scattered across meadow)
  setSeed(worldSeed + 100);
  for (let i = 0; i < 40; i++) {
    const wx = rngInt(half - 200, half + 200);
    const wy = rngInt(half - 200, half + 200);
    if (getBiome(wx, wy) === 'meadow' && worldMap[wy * MAP_SIZE + wx] === T.AIR) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          if (Math.abs(dx) + Math.abs(dy) < 4) {
            const ni = (wy + dy) * MAP_SIZE + (wx + dx);
            if (ni >= 0 && ni < MAP_SIZE * MAP_SIZE && worldMap[ni] === T.AIR) worldMap[ni] = T.WATER;
          }
        }
      }
    }
  }

  // Lava in volcanic region
  setSeed(worldSeed + 200);
  for (let i = 0; i < 60; i++) {
    const lx = rngInt(50, half - 50);
    const ly = rngInt(half + 100, MAP_SIZE - 50);
    if (getBiome(lx, ly) === 'volcanic' && worldMap[ly * MAP_SIZE + lx] === T.AIR) {
      worldMap[ly * MAP_SIZE + lx] = T.LAVA;
      if (rng() < 0.5 && worldMap[(ly + 1) * MAP_SIZE + lx] === T.AIR) worldMap[(ly + 1) * MAP_SIZE + lx] = T.LAVA;
    }
  }

  // Lakes (25 total, all non-volcanic biomes)
  setSeed(worldSeed + 300);
  for (let i = 0; i < 25; i++) {
    const lx = rngInt(100, MAP_SIZE - 100);
    const ly = rngInt(100, MAP_SIZE - 100);
    const biome = getBiome(lx, ly);
    if (biome === 'volcanic') continue;
    const radius = rngInt(5, 15);
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const dist2 = dx * dx + dy * dy;
        const edge = radius + Math.sin(dx * 0.7) * 2 + Math.cos(dy * 0.5) * 2;
        if (dist2 < edge * edge) {
          const wx = lx + dx, wy = ly + dy;
          if (wx > 1 && wx < MAP_SIZE - 2 && wy > 1 && wy < MAP_SIZE - 2) {
            const blk = worldMap[wy * MAP_SIZE + wx];
            if (blk === T.AIR || blk === T.DIRT || blk === T.SAND || blk === T.SNOW) {
              worldMap[wy * MAP_SIZE + wx] = T.WATER;
            }
          }
        }
      }
    }
  }

  // Rivers (6 total)
  setSeed(worldSeed + 400);
  for (let i = 0; i < 6; i++) {
    const sx = rngInt(200, MAP_SIZE - 200);
    const sy = rngInt(200, MAP_SIZE - 200);
    const angle = rng() * Math.PI * 2;
    const len = rngInt(150, 400);
    const width = rngInt(2, 4);
    const amp = rngInt(10, 30);
    const freq = 0.02 + rng() * 0.03;
    for (let t = 0; t < len; t++) {
      const drift = Math.sin(t * freq) * amp;
      const px = Math.floor(sx + Math.cos(angle) * t + Math.cos(angle + Math.PI / 2) * drift);
      const py = Math.floor(sy + Math.sin(angle) * t + Math.sin(angle + Math.PI / 2) * drift);
      for (let w = -width; w <= width; w++) {
        const rx = px + Math.floor(Math.cos(angle + Math.PI / 2) * w);
        const ry = py + Math.floor(Math.sin(angle + Math.PI / 2) * w);
        if (rx > 1 && rx < MAP_SIZE - 2 && ry > 1 && ry < MAP_SIZE - 2) {
          if (getBiome(rx, ry) !== 'volcanic') {
            const blk = worldMap[ry * MAP_SIZE + rx];
            if (blk === T.AIR || blk === T.DIRT || blk === T.SAND || blk === T.SNOW) {
              worldMap[ry * MAP_SIZE + rx] = T.WATER;
            }
          }
        }
      }
    }
  }

  // Creeks (12 total)
  setSeed(worldSeed + 450);
  for (let i = 0; i < 12; i++) {
    let cx2 = rngInt(100, MAP_SIZE - 100);
    let cy2 = rngInt(100, MAP_SIZE - 100);
    let cAngle = rng() * Math.PI * 2;
    const cLen = rngInt(80, 200);
    for (let t = 0; t < cLen; t++) {
      cAngle += (rng() - 0.5) * 0.5;
      cx2 += Math.cos(cAngle);
      cy2 += Math.sin(cAngle);
      const rx = Math.floor(cx2), ry = Math.floor(cy2);
      if (rx > 1 && rx < MAP_SIZE - 2 && ry > 1 && ry < MAP_SIZE - 2) {
        if (getBiome(rx, ry) !== 'volcanic') {
          const blk = worldMap[ry * MAP_SIZE + rx];
          if (blk === T.AIR || blk === T.DIRT || blk === T.SAND || blk === T.SNOW) {
            worldMap[ry * MAP_SIZE + rx] = T.WATER;
          }
        }
      }
    }
  }

  // Generate towns
  generateTowns(worldSeed);

  // Generate underground
  generateUnderground(worldSeed);

  // Apply saved block changes (surface)
  for (const key in blockChanges) {
    const [bx, by] = key.split(',').map(Number);
    if (by >= 0 && by < MAP_SIZE && bx >= 0 && bx < MAP_SIZE)
      worldMap[by * MAP_SIZE + bx] = blockChanges[key];
  }

  // Apply underground block changes
  if (undergroundMap) {
    for (const key in undergroundBlockChanges) {
      const [bx, by] = key.split(',').map(Number);
      if (by >= 0 && by < MAP_SIZE && bx >= 0 && bx < MAP_SIZE)
        undergroundMap[by * MAP_SIZE + bx] = undergroundBlockChanges[key];
    }
  }
}

function generateTowns(ws) {
  setSeed(ws + 777);
  townPositions = [];
  // One town per biome, well-spaced
  // Hearthville (capital) in meadow near center
  // Dustwatch deep in desert (east)
  // Frostholm deep in tundra (north)
  // Ironhaven deep in jungle (south)
  // Ashridge deep in volcanic (northwest)
  const offsets = [
    {dx: 0, dy: -80},       // meadow center (capital)
    {dx: 450, dy: 100},     // desert (east)
    {dx: 100, dy: -450},    // tundra (north)
    {dx: -200, dy: 450},    // jungle (south)
    {dx: -350, dy: -350},   // volcanic (northwest)
  ];
  const half = MAP_SIZE / 2;
  for (let i = 0; i < TOWN_COUNT; i++) {
    const tx = Math.floor(half + offsets[i].dx + rngInt(-20, 20));
    const ty = Math.floor(half + offsets[i].dy + rngInt(-20, 20));
    const name = TOWN_NAMES[i];
    const capital = (i === 0);
    townPositions.push({x: tx, y: ty, name, mega: capital});
    if (capital) buildCapital(tx, ty);
    else buildTown(tx, ty);
  }
}

function buildTown(cx, cy) {
  const R = 16;
  // Clear area
  for (let dy = -R; dy <= R; dy++) {
    for (let dx = -R; dx <= R; dx++) {
      const x = cx + dx, y = cy + dy;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1)
        worldMap[y * MAP_SIZE + x] = T.AIR;
    }
  }
  // Perimeter wall with 4 gate gaps (3 tiles wide)
  for (let d = -R; d <= R; d++) {
    const positions = [
      {x: cx + d, y: cy - R}, {x: cx + d, y: cy + R},
      {x: cx - R, y: cy + d}, {x: cx + R, y: cy + d},
    ];
    for (const p of positions) {
      if (p.x <= 0 || p.x >= MAP_SIZE - 1 || p.y <= 0 || p.y >= MAP_SIZE - 1) continue;
      if (Math.abs(p.x - cx) <= 1 && (p.y === cy - R || p.y === cy + R)) continue;
      if (Math.abs(p.y - cy) <= 1 && (p.x === cx - R || p.x === cx + R)) continue;
      worldMap[p.y * MAP_SIZE + p.x] = T.HOUSE_WALL;
    }
  }
  // Central well
  if (cy > 0 && cy < MAP_SIZE - 1 && cx > 0 && cx < MAP_SIZE - 1)
    worldMap[cy * MAP_SIZE + cx] = T.WELL;
  // 6 houses (5x5 each)
  const houses = [
    {dx: -8, dy: -8}, {dx: 2, dy: -8}, {dx: -10, dy: 0},
    {dx: 6, dy: 0}, {dx: -7, dy: 7}, {dx: 4, dy: 7},
  ];
  for (const h of houses) {
    const hx = cx + h.dx, hy = cy + h.dy;
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = 0; dx < 5; dx++) {
        const x = hx + dx, y = hy + dy;
        if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
        if (dy === 0 || dy === 4 || dx === 0 || dx === 4)
          worldMap[y * MAP_SIZE + x] = T.HOUSE_WALL;
      }
    }
    const doorX = hx + 2, doorY = hy + 4;
    if (doorX > 0 && doorX < MAP_SIZE - 1 && doorY > 0 && doorY < MAP_SIZE - 1)
      worldMap[doorY * MAP_SIZE + doorX] = T.DOOR;
  }
  // Torches
  const torchSpots = [
    {dx:-3,dy:0},{dx:3,dy:0},{dx:0,dy:-3},{dx:0,dy:3},
    {dx:-6,dy:-3},{dx:6,dy:-3},{dx:-6,dy:4},{dx:6,dy:4},
    {dx:-3,dy:-6},{dx:3,dy:-6},{dx:-3,dy:6},{dx:3,dy:6},
  ];
  for (const ts of torchSpots) {
    const x = cx + ts.dx, y = cy + ts.dy;
    if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
      worldMap[y * MAP_SIZE + x] = T.TORCH;
  }
  // Market stalls
  const stalls = [{dx:3,dy:2},{dx:-3,dy:2},{dx:2,dy:-3},{dx:-2,dy:-3}];
  for (const s of stalls) {
    const x = cx + s.dx, y = cy + s.dy;
    if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
      worldMap[y * MAP_SIZE + x] = T.MARKET_STALL;
  }
}

function buildCapital(cx, cy) {
  const R = 40;
  // Clear entire area
  for (let dy = -R; dy <= R; dy++) {
    for (let dx = -R; dx <= R; dx++) {
      const x = cx + dx, y = cy + dy;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1)
        worldMap[y * MAP_SIZE + x] = T.AIR;
    }
  }
  // Double outer wall with 4 wide gate gaps (5 tiles wide at N/S/E/W)
  for (let layer = 0; layer < 2; layer++) {
    const r = R - layer;
    for (let d = -r; d <= r; d++) {
      const positions = [
        {x: cx + d, y: cy - r}, {x: cx + d, y: cy + r},
        {x: cx - r, y: cy + d}, {x: cx + r, y: cy + d},
      ];
      for (const p of positions) {
        if (p.x <= 0 || p.x >= MAP_SIZE - 1 || p.y <= 0 || p.y >= MAP_SIZE - 1) continue;
        if (Math.abs(p.x - cx) <= 2 && (p.y <= cy - r + 1 || p.y >= cy + r - 1)) continue;
        if (Math.abs(p.y - cy) <= 2 && (p.x <= cx - r + 1 || p.x >= cx + r - 1)) continue;
        worldMap[p.y * MAP_SIZE + p.x] = T.STONE_WALL;
      }
    }
  }
  // === Central plaza ===
  worldMap[cy * MAP_SIZE + cx] = T.WELL;
  // Ring of market stalls around center
  const stallRing = [
    {dx:-4,dy:-4},{dx:0,dy:-4},{dx:4,dy:-4},
    {dx:-4,dy:0},{dx:4,dy:0},
    {dx:-4,dy:4},{dx:0,dy:4},{dx:4,dy:4},
  ];
  for (const s of stallRing) {
    const x = cx + s.dx, y = cy + s.dy;
    if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1)
      worldMap[y * MAP_SIZE + x] = T.MARKET_STALL;
  }
  // === Town Hall (north, 12x8) ===
  const thX = cx - 6, thY = cy - 28;
  for (let dy = 0; dy < 8; dy++) {
    for (let dx = 0; dx < 12; dx++) {
      const x = thX + dx, y = thY + dy;
      if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
      if (dy === 0 || dy === 7 || dx === 0 || dx === 11)
        worldMap[y * MAP_SIZE + x] = T.STONE_WALL;
    }
  }
  worldMap[(thY + 7) * MAP_SIZE + (thX + 5)] = T.DOOR;
  worldMap[(thY + 7) * MAP_SIZE + (thX + 6)] = T.DOOR;
  worldMap[(thY + 2) * MAP_SIZE + (thX + 2)] = T.TORCH;
  worldMap[(thY + 2) * MAP_SIZE + (thX + 9)] = T.TORCH;
  // === Blacksmith (east, 8x6) ===
  const bsX = cx + 15, bsY = cy - 3;
  for (let dy = 0; dy < 6; dy++) {
    for (let dx = 0; dx < 8; dx++) {
      const x = bsX + dx, y = bsY + dy;
      if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
      if (dy === 0 || dy === 5 || dx === 0 || dx === 7)
        worldMap[y * MAP_SIZE + x] = T.STONE_WALL;
    }
  }
  worldMap[(bsY + 5) * MAP_SIZE + (bsX + 3)] = T.DOOR;
  worldMap[(bsY + 2) * MAP_SIZE + (bsX + 2)] = T.FURNACE;
  worldMap[(bsY + 2) * MAP_SIZE + (bsX + 5)] = T.TORCH;
  // === Tavern (west, 10x7) ===
  const tavX = cx - 25, tavY = cy - 3;
  for (let dy = 0; dy < 7; dy++) {
    for (let dx = 0; dx < 10; dx++) {
      const x = tavX + dx, y = tavY + dy;
      if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
      if (dy === 0 || dy === 6 || dx === 0 || dx === 9)
        worldMap[y * MAP_SIZE + x] = T.HOUSE_WALL;
    }
  }
  worldMap[(tavY + 6) * MAP_SIZE + (tavX + 4)] = T.DOOR;
  worldMap[(tavY + 6) * MAP_SIZE + (tavX + 5)] = T.DOOR;
  worldMap[(tavY + 2) * MAP_SIZE + (tavX + 5)] = T.CAMPFIRE;
  worldMap[(tavY + 2) * MAP_SIZE + (tavX + 2)] = T.TORCH;
  worldMap[(tavY + 2) * MAP_SIZE + (tavX + 7)] = T.TORCH;
  // === Stables (south, 14x8, fence walls) ===
  const stX = cx - 7, stY = cy + 18;
  for (let dy = 0; dy < 8; dy++) {
    for (let dx = 0; dx < 14; dx++) {
      const x = stX + dx, y = stY + dy;
      if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
      if (dy === 0 || dx === 0 || dx === 13)
        worldMap[y * MAP_SIZE + x] = T.FENCE;
    }
  }
  // Stall dividers inside
  for (let dy = 1; dy < 5; dy++) {
    for (const sdx of [4, 7, 10]) {
      const x = stX + sdx, y = stY + dy;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1)
        worldMap[y * MAP_SIZE + x] = T.FENCE;
    }
  }
  // Water troughs
  worldMap[(stY + 2) * MAP_SIZE + (stX + 2)] = T.WELL;
  worldMap[(stY + 2) * MAP_SIZE + (stX + 12)] = T.WELL;
  // === Wagons near stables (3x2 wood structures) ===
  const wagonSpots = [{dx: -14, dy: 20}, {dx: 10, dy: 20}];
  for (const ws2 of wagonSpots) {
    const wx = cx + ws2.dx, wy = cy + ws2.dy;
    for (let dy = 0; dy < 2; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const x = wx + dx, y = wy + dy;
        if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1)
          worldMap[y * MAP_SIZE + x] = T.WOOD_WALL;
      }
    }
    // Fence hitching post
    const fx = wx + 1, fy = wy + 2;
    if (fx > 0 && fx < MAP_SIZE - 1 && fy > 0 && fy < MAP_SIZE - 1)
      worldMap[fy * MAP_SIZE + fx] = T.FENCE;
  }
  // === 20 Residential houses in 4 quadrants (5 per quadrant, 5x5 each) ===
  const housePositions = [
    // NE quadrant
    {dx:8,dy:-18},{dx:16,dy:-18},{dx:24,dy:-18},{dx:8,dy:-12},{dx:16,dy:-12},
    // NW quadrant
    {dx:-12,dy:-18},{dx:-20,dy:-18},{dx:-28,dy:-18},{dx:-12,dy:-12},{dx:-20,dy:-12},
    // SE quadrant
    {dx:8,dy:8},{dx:16,dy:8},{dx:24,dy:8},{dx:8,dy:14},{dx:16,dy:14},
    // SW quadrant
    {dx:-12,dy:8},{dx:-20,dy:8},{dx:-28,dy:8},{dx:-12,dy:14},{dx:-20,dy:14},
  ];
  for (const h of housePositions) {
    const hx = cx + h.dx, hy = cy + h.dy;
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = 0; dx < 5; dx++) {
        const x = hx + dx, y = hy + dy;
        if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
        if (dy === 0 || dy === 4 || dx === 0 || dx === 4)
          worldMap[y * MAP_SIZE + x] = T.HOUSE_WALL;
      }
    }
    const doorX = hx + 2, doorY = hy + 4;
    if (doorX > 0 && doorX < MAP_SIZE - 1 && doorY > 0 && doorY < MAP_SIZE - 1)
      worldMap[doorY * MAP_SIZE + doorX] = T.DOOR;
  }
  // === Torch grid along main roads + scattered ===
  for (let d = -R + 3; d <= R - 3; d += 5) {
    // East-west road torches
    for (const yOff of [2, -2]) {
      const x = cx + d, y = cy + yOff;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
        worldMap[y * MAP_SIZE + x] = T.TORCH;
    }
    // North-south road torches
    for (const xOff of [2, -2]) {
      const x = cx + xOff, y = cy + d;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
        worldMap[y * MAP_SIZE + x] = T.TORCH;
    }
  }
  // Scatter torches in quadrants
  for (let dy = -R + 4; dy < R; dy += 8) {
    for (let dx = -R + 4; dx < R; dx += 8) {
      const x = cx + dx, y = cy + dy;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
        worldMap[y * MAP_SIZE + x] = T.TORCH;
    }
  }
}

function generateUnderground(ws) {
  setSeed(ws + 9999);
  undergroundMap = new Uint8Array(MAP_SIZE * MAP_SIZE);
  // Fill with stone
  for (let i = 0; i < MAP_SIZE * MAP_SIZE; i++) undergroundMap[i] = T.STONE;
  // Cellular automata caves: seed 45% AIR
  const tempGrid = new Uint8Array(MAP_SIZE * MAP_SIZE);
  for (let y = 1; y < MAP_SIZE - 1; y++) {
    for (let x = 1; x < MAP_SIZE - 1; x++) {
      tempGrid[y * MAP_SIZE + x] = rng() < 0.45 ? T.AIR : T.STONE;
    }
  }
  // 4 iterations of smoothing
  for (let iter = 0; iter < 4; iter++) {
    const next = new Uint8Array(MAP_SIZE * MAP_SIZE);
    for (let y = 1; y < MAP_SIZE - 1; y++) {
      for (let x = 1; x < MAP_SIZE - 1; x++) {
        let stoneCount = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (tempGrid[(y + dy) * MAP_SIZE + (x + dx)] === T.STONE) stoneCount++;
          }
        }
        next[y * MAP_SIZE + x] = stoneCount >= 5 ? T.STONE : T.AIR;
      }
    }
    for (let i = 0; i < MAP_SIZE * MAP_SIZE; i++) tempGrid[i] = next[i];
  }
  // Copy smoothed result
  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const idx = y * MAP_SIZE + x;
      if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) {
        undergroundMap[idx] = T.STONE;
      } else {
        undergroundMap[idx] = tempGrid[idx];
      }
    }
  }
  // 3x ore density in stone walls
  setSeed(ws + 10000);
  for (let y = 1; y < MAP_SIZE - 1; y++) {
    for (let x = 1; x < MAP_SIZE - 1; x++) {
      if (undergroundMap[y * MAP_SIZE + x] !== T.STONE) continue;
      const oreRoll = rng();
      if (oreRoll < 0.06) undergroundMap[y * MAP_SIZE + x] = T.CRYSTAL;
      else if (oreRoll < 0.15) undergroundMap[y * MAP_SIZE + x] = T.GOLD;
      else if (oreRoll < 0.25) undergroundMap[y * MAP_SIZE + x] = T.IRON;
      else if (oreRoll < 0.32) undergroundMap[y * MAP_SIZE + x] = T.COPPER;
      else if (oreRoll < 0.38) undergroundMap[y * MAP_SIZE + x] = T.SILVER;
    }
  }
}

function getBlock(x, y) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return T.STONE;
  if (player.level === 1 && undergroundMap) return undergroundMap[y * MAP_SIZE + x];
  return worldMap[y * MAP_SIZE + x];
}

function setBlock(x, y, val) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return;
  if (player.level === 1 && undergroundMap) {
    undergroundMap[y * MAP_SIZE + x] = val;
    undergroundBlockChanges[x + ',' + y] = val;
  } else {
    worldMap[y * MAP_SIZE + x] = val;
    blockChanges[x + ',' + y] = val;
  }
}

function getBlockOnLayer(x, y, layer) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return T.STONE;
  if (layer === 1 && undergroundMap) return undergroundMap[y * MAP_SIZE + x];
  return worldMap[y * MAP_SIZE + x];
}

function setBlockOnLayer(x, y, val, layer) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return;
  if (layer === 1 && undergroundMap) {
    undergroundMap[y * MAP_SIZE + x] = val;
    undergroundBlockChanges[x + ',' + y] = val;
  } else {
    worldMap[y * MAP_SIZE + x] = val;
    blockChanges[x + ',' + y] = val;
  }
}

// ============================================================
// GAME STATE
// ============================================================
let gameRunning = false;
let craftingOpen = false;

const player = {
  x: MAP_SIZE / 2 + 0.5,
  y: MAP_SIZE / 2 + 0.5,
  angle: 0,
  hp: 100,
  maxHp: 100,
  hunger: 100,
  maxHunger: 100,
  hotbar: new Array(8).fill(null),
  backpack: new Array(BACKPACK_SIZE).fill(null),
  selectedSlot: 0,
  miningTarget: null,
  miningProgress: 0,
  attackCooldown: 0,
  sprinting: false,
  pitch: 0, // horizon offset in pixels (positive = look up)
  swimStamina: 100,
  maxSwimStamina: 100,
  inTree: false,
  treePos: null,
  treeStealth: false,
  level: 0, // 0=surface, 1=underground
  digProgress: {},
  riding: null, // reference to mounted creature
};

let creatures = [];
let npcs = []; // town NPCs
let minimapSize = 0;
let worldSeed = 12345;
let notifications = [];
let torchPositions = [];
let buildMode = false;
let buildMenuOpen = false;
let backpackOpen = false;
let tradeOpen = false;
let tradeNPC = null; // currently trading NPC
let smeltOpen = false;
let fullscreenMapOpen = false;
let currentSeason = 0;
let seasonTimer = 0;
let playerTemp = 65;
let activeSlot = -1; // which save slot is active
let speedBoostTimer = 0;
let strengthBoostTimer = 0;
let chestInventories = {}; // key: "x,y" -> array of items
let dayTimer = 0;
const DAY_LENGTH = 600; // 10 minutes full cycle (0=noon, 0.5=midnight)
let playerXP = 0;
let playerLevel = 1;
let damageFlash = 0; // red tint timer on taking damage
let damageDirection = 0; // angle of last damage source
let damageIndicatorTimer = 0; // how long to show directional indicator
let saplingData = {}; // key: "x,y" -> species string (e.g. 'oak','pine')
let treeGrowthTimer = 0;

// ---- INPUT ----
const keys = {};
let mouseDown = {left: false, right: false};
let mouseDX = 0;
let mouseDY = 0;
let pointerLocked = false;
const PITCH_SPEED = 0.004;
const MAX_PITCH = 600; // max pixel offset for horizon

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (buildMenuOpen) {
    if (e.code === 'KeyB' || e.code === 'Escape') { toggleBuildMenu(); e.preventDefault(); }
    // Number keys 1-9 select build item
    if (e.code >= 'Digit1' && e.code <= 'Digit9') {
      selectBuildItem(parseInt(e.code[5]) - 1);
      e.preventDefault();
    }
  } else if (fullscreenMapOpen) {
    if (e.code === 'KeyM' || e.code === 'Escape') { toggleFullscreenMap(); e.preventDefault(); }
  } else if (craftingOpen) {
    if (e.code === 'KeyE' || e.code === 'Escape') { toggleCrafting(); e.preventDefault(); }
  } else if (backpackOpen) {
    if (e.code === 'Tab' || e.code === 'Escape') { toggleBackpack(); e.preventDefault(); }
  } else if (tradeOpen) {
    if (e.code === 'KeyE' || e.code === 'Escape') { closeTrade(); e.preventDefault(); }
  } else if (smeltOpen) {
    if (e.code === 'KeyE' || e.code === 'Escape') { closeSmeltMenu(); e.preventDefault(); }
  } else if (gameRunning) {
    if (e.code === 'KeyE') {
      const nearNPC = findNearbyNPC();
      if (nearNPC) { openTrade(nearNPC); e.preventDefault(); return; }
      toggleCrafting(); e.preventDefault();
    }
    if (e.code === 'KeyM') { toggleFullscreenMap(); e.preventDefault(); }
    if (e.code === 'Tab') { toggleBackpack(); e.preventDefault(); }
    if (e.code === 'KeyB') { toggleBuildMenu(); e.preventDefault(); }
    if (e.code >= 'Digit1' && e.code <= 'Digit8') {
      player.selectedSlot = parseInt(e.code[5]) - 1;
      e.preventDefault();
    }
    // R key â€” mount/dismount horse
    if (e.code === 'KeyR') {
      if (player.riding) {
        // Dismount horse
        player.riding.x = player.x + Math.cos(player.angle) * 1.5;
        player.riding.y = player.y + Math.sin(player.angle) * 1.5;
        player.riding.state = 'idle';
        player.riding = null;
        notify('Dismounted');
      } else if (!player.inTree) {
        // Try to mount a nearby tamed horse
        for (const c of creatures) {
          if (!c.tamed || c.type !== 'horse') continue;
          const dx2 = c.x - player.x, dy2 = c.y - player.y;
          if (Math.sqrt(dx2 * dx2 + dy2 * dy2) < 3) {
            player.riding = c;
            c.state = 'follow';
            notify('Mounted horse! [R] to dismount');
            break;
          }
        }
      }
      e.preventDefault();
      return;
    }
    // Tree climbing
    if (e.code === 'Space') {
      if (player.inTree) {
        // Climb down
        player.inTree = false;
        player.treePos = null;
        player.treeStealth = false;
        notify('Climbed down from tree');
      } else {
        // Check for nearby climbable tree (2-unit radius)
        const px = Math.floor(player.x), py = Math.floor(player.y);
        let foundTree = false;
        for (let dy = -2; dy <= 2 && !foundTree; dy++) {
          for (let dx = -2; dx <= 2 && !foundTree; dx++) {
            const blk = getBlock(px + dx, py + dy);
            if (blk === T.OAK || blk === T.PINE || blk === T.JUNGLE_TREE || blk === T.PALM) {
              player.inTree = true;
              player.treePos = {x: px + dx, y: py + dy};
              player.treeStealth = false;
              notify('Climbed up tree! [Space] down, [S] stealth');
              foundTree = true;
            }
          }
        }
      }
      e.preventDefault();
    }
    // Toggle stealth while in tree
    if (e.code === 'KeyS' && player.inTree) {
      player.treeStealth = !player.treeStealth;
      notify(player.treeStealth ? 'Stealth: HIDDEN' : 'Stealth: OFF');
      e.preventDefault();
    }
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

C.addEventListener('mousedown', e => {
  const anyMenuOpen = craftingOpen || buildMenuOpen || fullscreenMapOpen || backpackOpen || tradeOpen || smeltOpen;
  if (!pointerLocked && gameRunning && !anyMenuOpen) {
    C.requestPointerLock();
    return;
  }
  if (e.button === 0) mouseDown.left = true;
  if (e.button === 2) mouseDown.right = true;
});
C.addEventListener('mouseup', e => {
  if (e.button === 0) mouseDown.left = false;
  if (e.button === 2) mouseDown.right = false;
});
C.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('mousemove', e => {
  if (pointerLocked) { mouseDX += e.movementX; mouseDY += e.movementY; }
});
document.addEventListener('pointerlockchange', () => {
  pointerLocked = document.pointerLockElement === C;
  if (!pointerLocked && gameRunning && !craftingOpen) {
    // Lost pointer lock unexpectedly
  }
});

// ============================================================
// INVENTORY HELPERS
// ============================================================
function addItem(id, count) {
  if (!ITEMS[id]) return 0;
  const maxStack = ITEMS[id].stack || 64;
  let remaining = count;

  // Try to stack with existing hotbar
  for (let i = 0; i < 8 && remaining > 0; i++) {
    const slot = player.hotbar[i];
    if (slot && slot.id === id && slot.count < maxStack) {
      const add = Math.min(remaining, maxStack - slot.count);
      slot.count += add;
      remaining -= add;
    }
  }
  // Try empty hotbar slots
  for (let i = 0; i < 8 && remaining > 0; i++) {
    if (!player.hotbar[i]) {
      const add = Math.min(remaining, maxStack);
      player.hotbar[i] = { id, count: add };
      remaining -= add;
    }
  }
  // Overflow to backpack - stack first
  for (let i = 0; i < BACKPACK_SIZE && remaining > 0; i++) {
    const slot = player.backpack[i];
    if (slot && slot.id === id && slot.count < maxStack) {
      const add = Math.min(remaining, maxStack - slot.count);
      slot.count += add;
      remaining -= add;
    }
  }
  // Overflow to backpack - empty slots
  for (let i = 0; i < BACKPACK_SIZE && remaining > 0; i++) {
    if (!player.backpack[i]) {
      const add = Math.min(remaining, maxStack);
      player.backpack[i] = { id, count: add };
      remaining -= add;
    }
  }
  return count - remaining;
}

function removeItem(id, count) {
  let remaining = count;
  for (let i = 7; i >= 0 && remaining > 0; i--) {
    const slot = player.hotbar[i];
    if (slot && slot.id === id) {
      const take = Math.min(remaining, slot.count);
      slot.count -= take;
      remaining -= take;
      if (slot.count <= 0) player.hotbar[i] = null;
    }
  }
  // Also take from backpack
  for (let i = BACKPACK_SIZE - 1; i >= 0 && remaining > 0; i--) {
    const slot = player.backpack[i];
    if (slot && slot.id === id) {
      const take = Math.min(remaining, slot.count);
      slot.count -= take;
      remaining -= take;
      if (slot.count <= 0) player.backpack[i] = null;
    }
  }
  return remaining === 0;
}

function countItem(id) {
  let total = 0;
  for (let i = 0; i < 8; i++) {
    if (player.hotbar[i] && player.hotbar[i].id === id) total += player.hotbar[i].count;
  }
  for (let i = 0; i < BACKPACK_SIZE; i++) {
    if (player.backpack[i] && player.backpack[i].id === id) total += player.backpack[i].count;
  }
  return total;
}

function getHeldItem() {
  const slot = player.hotbar[player.selectedSlot];
  if (!slot) return null;
  return ITEMS[slot.id];
}

function getHeldItemId() {
  const slot = player.hotbar[player.selectedSlot];
  return slot ? slot.id : null;
}

function getPickaxeTier() {
  for (let i = 0; i < 8; i++) {
    const slot = player.hotbar[i];
    if (slot) {
      const item = ITEMS[slot.id];
      if (item && item.tool === 'pickaxe') return item.tier;
    }
  }
  return 0; // bare hands
}

function getShovelTier() {
  for (let i = 0; i < 8; i++) {
    const slot = player.hotbar[i];
    if (slot) {
      const item = ITEMS[slot.id];
      if (item && item.tool === 'shovel') return item.tier;
    }
  }
  return 0;
}

function isSoftBlock(block) {
  return block === T.DIRT || block === T.SAND || block === T.SNOW;
}

function getSwordDmg() {
  const held = getHeldItem();
  let base = 3; // fist damage
  if (held && held.tool === 'sword') base = held.dmg;
  // Hunger affects strength: full hunger = 1.0x, empty = 0.3x
  const hungerMult = 0.3 + 0.7 * (player.hunger / player.maxHunger);
  // Strength potion doubles damage
  const strMult = strengthBoostTimer > 0 ? 2.0 : 1.0;
  return Math.floor(base * hungerMult * strMult);
}

function notify(msg) {
  notifications.push({ msg, time: 3.0 });
  if (notifications.length > 5) notifications.shift();
}

// ---- XP / LEVEL SYSTEM ----
function xpToLevel(lvl) { return lvl * 20 + 10; }
function gainXP(amt) {
  playerXP += amt;
  const needed = xpToLevel(playerLevel);
  if (playerXP >= needed) {
    playerXP -= needed;
    playerLevel++;
    player.maxHp += 10;
    player.hp = Math.min(player.hp + 20, player.maxHp);
    notify('LEVEL UP! Level ' + playerLevel + ' (+10 max HP)');
    SFX.levelUp();
  }
}

// ============================================================
// CRAFTING
// ============================================================
function toggleCrafting() {
  craftingOpen = !craftingOpen;
  const menu = document.getElementById('crafting-menu');
  menu.style.display = craftingOpen ? 'block' : 'none';
  if (craftingOpen) {
    document.exitPointerLock();
    renderCraftingMenu();
  } else {
    if (gameRunning) C.requestPointerLock();
  }
}

function canCraft(recipe) {
  for (const [itemId, need] of Object.entries(recipe.cost)) {
    if (countItem(itemId) < need) return false;
  }
  return true;
}

function doCraft(idx) {
  const recipe = RECIPES[idx];
  if (!canCraft(recipe)) return;
  for (const [itemId, need] of Object.entries(recipe.cost)) {
    removeItem(itemId, need);
  }
  const added = addItem(recipe.result, recipe.amt);
  if (added > 0) { notify('Crafted ' + ITEMS[recipe.result].name + (recipe.amt > 1 ? ' x' + recipe.amt : '')); SFX.craft(); gainXP(2); }
  renderCraftingMenu();
}

function renderCraftingMenu() {
  const list = document.getElementById('recipe-list');
  let html = '';
  let lastCat = '';
  RECIPES.forEach((r, i) => {
    if (r.cat !== lastCat) {
      html += `<div style="color:#888;font-size:11px;text-transform:uppercase;letter-spacing:1px;margin:10px 0 6px;padding-top:6px;border-top:1px solid #333;">${r.cat}</div>`;
      lastCat = r.cat;
    }
    const can = canCraft(r);
    const costStr = Object.entries(r.cost).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    html += `<div class="recipe-row">
      <span class="recipe-name">${ITEMS[r.result].name}${r.amt > 1 ? ' x' + r.amt : ''}</span>
      <span class="recipe-cost">${costStr}</span>
      <button class="recipe-craft ${can ? '' : 'cannot'}" onclick="doCraft(${i})">${can ? 'Craft' : 'Need'}</button>
    </div>`;
  });
  list.innerHTML = html;
}

// ============================================================
// BACKPACK UI
// ============================================================
function toggleBackpack() {
  backpackOpen = !backpackOpen;
  const menu = document.getElementById('backpack-menu');
  menu.style.display = backpackOpen ? 'block' : 'none';
  if (backpackOpen) {
    document.exitPointerLock();
    renderBackpackMenu();
  } else {
    if (gameRunning) C.requestPointerLock();
  }
}

function renderBackpackMenu() {
  const el = document.getElementById('backpack-slots');
  let html = '<div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-bottom:14px;">';
  // Hotbar
  html += '<div style="width:100%;color:#e8a030;font-size:12px;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px;">Hotbar</div>';
  for (let i = 0; i < 8; i++) {
    const slot = player.hotbar[i];
    const sel = i === player.selectedSlot ? 'border-color:#e8a030;' : '';
    html += `<div class="bp-slot" style="${sel}" onclick="bpClickHotbar(${i})">`;
    if (slot) {
      const item = ITEMS[slot.id];
      html += `<div style="width:28px;height:28px;background:${item.color};border-radius:3px;margin:2px auto;"></div>`;
      html += `<div style="font-size:9px;color:#ccc;">${item.name}</div>`;
      if (slot.count > 1) html += `<div style="font-size:9px;color:#aaa;">x${slot.count}</div>`;
    }
    html += '</div>';
  }
  // Backpack
  html += `<div style="width:100%;color:#44aaff;font-size:12px;text-transform:uppercase;letter-spacing:1px;margin:10px 0 4px;">Backpack (${BACKPACK_SIZE} slots)</div>`;
  for (let i = 0; i < BACKPACK_SIZE; i++) {
    const slot = player.backpack[i];
    html += `<div class="bp-slot" onclick="bpClickBackpack(${i})">`;
    if (slot) {
      const item = ITEMS[slot.id];
      html += `<div style="width:28px;height:28px;background:${item.color};border-radius:3px;margin:2px auto;"></div>`;
      html += `<div style="font-size:9px;color:#ccc;">${item.name}</div>`;
      if (slot.count > 1) html += `<div style="font-size:9px;color:#aaa;">x${slot.count}</div>`;
    }
    html += '</div>';
  }
  html += '</div>';
  el.innerHTML = html;
}

function bpClickHotbar(i) {
  // Move hotbar item to first empty backpack slot
  if (!player.hotbar[i]) return;
  for (let j = 0; j < BACKPACK_SIZE; j++) {
    if (!player.backpack[j]) {
      player.backpack[j] = player.hotbar[i];
      player.hotbar[i] = null;
      renderBackpackMenu();
      return;
    }
  }
  notify('Backpack full!');
}

function bpClickBackpack(i) {
  // Move backpack item to first empty hotbar slot
  if (!player.backpack[i]) return;
  for (let j = 0; j < 8; j++) {
    if (!player.hotbar[j]) {
      player.hotbar[j] = player.backpack[i];
      player.backpack[i] = null;
      renderBackpackMenu();
      return;
    }
  }
  notify('Hotbar full!');
}

// ============================================================
// NPC SYSTEM
// ============================================================
function spawnNPCs() {
  npcs = [];
  for (const town of townPositions) {
    if (town.mega) {
      // Capital: 27+ NPCs spread across districts
      const capitalNPCs = [];
      // 4 merchants near central market
      for (let i = 0; i < 4; i++) {
        const a = (i / 4) * Math.PI * 2;
        capitalNPCs.push({type:'merchant', ox: Math.round(Math.cos(a) * 6), oy: Math.round(Math.sin(a) * 6)});
      }
      // 2 blacksmiths near smithy (east)
      capitalNPCs.push({type:'blacksmith', ox: 17, oy: -1});
      capitalNPCs.push({type:'blacksmith', ox: 19, oy: 1});
      // 3 farmers wandering
      for (let i = 0; i < 3; i++) {
        const a = (i / 3) * Math.PI * 2 + 0.5;
        capitalNPCs.push({type:'farmer', ox: Math.round(Math.cos(a) * (10 + i * 3)), oy: Math.round(Math.sin(a) * (10 + i * 3))});
      }
      // 2 ranchers near stables (south)
      capitalNPCs.push({type:'rancher', ox: -3, oy: 20});
      capitalNPCs.push({type:'rancher', ox: 3, oy: 22});
      // 1 innkeeper at tavern (west)
      capitalNPCs.push({type:'innkeeper', ox: -22, oy: 0});
      // 1 stablemaster at stables (south)
      capitalNPCs.push({type:'stablemaster', ox: 0, oy: 22});
      // 6 villagers wandering throughout
      for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 + 1.0;
        const r = 8 + i * 4;
        capitalNPCs.push({type:'villager', ox: Math.round(Math.cos(a) * r), oy: Math.round(Math.sin(a) * r)});
      }
      // Place all named NPCs
      for (const cn of capitalNPCs) {
        npcs.push({
          type: cn.type,
          x: town.x + cn.ox + 0.5,
          y: town.y + cn.oy + 0.5,
          town: town.name, angle: 0,
        });
      }
      // 8 guards on outer patrol ring
      for (let g = 0; g < 8; g++) {
        const a = (g / 8) * Math.PI * 2;
        npcs.push({
          type: 'guard',
          x: town.x + Math.round(Math.cos(a) * 30) + 0.5,
          y: town.y + Math.round(Math.sin(a) * 30) + 0.5,
          town: town.name, angle: a,
        });
      }
      // Spawn 4 tamed horses at the stables
      for (let h = 0; h < 4; h++) {
        const hx = town.x - 5 + h * 3;
        const hy = town.y + 20;
        creatures.push({
          type: 'horse', x: hx + 0.5, y: hy + 0.5,
          hp: 40, maxHp: 40, state: 'idle', stateTimer: 0,
          angle: Math.PI, attackTimer: 0, tamed: true, attackAnim: 0,
          produceTimer: 0, penned: true,
        });
      }
    } else {
      // Normal towns: 8 NPCs (merchant, blacksmith, farmer, rancher, 2 guards, 2 villagers)
      const townTypes = ['merchant','blacksmith','farmer','rancher','guard','guard','villager','villager'];
      for (let i = 0; i < townTypes.length; i++) {
        const a = (i / townTypes.length) * Math.PI * 2;
        const r = 4 + (i % 2) * 3;
        npcs.push({
          type: townTypes[i],
          x: town.x + Math.round(Math.cos(a) * r) + 0.5,
          y: town.y + Math.round(Math.sin(a) * r) + 0.5,
          town: town.name, angle: 0,
        });
      }
    }
  }
}

function findNearbyNPC() {
  for (const n of npcs) {
    const dx = n.x - player.x, dy = n.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return n;
  }
  return null;
}

// ============================================================
// TRADE SYSTEM
// ============================================================
function openTrade(npc) {
  tradeOpen = true;
  tradeNPC = npc;
  document.exitPointerLock();
  const menu = document.getElementById('trade-menu');
  menu.style.display = 'block';
  renderTradeMenu();
}

function closeTrade() {
  tradeOpen = false;
  tradeNPC = null;
  document.getElementById('trade-menu').style.display = 'none';
  if (gameRunning) C.requestPointerLock();
}

function renderTradeMenu() {
  if (!tradeNPC) return;
  const nt = NPC_TYPES[tradeNPC.type];
  const el = document.getElementById('trade-list');
  let html = `<div style="color:#e8a030;font-size:16px;font-weight:700;text-align:center;margin-bottom:4px;">${nt.name} â€” ${tradeNPC.town}</div>`;
  html += `<div style="color:#888;font-size:11px;text-align:center;margin-bottom:12px;">Gold Coins: ${countItem('gold_coin')}</div>`;
  nt.trades.forEach((t, i) => {
    const giveStr = Object.entries(t.give).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    const getStr = Object.entries(t.get).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    let canTrade = true;
    for (const [id, n] of Object.entries(t.give)) { if (countItem(id) < n) canTrade = false; }
    html += `<div class="recipe-row">
      <span class="recipe-cost" style="color:#ff8888;">${giveStr}</span>
      <span style="color:#666;margin:0 8px;">â†’</span>
      <span class="recipe-cost" style="color:#88ff88;">${getStr}</span>
      <button class="recipe-craft ${canTrade ? '' : 'cannot'}" onclick="doTrade(${i})">${canTrade ? 'Trade' : 'Need'}</button>
    </div>`;
  });
  el.innerHTML = html;
}

function doTrade(idx) {
  if (!tradeNPC) return;
  const nt = NPC_TYPES[tradeNPC.type];
  const t = nt.trades[idx];
  for (const [id, n] of Object.entries(t.give)) { if (countItem(id) < n) return; }
  for (const [id, n] of Object.entries(t.give)) { removeItem(id, n); }
  for (const [id, n] of Object.entries(t.get)) { addItem(id, n); }
  notify('Traded!'); SFX.trade();
  renderTradeMenu();
}

// ============================================================
// SMELTING SYSTEM
// ============================================================
function openSmeltMenu() {
  smeltOpen = true;
  document.exitPointerLock();
  document.getElementById('smelt-menu').style.display = 'block';
  renderSmeltMenu();
}

function closeSmeltMenu() {
  smeltOpen = false;
  document.getElementById('smelt-menu').style.display = 'none';
  if (gameRunning) C.requestPointerLock();
}

function renderSmeltMenu() {
  const el = document.getElementById('smelt-list');
  let html = '';
  SMELT_RECIPES.forEach((r, i) => {
    const inputStr = Object.entries(r.input).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    const fuelStr = Object.entries(r.fuel).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    const resultStr = `${ITEMS[r.result].name} x${r.amt}`;
    let canSmelt = true;
    for (const [id, n] of Object.entries(r.input)) { if (countItem(id) < n) canSmelt = false; }
    for (const [id, n] of Object.entries(r.fuel)) { if (countItem(id) < n) canSmelt = false; }
    html += `<div class="recipe-row">
      <span class="recipe-name" style="color:#FF8800;">${r.name}</span>
      <span class="recipe-cost" style="color:#aaa;font-size:11px;">${inputStr} + ${fuelStr}</span>
      <span style="color:#666;margin:0 6px;">â†’</span>
      <span style="color:#88ff88;font-size:12px;min-width:80px;">${resultStr}</span>
      <button class="recipe-craft ${canSmelt ? '' : 'cannot'}" onclick="doSmelt(${i})">${canSmelt ? 'Smelt' : 'Need'}</button>
    </div>`;
  });
  el.innerHTML = html;
}

function doSmelt(idx) {
  const r = SMELT_RECIPES[idx];
  for (const [id, n] of Object.entries(r.input)) { if (countItem(id) < n) return; }
  for (const [id, n] of Object.entries(r.fuel)) { if (countItem(id) < n) return; }
  for (const [id, n] of Object.entries(r.input)) { removeItem(id, n); }
  for (const [id, n] of Object.entries(r.fuel)) { removeItem(id, n); }
  addItem(r.result, r.amt);
  notify('Smelted ' + ITEMS[r.result].name + (r.amt > 1 ? ' x' + r.amt : '') + '!');
  SFX.craft();
  renderSmeltMenu();
}

// ============================================================
// CREATURES
// ============================================================
function spawnCreatures() {
  creatures = [];
  setSeed(worldSeed + 500);
  let spawned = 0;
  const types = Object.keys(CREATURE_TYPES);
  let attempts = 0;
  while (spawned < MAX_CREATURES && attempts < 20000) {
    attempts++;
    const typeId = types[rngInt(0, types.length - 1)];
    const ct = CREATURE_TYPES[typeId];
    if (!ct) continue;
    const x = rngInt(3, MAP_SIZE - 4) + 0.5;
    const y = rngInt(3, MAP_SIZE - 4) + 0.5;
    // Skip town areas
    let inTown = false;
    for (const t of townPositions) { if (Math.abs(x - t.x) < 15 && Math.abs(y - t.y) < 15) { inTown = true; break; } }
    if (inTown) continue;
    const biome = getBiome(Math.floor(x), Math.floor(y));
    if (biome !== ct.biome) continue;
    const spawnBlock = getBlock(Math.floor(x), Math.floor(y));
    if (ct.aquatic) { if (spawnBlock !== T.WATER) continue; }
    else { if (spawnBlock !== T.AIR) continue; }
    creatures.push({
      type: typeId,
      x, y,
      hp: ct.hp,
      maxHp: ct.hp,
      angle: rng() * Math.PI * 2,
      state: 'idle', // idle, chase, flee, follow
      tamed: false,
      stateTimer: rng() * 3,
      knockback: 0,
      kbAngle: 0,
      attackTimer: 0,
      age: 120 + Math.random() * 60, // spawn as mature adults
      breedTimer: Math.random() * 120,
      attackAnim: 0,
      produceTimer: 0,
      penned: false,
    });
    spawned++;
  }
}

function updateCreatures(dt) {
  for (let i = creatures.length - 1; i >= 0; i--) {
    const c = creatures[i];
    if (c === player.riding) continue; // skip mounted horse AI
    const ct = CREATURE_TYPES[c.type];
    const dx = player.x - c.x;
    const dy = player.y - c.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angleToPlayer = Math.atan2(dy, dx);

    // Knockback
    if (c.knockback > 0) {
      const kbSpeed = c.knockback * 5 * dt;
      const nx = c.x + Math.cos(c.kbAngle) * kbSpeed;
      const ny = c.y + Math.sin(c.kbAngle) * kbSpeed;
      if (getBlock(Math.floor(nx), Math.floor(ny)) === T.AIR) {
        c.x = nx; c.y = ny;
      }
      c.knockback = Math.max(0, c.knockback - dt * 4);
    }

    c.attackTimer = Math.max(0, c.attackTimer - dt);
    if (c.attackAnim > 0) c.attackAnim = Math.max(0, c.attackAnim - dt);
    c.stateTimer -= dt;

    if (c.tamed) {
      // Produce timer tick
      if (c.produceTimer > 0) c.produceTimer -= dt;
      if (c.penned) {
        // Penned: wander near current position instead of following
        if (c.stateTimer <= 0) {
          c.angle += (Math.random() - 0.5) * 2;
          c.stateTimer = 1 + Math.random() * 3;
        }
        const wanderSpeed = ct.speed * 0.15;
        const wnx = c.x + Math.cos(c.angle) * wanderSpeed * dt;
        const wny = c.y + Math.sin(c.angle) * wanderSpeed * dt;
        const wb = getBlock(Math.floor(wnx), Math.floor(wny));
        if (wb === T.AIR) { c.x = wnx; c.y = wny; }
        else c.angle += Math.PI * 0.5;
      } else {
        // Follow player
        if (dist > 3) {
          c.x += Math.cos(angleToPlayer) * ct.speed * dt;
          c.y += Math.sin(angleToPlayer) * ct.speed * dt;
        }
      }
      c.angle = c.penned ? c.angle : angleToPlayer;
      // Attack nearby hostile creatures
      for (let j = 0; j < creatures.length; j++) {
        if (j === i) continue;
        const other = creatures[j];
        if (other.tamed || !CREATURE_TYPES[other.type].hostile) continue;
        const odx = other.x - c.x, ody = other.y - c.y;
        const odist = Math.sqrt(odx * odx + ody * ody);
        if (odist < 2 && c.attackTimer <= 0) {
          other.hp -= Math.floor(ct.dmg * 0.6) || 3;
          c.attackTimer = 1.0;
          if (other.hp <= 0) {
            const otherCt = CREATURE_TYPES[other.type];
            if (otherCt.drop) addItem(otherCt.drop, 1);
            if (otherCt.specialDrop) addItem(otherCt.specialDrop, 1);
            notify('Your ' + ct.name + ' killed a ' + otherCt.name + '!');
            creatures.splice(j, 1);
            if (j < i) i--;
          }
          break;
        }
      }
      continue;
    }

    // AI state machine (stealth in tree = invisible to hostiles)
    if (ct.hostile && dist < 8 && !player.treeStealth) {
      c.state = 'chase';
    } else if (!ct.hostile && dist < 4 && !player.treeStealth) {
      c.state = 'flee';
      c.stateTimer = 2;
    } else if (c.stateTimer <= 0) {
      c.state = 'idle';
      c.angle += (rng() - 0.5) * 2;
      c.stateTimer = 1 + rng() * 3;
    }

    let speed = 0;
    if (c.state === 'chase') {
      c.angle = angleToPlayer;
      speed = ct.speed;
      // Attack player
      if (dist < 1.5 && c.attackTimer <= 0) {
        player.hp -= ct.dmg;
        damageFlash = 0.3;
        damageDirection = angleToPlayer + Math.PI; // direction FROM the creature
        damageIndicatorTimer = 0.8;
        c.attackAnim = 0.4; // lunge animation timer
        SFX.hurt();
        c.attackTimer = 1.2;
        if (player.hp <= 0) playerDeath();
      }
    } else if (c.state === 'flee') {
      c.angle = angleToPlayer + Math.PI;
      speed = ct.speed;
    } else if (c.state === 'idle') {
      speed = ct.speed * 0.2;
    }

    if (speed > 0) {
      const nx = c.x + Math.cos(c.angle) * speed * dt;
      const ny = c.y + Math.sin(c.angle) * speed * dt;
      const bx = Math.floor(nx), by = Math.floor(ny);
      const moveBlock = (bx > 0 && bx < MAP_SIZE - 1 && by > 0 && by < MAP_SIZE - 1) ? getBlock(bx, by) : T.STONE;
      const canMove = ct.aquatic ? (moveBlock === T.WATER) : (moveBlock === T.AIR);
      if (canMove) {
        c.x = nx;
        c.y = ny;
      } else {
        c.angle += Math.PI * 0.5; // turn on wall hit
      }
    }
  }

  // Breeding logic
  if (creatures.length < MAX_CREATURES) {
    const babies = [];
    for (let i = 0; i < creatures.length; i++) {
      const c = creatures[i];
      c.age = (c.age || 0) + dt;
      if (c.breedTimer > 0) c.breedTimer -= dt;
      if (c.tamed || c.age < 120 || c.breedTimer > 0) continue;
      // 1% chance per second
      if (Math.random() > dt * 0.01) continue;
      // Count same-type nearby to cap at ~20
      let nearCount = 0;
      let mate = null;
      for (let j = 0; j < creatures.length; j++) {
        if (j === i) continue;
        const o = creatures[j];
        if (o.type !== c.type || o.tamed) continue;
        const odx = o.x - c.x, ody = o.y - c.y;
        const odist = Math.sqrt(odx * odx + ody * ody);
        if (odist < 30) nearCount++;
        if (odist < 8 && (o.age || 0) >= 120 && (o.breedTimer || 0) <= 0 && !mate) mate = o;
      }
      if (!mate || nearCount >= 20) continue;
      // Spawn baby nearby
      const bx = c.x + (Math.random() - 0.5) * 3;
      const by = c.y + (Math.random() - 0.5) * 3;
      if (getBlock(Math.floor(bx), Math.floor(by)) !== T.AIR) continue;
      const ct2 = CREATURE_TYPES[c.type];
      babies.push({
        type: c.type, x: bx, y: by,
        hp: ct2.hp, maxHp: ct2.hp,
        angle: Math.random() * Math.PI * 2, state: 'idle',
        tamed: false, stateTimer: Math.random() * 3,
        knockback: 0, kbAngle: 0, attackTimer: 0,
        age: 0, breedTimer: 120, attackAnim: 0,
        produceTimer: 0, penned: false,
      });
      c.breedTimer = 120;
      mate.breedTimer = 120;
    }
    for (const b of babies) {
      if (creatures.length < MAX_CREATURES) creatures.push(b);
    }
  }
}

// ---- TREE GROWTH ----
const BIOME_DEFAULT_TREE = {meadow:'oak', tundra:'pine', jungle:'jungle', desert:'palm'};
function updateTreeGrowth() {
  const px = Math.floor(player.x), py = Math.floor(player.y);
  const R = 60;
  const x0 = Math.max(1, px - R), x1 = Math.min(MAP_SIZE - 2, px + R);
  const y0 = Math.max(1, py - R), y1 = Math.min(MAP_SIZE - 2, py + R);
  for (let y = y0; y <= y1; y++) {
    for (let x = x0; x <= x1; x++) {
      const tile = getBlock(x, y);
      if (tile === T.SAPLING) {
        // 20% chance per tick (~2 min avg)
        if (Math.random() < 0.20) {
          setBlock(x, y, T.YOUNG_TREE);
        }
      } else if (tile === T.YOUNG_TREE) {
        // 10% chance per tick (~4 min avg)
        if (Math.random() < 0.10) {
          const key = x + ',' + y;
          let species = saplingData[key];
          if (!species) {
            const biome = getBiome(x, y);
            species = BIOME_DEFAULT_TREE[biome] || 'oak';
          }
          const matureMap = {oak: T.OAK, pine: T.PINE, jungle: T.JUNGLE_TREE, palm: T.PALM};
          setBlock(x, y, matureMap[species] || T.OAK);
          delete saplingData[key];
        }
      } else if (tile === T.OAK || tile === T.PINE || tile === T.JUNGLE_TREE || tile === T.PALM) {
        // Mature trees can spread: 2% chance to spawn sapling nearby
        if (Math.random() < 0.02) {
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          const d = dirs[Math.floor(Math.random() * 4)];
          const nx = x + d[0], ny = y + d[1];
          if (nx > 0 && nx < MAP_SIZE - 1 && ny > 0 && ny < MAP_SIZE - 1 && getBlock(nx, ny) === T.AIR) {
            setBlock(nx, ny, T.SAPLING);
            // Record species based on parent tree
            const speciesMap = {[T.OAK]:'oak', [T.PINE]:'pine', [T.JUNGLE_TREE]:'jungle', [T.PALM]:'palm'};
            saplingData[nx + ',' + ny] = speciesMap[tile] || 'oak';
          }
        }
      }
    }
  }
}

// ---- DAY/NIGHT HELPERS ----
function getDayNightFactor() {
  // 0 = full day, 1 = full night
  const t = dayTimer / DAY_LENGTH; // 0..1
  // 0-0.25: day, 0.25-0.35: dusk, 0.35-0.65: night, 0.65-0.75: dawn, 0.75-1.0: day
  if (t < 0.25) return 0;
  if (t < 0.35) return (t - 0.25) / 0.1; // dusk
  if (t < 0.65) return 1; // night
  if (t < 0.75) return 1 - (t - 0.65) / 0.1; // dawn
  return 0;
}

function lerpColor(hex1, hex2, t) {
  // hex strings like '#5588CC'
  const r1 = parseInt(hex1.slice(1,3),16), g1 = parseInt(hex1.slice(3,5),16), b1 = parseInt(hex1.slice(5,7),16);
  const r2 = parseInt(hex2.slice(1,3),16), g2 = parseInt(hex2.slice(3,5),16), b2 = parseInt(hex2.slice(5,7),16);
  const r = Math.floor(r1 + (r2 - r1) * t), g = Math.floor(g1 + (g2 - g1) * t), b = Math.floor(b1 + (b2 - b1) * t);
  return `rgb(${r},${g},${b})`;
}

// ============================================================
// RAYCASTING RENDERER
// ============================================================
let zBuffer = new Float64Array(W);

function handleResize() {
  W = window.innerWidth;
  H = window.innerHeight;
  C.width = W;
  C.height = H;
  zBuffer = new Float64Array(W);
}
window.addEventListener('resize', handleResize);

function castRay(px, py, angle) {
  const dirX = Math.cos(angle), dirY = Math.sin(angle);
  let mapX = Math.floor(px), mapY = Math.floor(py);
  const deltaDistX = Math.abs(1 / dirX), deltaDistY = Math.abs(1 / dirY);
  let stepX, stepY, sideDistX, sideDistY;

  if (dirX < 0) { stepX = -1; sideDistX = (px - mapX) * deltaDistX; }
  else { stepX = 1; sideDistX = (mapX + 1 - px) * deltaDistX; }
  if (dirY < 0) { stepY = -1; sideDistY = (py - mapY) * deltaDistY; }
  else { stepY = 1; sideDistY = (mapY + 1 - py) * deltaDistY; }

  let side = 0;
  for (let i = 0; i < 64; i++) {
    if (sideDistX < sideDistY) {
      sideDistX += deltaDistX;
      mapX += stepX;
      side = 0;
    } else {
      sideDistY += deltaDistY;
      mapY += stepY;
      side = 1;
    }
    const block = getBlock(mapX, mapY);
    if (block !== T.AIR) {
      let dist;
      if (side === 0) dist = sideDistX - deltaDistX;
      else dist = sideDistY - deltaDistY;
      // Calculate wall X (texture coordinate)
      let wallX;
      if (side === 0) wallX = py + dist * dirY;
      else wallX = px + dist * dirX;
      wallX -= Math.floor(wallX);
      return { dist, side, block, mapX, mapY, wallX };
    }
  }
  return { dist: 64, side: 0, block: T.AIR, mapX, mapY, wallX: 0 };
}

function renderScene() {
  const fov = Math.PI / 3; // 60 degrees
  const treeElevation = player.inTree ? 300 : 0;
  const halfH = H / 2 + player.pitch + treeElevation; // pitch shifts horizon
  const biome = getBiome(Math.floor(player.x), Math.floor(player.y));
  const bd = BIOMES[biome];

  // Day/night factor
  let nightF = getDayNightFactor(); // 0=day, 1=night
  // Underground: always dark
  if (player.level === 1) nightF = 0.8;
  const dayBright = 1.0 - nightF * 0.7; // walls get dimmer at night

  // Draw sky gradient (shifted by pitch) with day/night
  const horizonY = Math.floor(halfH);
  if (player.level === 1) {
    // Underground: solid dark cave ceiling and floor
    ctx.fillStyle = '#0a0808';
    ctx.fillRect(0, 0, W, Math.max(0, horizonY));
    ctx.fillStyle = '#1a1210';
    ctx.fillRect(0, Math.max(0, horizonY), W, H - Math.max(0, horizonY));
  } else {
    const skyGrad = ctx.createLinearGradient(0, Math.min(0, horizonY - H), 0, Math.max(0, horizonY));
    const nightSky1 = '#0a0a2a', nightSky2 = '#141440';
    skyGrad.addColorStop(0, lerpColor(bd.sky1, nightSky1, nightF));
    skyGrad.addColorStop(1, lerpColor(bd.sky2, nightSky2, nightF));
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, Math.max(0, horizonY));

    // Stars at night
    if (nightF > 0.3) {
      ctx.fillStyle = `rgba(255,255,255,${(nightF - 0.3) * 1.2})`;
      for (let i = 0; i < 60; i++) {
        const sx = ((i * 137 + 42) % W);
        const sy = ((i * 97 + 13) % Math.max(1, horizonY));
        ctx.fillRect(sx, sy, 1 + (i % 2), 1 + (i % 2));
      }
    }

    // Draw floor gradient (shifted by pitch) with day/night
    const gc = bd.ground;
    const gDim = dayBright;
    const flrGrad = ctx.createLinearGradient(0, Math.max(0, horizonY), 0, Math.max(horizonY, H + Math.abs(player.pitch)));
    flrGrad.addColorStop(0, `rgb(${Math.floor(gc[0]*gDim*0.5)},${Math.floor(gc[1]*gDim*0.5)},${Math.floor(gc[2]*gDim*0.5)})`);
    flrGrad.addColorStop(1, `rgb(${Math.floor(gc[0]*gDim)},${Math.floor(gc[1]*gDim)},${Math.floor(gc[2]*gDim)})`);
    ctx.fillStyle = flrGrad;
    ctx.fillRect(0, Math.max(0, horizonY), W, H - Math.max(0, horizonY));
  }

  // Raycast walls
  const imgData = ctx.getImageData(0, 0, W, H);
  const pixels = imgData.data;

  for (let col = 0; col < W; col++) {
    const rayAngle = player.angle + (col / W - 0.5) * fov;
    const hit = castRay(player.x, player.y, rayAngle);
    const perpDist = hit.dist * Math.cos(rayAngle - player.angle); // fisheye correction
    zBuffer[col] = perpDist;

    if (hit.block === T.AIR) continue;

    const fullLineHeight = Math.floor(H / perpDist);
    const wallH = (TILE_INFO[hit.block] && TILE_INFO[hit.block].wh) || 1.0;
    const lineHeight = Math.floor(fullLineHeight * wallH);
    // Bottom-aligned: floor stays fixed, top varies by height
    const drawEnd = Math.min(H - 1, Math.floor(halfH + fullLineHeight / 2));
    const drawStart = Math.max(0, drawEnd - lineHeight);

    const tex = textures[hit.block];
    const texX = Math.floor(hit.wallX * TEX_SIZE) & (TEX_SIZE - 1);
    const shade = hit.side ? 0.7 : 1.0;
    const distShade = Math.max(0.15, 1.0 - perpDist / 20);
    const finalShade = shade * distShade * dayBright;

    // Check for nearby torches for extra lighting
    let torchLight = 0;
    for (const tp of torchPositions) {
      const td = Math.sqrt((hit.mapX - tp[0]) ** 2 + (hit.mapY - tp[1]) ** 2);
      if (td < 6) torchLight = Math.max(torchLight, (1 - td / 6) * 0.5);
    }

    // Transparency for tree/torch/fence blocks â€” skip pure-black pixels
    const isTransparent = hit.block === T.OAK || hit.block === T.PINE || hit.block === T.JUNGLE_TREE ||
      hit.block === T.PALM || hit.block === T.YOUNG_TREE || hit.block === T.SAPLING ||
      hit.block === T.TORCH || hit.block === T.CAMPFIRE || hit.block === T.FENCE || hit.block === T.HOLE;

    for (let y = drawStart; y <= drawEnd; y++) {
      const texY = Math.floor((y - drawStart) / lineHeight * TEX_SIZE) & (TEX_SIZE - 1);
      const ti = (texY * TEX_SIZE + texX) * 3;
      const pi = (y * W + col) * 4;
      const s = Math.min(1, finalShade + torchLight);

      if (tex) {
        // Skip transparent (pure black) pixels on tree-type blocks
        if (isTransparent && tex[ti] === 0 && tex[ti + 1] === 0 && tex[ti + 2] === 0) continue;
        pixels[pi] = Math.floor(tex[ti] * s);
        pixels[pi + 1] = Math.floor(tex[ti + 1] * s);
        pixels[pi + 2] = Math.floor(tex[ti + 2] * s);
      } else {
        const info = TILE_INFO[hit.block];
        const c = info ? info.color : [128, 128, 128];
        pixels[pi] = Math.floor(c[0] * s);
        pixels[pi + 1] = Math.floor(c[1] * s);
        pixels[pi + 2] = Math.floor(c[2] * s);
      }
      pixels[pi + 3] = 255;
    }
  }

  ctx.putImageData(imgData, 0, 0);
}

// ============================================================
// BILLBOARD SPRITE RENDERING (creatures)
// ============================================================
function renderCreatures() {
  // Sort by distance (far first)
  const spriteList = creatures.map(c => {
    const dx = c.x - player.x, dy = c.y - player.y;
    return { creature: c, dist: Math.sqrt(dx * dx + dy * dy), dx, dy };
  }).sort((a, b) => b.dist - a.dist);

  const fov = Math.PI / 3;
  const treeElev = player.inTree ? 300 : 0;
  const halfH = H / 2 + player.pitch + treeElev;

  for (const s of spriteList) {
    const { creature: c, dist, dx, dy } = s;
    if (c === player.riding) continue; // hide mounted horse
    if (dist < 0.3 || dist > 30) continue;

    const ct = CREATURE_TYPES[c.type];

    // Angle relative to player view
    const spriteAngle = Math.atan2(dy, dx) - player.angle;
    // Normalize to -PI..PI
    let normAngle = spriteAngle;
    while (normAngle > Math.PI) normAngle -= Math.PI * 2;
    while (normAngle < -Math.PI) normAngle += Math.PI * 2;

    // Skip if behind
    if (Math.abs(normAngle) > fov * 0.7) continue;

    const screenX = Math.floor(W / 2 + (normAngle / fov) * W);
    // Attack lunge: creature grows larger + shifts toward player
    const lungeScale = c.attackAnim > 0 ? 1.0 + c.attackAnim * 1.5 : 1.0;
    const spriteHeight = Math.floor((H / dist) * ct.size * lungeScale);
    const spriteWidth = Math.floor(spriteHeight * 0.8);
    const drawY = Math.floor(halfH - spriteHeight / 2 + (1 - ct.size) * (H / dist) * 0.3);

    const startX = Math.max(0, screenX - spriteWidth / 2);
    const endX = Math.min(W - 1, screenX + spriteWidth / 2);

    // Z-buffer check per column
    let visible = false;
    for (let x = Math.floor(startX); x <= Math.floor(endX); x++) {
      if (x >= 0 && x < W && dist < zBuffer[x]) { visible = true; break; }
    }
    if (!visible) continue;

    // Parse color (red tint during attack animation)
    const col = ct.color;
    const isAttacking = c.attackAnim > 0;
    const atkTint = isAttacking ? c.attackAnim * 2.5 : 0; // 0-1 red tint
    let r = parseInt(col.slice(1, 3), 16);
    let g = parseInt(col.slice(3, 5), 16);
    let b = parseInt(col.slice(5, 7), 16);
    if (isAttacking) {
      r = Math.min(255, r + Math.floor(atkTint * (255 - r)));
      g = Math.floor(g * (1 - atkTint * 0.7));
      b = Math.floor(b * (1 - atkTint * 0.7));
    }

    const distShade = Math.max(0.2, 1.0 - dist / 20);

    // Draw sprite as filled rectangle with detail
    ctx.save();
    for (let x = Math.floor(startX); x <= Math.floor(endX); x++) {
      if (x < 0 || x >= W || dist >= zBuffer[x]) continue;
      const relX = (x - (screenX - spriteWidth / 2)) / spriteWidth;

      // Body shape: narrower at top and bottom
      const bodyTop = drawY + spriteHeight * 0.1;
      const bodyBot = drawY + spriteHeight;
      const headTop = drawY;
      const headBot = drawY + spriteHeight * 0.25;
      const headWidth = 0.4;

      // Head
      if (Math.abs(relX - 0.5) < headWidth / 2) {
        const ht = Math.floor(headTop);
        const hb = Math.floor(headBot);
        for (let y = Math.max(0, ht); y < Math.min(H, hb); y++) {
          if (y >= 0 && y < H) {
            ctx.fillStyle = `rgb(${Math.floor(r * distShade * 1.1)},${Math.floor(g * distShade * 1.1)},${Math.floor(b * distShade * 1.1)})`;
            ctx.fillRect(x, y, 1, 1);
          }
        }
        // Eyes
        if (spriteHeight > 20) {
          const eyeY = Math.floor(headTop + (headBot - headTop) * 0.4);
          if (Math.abs(relX - 0.4) < 0.05 || Math.abs(relX - 0.6) < 0.05) {
            ctx.fillStyle = '#000';
            ctx.fillRect(x, eyeY, 1, Math.max(1, spriteHeight * 0.05));
          }
        }
      }

      // Body
      const bodyNarrow = Math.abs(relX - 0.5) < 0.35 ? 1 : 0;
      if (bodyNarrow) {
        const bt = Math.floor(headBot);
        const bb = Math.floor(bodyBot);
        for (let y = Math.max(0, bt); y < Math.min(H, bb); y++) {
          const shade = 0.8 + 0.2 * ((y - bt) / (bb - bt));
          ctx.fillStyle = `rgb(${Math.floor(r * distShade * shade)},${Math.floor(g * distShade * shade)},${Math.floor(b * distShade * shade)})`;
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }

    // Draw HP bar if damaged
    if (c.hp < c.maxHp) {
      const barW = spriteWidth;
      const barH = 3;
      const barX = screenX - barW / 2;
      const barY = drawY - 6;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = c.tamed ? '#44FF44' : '#FF4444';
      ctx.fillRect(barX, barY, barW * (c.hp / c.maxHp), barH);
    }

    // Tamed indicator
    if (c.tamed) {
      ctx.fillStyle = '#44FF44';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(ct.name, screenX, drawY - 10);
    }

    ctx.restore();
  }
}

// ============================================================
// NPC BILLBOARD RENDERING
// ============================================================
function renderNPCs() {
  const fov = Math.PI / 3;
  const treeElevNPC = player.inTree ? 300 : 0;
  const halfH = H / 2 + player.pitch + treeElevNPC;
  for (const n of npcs) {
    const dx = n.x - player.x, dy = n.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 0.3 || dist > 30) continue;
    const nt = NPC_TYPES[n.type];
    let normAngle = Math.atan2(dy, dx) - player.angle;
    while (normAngle > Math.PI) normAngle -= Math.PI * 2;
    while (normAngle < -Math.PI) normAngle += Math.PI * 2;
    if (Math.abs(normAngle) > fov * 0.7) continue;
    const screenX = Math.floor(W / 2 + (normAngle / fov) * W);
    const spriteHeight = Math.floor((H / dist) * nt.size);
    const spriteWidth = Math.floor(spriteHeight * 0.6);
    const drawY = Math.floor(halfH - spriteHeight / 2 + (1 - nt.size) * (H / dist) * 0.3);
    const distShade = Math.max(0.2, 1.0 - dist / 20);
    const col = nt.color;
    const r = parseInt(col.slice(1, 3), 16);
    const g = parseInt(col.slice(3, 5), 16);
    const b = parseInt(col.slice(5, 7), 16);
    // Check z-buffer
    let visible = false;
    for (let x = Math.max(0, screenX - spriteWidth / 2); x <= Math.min(W - 1, screenX + spriteWidth / 2); x++) {
      if (dist < zBuffer[Math.floor(x)]) { visible = true; break; }
    }
    if (!visible) continue;
    // Draw body
    ctx.fillStyle = `rgb(${Math.floor(r * distShade)},${Math.floor(g * distShade)},${Math.floor(b * distShade)})`;
    const bodyX = screenX - spriteWidth / 2;
    ctx.fillRect(bodyX, drawY + spriteHeight * 0.25, spriteWidth, spriteHeight * 0.75);
    // Head
    ctx.fillStyle = `rgb(${Math.floor(0xDD * distShade)},${Math.floor(0xBB * distShade)},${Math.floor(0x99 * distShade)})`;
    ctx.beginPath();
    ctx.arc(screenX, drawY + spriteHeight * 0.15, spriteWidth * 0.35, 0, Math.PI * 2);
    ctx.fill();
    // Name label
    ctx.fillStyle = '#FFDD44';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(nt.name, screenX, drawY - 6);
    // E prompt if close
    if (dist < 3) {
      ctx.fillStyle = '#44FF44';
      ctx.font = 'bold 12px sans-serif';
      ctx.fillText('[E] Trade', screenX, drawY - 18);
    }
  }
}

// ============================================================
// HUD RENDERING
// ============================================================
function renderHUD() {
  // Directional damage indicator (red wedge showing where hit came from)
  if (damageIndicatorTimer > 0) {
    const alpha = Math.min(0.8, damageIndicatorTimer);
    const indicatorAngle = damageDirection - player.angle;
    const cx2 = W / 2, cy2 = H / 2;
    const indicatorDist = 100;
    const ix = cx2 + Math.cos(indicatorAngle) * indicatorDist;
    const iy = cy2 + Math.sin(indicatorAngle) * indicatorDist;

    // Draw red damage wedge
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#FF0000';
    ctx.beginPath();
    ctx.moveTo(ix + Math.cos(indicatorAngle) * 40, iy + Math.sin(indicatorAngle) * 40);
    ctx.lineTo(ix + Math.cos(indicatorAngle + 0.5) * 15, iy + Math.sin(indicatorAngle + 0.5) * 15);
    ctx.lineTo(ix + Math.cos(indicatorAngle - 0.5) * 15, iy + Math.sin(indicatorAngle - 0.5) * 15);
    ctx.closePath();
    ctx.fill();

    // Red edge glow on screen border in damage direction
    const edgeGrad = ctx.createRadialGradient(ix, iy, 0, ix, iy, 200);
    edgeGrad.addColorStop(0, `rgba(255,0,0,${alpha * 0.5})`);
    edgeGrad.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  // Crosshair
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 10, H / 2); ctx.lineTo(W / 2 - 4, H / 2);
  ctx.moveTo(W / 2 + 4, H / 2); ctx.lineTo(W / 2 + 10, H / 2);
  ctx.moveTo(W / 2, H / 2 - 10); ctx.lineTo(W / 2, H / 2 - 4);
  ctx.moveTo(W / 2, H / 2 + 4); ctx.lineTo(W / 2, H / 2 + 10);
  ctx.stroke();

  // Hotbar
  const slotSize = 48;
  const hotbarW = slotSize * 8 + 16;
  const hotbarX = (W - hotbarW) / 2;
  const hotbarY = H - slotSize - 12;

  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(hotbarX - 4, hotbarY - 4, hotbarW + 8, slotSize + 8);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;

  for (let i = 0; i < 8; i++) {
    const sx = hotbarX + i * (slotSize + 2);
    // Slot background
    ctx.fillStyle = i === player.selectedSlot ? 'rgba(232,160,48,0.3)' : 'rgba(30,30,50,0.8)';
    ctx.fillRect(sx, hotbarY, slotSize, slotSize);
    ctx.strokeStyle = i === player.selectedSlot ? '#e8a030' : '#444';
    ctx.lineWidth = i === player.selectedSlot ? 2 : 1;
    ctx.strokeRect(sx, hotbarY, slotSize, slotSize);

    const slot = player.hotbar[i];
    if (slot) {
      const item = ITEMS[slot.id];
      // Item color block
      ctx.fillStyle = item.color;
      ctx.fillRect(sx + 8, hotbarY + 6, slotSize - 16, slotSize - 20);

      // Item count
      if (slot.count > 1) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(slot.count, sx + slotSize - 4, hotbarY + slotSize - 4);
      }

      // Item name (small)
      ctx.fillStyle = '#ccc';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(item.name, sx + slotSize / 2, hotbarY + slotSize - 2);
    }

    // Slot number
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(i + 1, sx + 3, hotbarY + 11);
  }

  // HP bar
  const barW = 180, barH = 14;
  const hpX = 12, hpY = 12;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(hpX - 2, hpY - 2, barW + 4, barH + 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(hpX, hpY, barW, barH);
  const hpPct = Math.max(0, player.hp / player.maxHp);
  ctx.fillStyle = hpPct > 0.3 ? '#44CC44' : '#FF4444';
  ctx.fillRect(hpX, hpY, barW * hpPct, barH);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`HP ${Math.ceil(player.hp)}/${player.maxHp}`, hpX + barW / 2, hpY + 11);

  // Hunger bar
  const hunY = hpY + barH + 6;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(hpX - 2, hunY - 2, barW + 4, barH + 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(hpX, hunY, barW, barH);
  const hunPct = Math.max(0, player.hunger / player.maxHunger);
  ctx.fillStyle = hunPct > 0.3 ? '#CC8822' : '#FF4444';
  ctx.fillRect(hpX, hunY, barW * hunPct, barH);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Hunger ${Math.ceil(player.hunger)}/${player.maxHunger}`, hpX + barW / 2, hunY + 11);

  // Swim stamina bar (only in water)
  const inWaterHud = getBlock(Math.floor(player.x), Math.floor(player.y)) === T.WATER;
  const heldBoatHud = getHeldItem();
  const hasBoatHud = heldBoatHud && heldBoatHud.tool === 'boat';
  if (inWaterHud && !hasBoatHud) {
    const swimY = hunY + barH + 6;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(hpX - 2, swimY - 2, barW + 4, barH + 4);
    ctx.fillStyle = '#333';
    ctx.fillRect(hpX, swimY, barW, barH);
    const swimPct = Math.max(0, player.swimStamina / player.maxSwimStamina);
    ctx.fillStyle = swimPct > 0.2 ? '#2288DD' : '#FF2222';
    ctx.fillRect(hpX, swimY, barW * swimPct, barH);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    const swimLabel = player.swimStamina <= 10 ? 'DROWNING!' : `Swim ${Math.ceil(player.swimStamina)}/${player.maxSwimStamina}`;
    ctx.fillText(swimLabel, hpX + barW / 2, swimY + 11);
  }

  // XP bar
  const xpY = hunY + barH + (inWaterHud && !hasBoatHud ? barH + 12 : 6);
  const xpBarH = 10;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(hpX - 2, xpY - 2, barW + 4, xpBarH + 4);
  ctx.fillStyle = '#222';
  ctx.fillRect(hpX, xpY, barW, xpBarH);
  const xpNeeded = xpToLevel(playerLevel);
  const xpPct = Math.min(1, playerXP / xpNeeded);
  ctx.fillStyle = '#8844DD';
  ctx.fillRect(hpX, xpY, barW * xpPct, xpBarH);
  ctx.fillStyle = '#ddd';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Lv ${playerLevel}  XP ${playerXP}/${xpNeeded}`, hpX + barW / 2, xpY + 8);

  // Compass (top-center strip)
  const compassW = 200, compassH = 22;
  const compassX = (W - compassW) / 2, compassY = 6;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(compassX, compassY, compassW, compassH);
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  ctx.strokeRect(compassX, compassY, compassW, compassH);
  // Cardinal directions
  const dirs = [{label:'N',angle:-Math.PI/2},{label:'NE',angle:-Math.PI/4},{label:'E',angle:0},{label:'SE',angle:Math.PI/4},
    {label:'S',angle:Math.PI/2},{label:'SW',angle:Math.PI*3/4},{label:'W',angle:Math.PI},{label:'NW',angle:-Math.PI*3/4}];
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  for (const d of dirs) {
    let diff = d.angle - player.angle;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    if (Math.abs(diff) > Math.PI / 2) continue;
    const px = compassX + compassW / 2 + (diff / (Math.PI / 2)) * (compassW / 2);
    ctx.fillStyle = d.label === 'N' ? '#FF4444' : d.label.length === 1 ? '#FFD700' : '#888';
    ctx.fillText(d.label, px, compassY + 15);
  }
  // Center tick
  ctx.strokeStyle = '#e8a030';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(W / 2, compassY + compassH - 2);
  ctx.lineTo(W / 2, compassY + compassH + 2);
  ctx.stroke();

  // Day/night indicator (next to season box)
  const nightF2 = getDayNightFactor();
  const dayIcon = nightF2 > 0.5 ? 'ðŸŒ™' : 'â˜€ï¸';
  const dayLabel = nightF2 > 0.5 ? 'Night' : 'Day';

  // Biome indicator
  const biome = getBiome(Math.floor(player.x), Math.floor(player.y));
  ctx.fillStyle = '#aaa';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(BIOMES[biome].name, W - 12, 24);

  // Season & Temperature HUD box (top-right corner)
  const seasonBox = SEASONS[currentSeason];
  const tempBoxW = 180, tempBoxH = 60;
  const tbx = W - tempBoxW - 12, tby = 34;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(tbx, tby, tempBoxW, tempBoxH);
  ctx.strokeStyle = seasonBox.color;
  ctx.lineWidth = 1;
  ctx.strokeRect(tbx, tby, tempBoxW, tempBoxH);
  ctx.fillStyle = seasonBox.color;
  ctx.font = 'bold 13px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(seasonBox.icon + ' ' + seasonBox.name, tbx + 8, tby + 18);
  const tempColor = playerTemp < FREEZE_TEMP ? '#6688FF' : playerTemp > HEAT_TEMP ? '#FF4444' : '#CCCCCC';
  ctx.fillStyle = tempColor;
  ctx.font = '12px sans-serif';
  ctx.fillText(Math.round(playerTemp) + 'Â°F', tbx + 100, tby + 18);
  // Season progress bar
  ctx.fillStyle = '#333';
  ctx.fillRect(tbx + 8, tby + 28, tempBoxW - 16, 6);
  ctx.fillStyle = seasonBox.color;
  ctx.fillRect(tbx + 8, tby + 28, (tempBoxW - 16) * (seasonTimer / SEASON_DURATION), 6);
  // Day/night in season box
  ctx.fillStyle = nightF2 > 0.5 ? '#8888CC' : '#FFDD44';
  ctx.font = '11px sans-serif';
  ctx.fillText(dayIcon + ' ' + dayLabel, tbx + 8, tby + 42);
  // Warmth warnings
  if (playerTemp < FREEZE_TEMP) {
    ctx.fillStyle = '#6688FF';
    ctx.font = 'bold 10px sans-serif';
    ctx.fillText('FREEZING!', tbx + 80, tby + 42);
  } else if (playerTemp > HEAT_TEMP) {
    ctx.fillStyle = '#FF4444';
    ctx.font = 'bold 10px sans-serif';
    ctx.fillText('OVERHEATING!', tbx + 80, tby + 42);
  }

  // Potion effect indicators
  if (speedBoostTimer > 0) {
    ctx.fillStyle = '#44AAFF';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('SPEED ' + Math.ceil(speedBoostTimer) + 's', 12, hunY + barH + (player.sprinting ? 34 : 18));
  }
  if (strengthBoostTimer > 0) {
    ctx.fillStyle = '#FF8800';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'left';
    const yOff = hunY + barH + (player.sprinting ? 34 : 18) + (speedBoostTimer > 0 ? 16 : 0);
    ctx.fillText('STRENGTH ' + Math.ceil(strengthBoostTimer) + 's', 12, yOff);
  }

  // Town name if nearby
  for (const t of townPositions) {
    if (Math.abs(player.x - t.x) < 15 && Math.abs(player.y - t.y) < 15) {
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(t.name, W / 2, 24);
      break;
    }
  }

  // Build mode indicator
  if (buildMode) {
    ctx.fillStyle = 'rgba(232,160,48,0.8)';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('BUILD MODE [B] â€” Right-click to place', 12, H - 80);
    const held2 = getHeldItem();
    if (held2 && held2.placeTile) {
      ctx.fillStyle = '#ccc';
      ctx.font = '11px sans-serif';
      ctx.fillText('Placing: ' + held2.name, 12, H - 65);
    }
  }

  // Near campfire hint
  if (isNearCampfire() && (getHeldItemId() === 'raw_meat' || getHeldItemId() === 'raw_fish')) {
    ctx.fillStyle = '#FFA500';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Right-click to cook meat', W / 2, H / 2 + 50);
  }

  // Sprint indicator
  if (player.sprinting) {
    ctx.fillStyle = '#44FF44';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('SPRINTING', 12, hunY + barH + 18);
  }

  // Mounted indicator
  if (player.riding) {
    ctx.fillStyle = '#CC8844';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('MOUNTED [R] dismount', 12, hunY + barH + (player.sprinting ? 50 : 34));
  }

  // Tree climbing indicator
  if (player.inTree) {
    ctx.fillStyle = '#88CC44';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('IN TREE [Space] down [S] stealth', 12, hunY + barH + (player.sprinting ? 50 : 34));
    if (player.treeStealth) {
      ctx.fillStyle = '#44FF88';
      ctx.font = 'bold 14px sans-serif';
      ctx.fillText('HIDDEN', 12, hunY + barH + (player.sprinting ? 66 : 50));
    }
  }

  // Underground indicator
  if (player.level === 1) {
    ctx.fillStyle = '#AA8855';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('UNDERGROUND', W / 2, 50);
  }

  // Sailing indicator
  const onBlockHud = getBlock(Math.floor(player.x), Math.floor(player.y));
  const heldHud = getHeldItem();
  if (onBlockHud === T.WATER && heldHud && heldHud.tool === 'boat') {
    ctx.fillStyle = '#44CCFF';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('SAILING', 12, hunY + barH + (player.sprinting ? 34 : 18));
  }

  // Currently held item info + placement hint
  const held = getHeldItem();
  if (held) {
    ctx.fillStyle = '#ddd';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(held.name, W / 2, hotbarY - 8);
    if (held.placeTile || held.seedSpecies) {
      ctx.fillStyle = 'rgba(200,200,200,0.6)';
      ctx.font = '10px sans-serif';
      ctx.fillText('Right-click to place', W / 2, hotbarY - 20);
    }
  }

  // Mining progress
  if (player.miningTarget) {
    const progW = 100, progH = 8;
    const progX = W / 2 - progW / 2, progY = H / 2 + 30;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(progX - 1, progY - 1, progW + 2, progH + 2);
    ctx.fillStyle = '#333';
    ctx.fillRect(progX, progY, progW, progH);
    ctx.fillStyle = '#e8a030';
    ctx.fillRect(progX, progY, progW * player.miningProgress, progH);
  }

  // Notifications
  for (let i = 0; i < notifications.length; i++) {
    const n = notifications[i];
    const alpha = Math.min(1, n.time);
    ctx.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(n.msg, W / 2, H / 2 - 60 - i * 18);
  }

  // Minimap
  if (minimapSize > 0) {
    renderMinimap();
  }
}

function renderMinimap() {
  const size = minimapSize === 1 ? 120 : 200;
  const viewRadius = minimapSize === 1 ? 60 : 120; // tiles visible on minimap
  const mx = W - size - 10, my = 40;
  const scale = size / (viewRadius * 2);
  const startX = Math.floor(player.x - viewRadius);
  const startY = Math.floor(player.y - viewRadius);

  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(mx - 2, my - 2, size + 4, size + 4);

  // Draw local area around player (not entire map)
  const step = Math.max(1, Math.floor(1 / scale));
  for (let ty = 0; ty < viewRadius * 2; ty += step) {
    for (let tx = 0; tx < viewRadius * 2; tx += step) {
      const wx = startX + tx, wy = startY + ty;
      if (wx < 0 || wx >= MAP_SIZE || wy < 0 || wy >= MAP_SIZE) continue;
      const block = getBlock(wx, wy);
      if (block === T.AIR) {
        const b = getBiome(wx, wy);
        const gc = BIOMES[b].ground;
        ctx.fillStyle = `rgb(${gc[0] >> 1},${gc[1] >> 1},${gc[2] >> 1})`;
      } else {
        const info = TILE_INFO[block];
        if (info) {
          ctx.fillStyle = `rgb(${info.color[0]},${info.color[1]},${info.color[2]})`;
        } else {
          ctx.fillStyle = '#888';
        }
      }
      ctx.fillRect(mx + tx * scale, my + ty * scale, Math.ceil(scale * step), Math.ceil(scale * step));
    }
  }

  // Nearby creatures
  for (const c of creatures) {
    const rx = c.x - startX, ry = c.y - startY;
    if (rx < 0 || rx >= viewRadius * 2 || ry < 0 || ry >= viewRadius * 2) continue;
    ctx.fillStyle = c.tamed ? '#44FF44' : (CREATURE_TYPES[c.type].hostile ? '#FF4444' : '#FFFF44');
    ctx.fillRect(mx + rx * scale - 1, my + ry * scale - 1, 2, 2);
  }

  // Nearby NPCs
  for (const n of npcs) {
    const rx = n.x - startX, ry = n.y - startY;
    if (rx < 0 || rx >= viewRadius * 2 || ry < 0 || ry >= viewRadius * 2) continue;
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(mx + rx * scale - 1, my + ry * scale - 1, 3, 3);
  }

  // Town markers
  for (const t of townPositions) {
    const rx = t.x - startX, ry = t.y - startY;
    if (rx < -10 || rx >= viewRadius * 2 + 10 || ry < -10 || ry >= viewRadius * 2 + 10) continue;
    ctx.fillStyle = '#FFD700';
    ctx.font = '8px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(t.name, mx + rx * scale, my + ry * scale - 4);
  }

  // Player (always center)
  ctx.fillStyle = '#00FFFF';
  ctx.fillRect(mx + size / 2 - 2, my + size / 2 - 2, 4, 4);

  // Player direction line
  ctx.strokeStyle = '#00FFFF';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(mx + size / 2, my + size / 2);
  ctx.lineTo(mx + size / 2 + Math.cos(player.angle) * 12,
             my + size / 2 + Math.sin(player.angle) * 12);
  ctx.stroke();

  // Coordinates
  ctx.fillStyle = '#888';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'right';
  const levelLabel = player.level === 1 ? ' [UNDERGROUND]' : '';
  ctx.fillText(`${Math.floor(player.x)}, ${Math.floor(player.y)}${levelLabel}`, mx + size, my + size + 12);

  // Border
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx - 2, my - 2, size + 4, size + 4);
}

// ============================================================
// BUILD MENU
// ============================================================
const BUILD_ITEMS = [
  {id:'wood_wall',name:'Wood Wall',cost:'Wood x2 â†’ 4'},
  {id:'stone_wall',name:'Stone Wall',cost:'Stone x2 â†’ 4'},
  {id:'fence',name:'Fence',cost:'Wood x3 â†’ 4'},
  {id:'door',name:'Door',cost:'Wood x4'},
  {id:'torch',name:'Torch',cost:'Wood x1, Berries x1 â†’ 4'},
  {id:'well',name:'Well',cost:'Stone x8, Iron x2'},
  {id:'campfire_item',name:'Campfire',cost:'Wood x5, Stone x3'},
  {id:'chest_item',name:'Chest',cost:'Wood x8, Iron x2'},
  {id:'glass',name:'Glass',cost:'Sand x4, Crystal x1 â†’ 2'},
  {id:'furnace_item',name:'Furnace',cost:'Stone x10, Iron x5'},
];

function toggleBuildMenu() {
  buildMenuOpen = !buildMenuOpen;
  if (buildMenuOpen) {
    buildMode = true;
    document.exitPointerLock();
  } else {
    buildMode = false;
    if (gameRunning) C.requestPointerLock();
  }
}

function selectBuildItem(idx) {
  if (idx < 0 || idx >= BUILD_ITEMS.length) return;
  const bi = BUILD_ITEMS[idx];
  // Find matching recipe and craft it
  const recipe = RECIPES.find(r => r.result === bi.id);
  if (recipe && canCraft(recipe)) {
    for (const [itemId, need] of Object.entries(recipe.cost)) removeItem(itemId, need);
    const added = addItem(recipe.result, recipe.amt);
    if (added > 0) { notify('Built ' + ITEMS[recipe.result].name + (recipe.amt > 1 ? ' x' + recipe.amt : '')); SFX.build(); }
  } else {
    notify('Not enough materials!');
  }
  toggleBuildMenu();
}

function renderBuildMenu() {
  if (!buildMenuOpen) return;
  const menuW = 340, menuH = BUILD_ITEMS.length * 28 + 60;
  const mx = W / 2 - menuW / 2, my = H / 2 - menuH / 2;
  ctx.fillStyle = 'rgba(15,15,30,0.95)';
  ctx.fillRect(mx, my, menuW, menuH);
  ctx.strokeStyle = '#e8a030';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx, my, menuW, menuH);
  ctx.fillStyle = '#e8a030';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('BUILD MENU [B]', W / 2, my + 22);
  ctx.font = '13px sans-serif';
  for (let i = 0; i < BUILD_ITEMS.length; i++) {
    const bi = BUILD_ITEMS[i];
    const recipe = RECIPES.find(r => r.result === bi.id);
    const can = recipe && canCraft(recipe);
    const y = my + 44 + i * 28;
    ctx.fillStyle = can ? '#ddd' : '#666';
    ctx.textAlign = 'left';
    ctx.fillText((i + 1) + '. ' + bi.name, mx + 14, y + 2);
    ctx.fillStyle = can ? '#888' : '#444';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(bi.cost, mx + menuW - 14, y + 2);
    ctx.font = '13px sans-serif';
  }
  ctx.fillStyle = '#666';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Type 1-9 to build, B/Esc to close', W / 2, my + menuH - 10);
}

// ============================================================
// FULLSCREEN MAP
// ============================================================
function toggleFullscreenMap() {
  fullscreenMapOpen = !fullscreenMapOpen;
  if (fullscreenMapOpen) {
    document.exitPointerLock();
  } else {
    if (gameRunning) C.requestPointerLock();
  }
}

function renderFullscreenMap() {
  if (!fullscreenMapOpen) return;
  const pad = 40;
  const mapSize = Math.min(W, H) - pad * 2;
  const mx = (W - mapSize) / 2, my = (H - mapSize) / 2;

  // Background
  ctx.fillStyle = 'rgba(0,0,0,0.9)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(15,15,30,0.95)';
  ctx.fillRect(mx - 4, my - 4, mapSize + 8, mapSize + 8);
  ctx.strokeStyle = '#e8a030';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx - 4, my - 4, mapSize + 8, mapSize + 8);

  const scale = mapSize / MAP_SIZE;
  const step = Math.max(1, Math.floor(4 / scale));

  // Draw terrain
  for (let ty = 0; ty < MAP_SIZE; ty += step) {
    for (let tx = 0; tx < MAP_SIZE; tx += step) {
      const block = getBlock(tx, ty);
      if (block === T.AIR) {
        const b = getBiome(tx, ty);
        const gc = BIOMES[b].ground;
        ctx.fillStyle = `rgb(${gc[0]>>1},${gc[1]>>1},${gc[2]>>1})`;
      } else {
        const info = TILE_INFO[block];
        if (info) ctx.fillStyle = `rgb(${info.color[0]},${info.color[1]},${info.color[2]})`;
        else ctx.fillStyle = '#888';
      }
      const px = mx + tx * scale, py = my + ty * scale;
      const sz = Math.max(1, Math.ceil(scale * step));
      ctx.fillRect(px, py, sz, sz);
    }
  }

  // Town markers
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  for (const t of townPositions) {
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(mx + t.x * scale - 3, my + t.y * scale - 3, 6, 6);
    ctx.fillText(t.name, mx + t.x * scale, my + t.y * scale - 8);
  }

  // Player
  ctx.fillStyle = '#00FFFF';
  ctx.fillRect(mx + player.x * scale - 4, my + player.y * scale - 4, 8, 8);
  ctx.strokeStyle = '#00FFFF';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mx + player.x * scale, my + player.y * scale);
  ctx.lineTo(mx + player.x * scale + Math.cos(player.angle) * 20,
             my + player.y * scale + Math.sin(player.angle) * 20);
  ctx.stroke();

  // Creatures
  for (const c of creatures) {
    ctx.fillStyle = c.tamed ? '#44FF44' : (CREATURE_TYPES[c.type].hostile ? '#FF4444' : '#FFFF44');
    ctx.fillRect(mx + c.x * scale - 1, my + c.y * scale - 1, 3, 3);
  }

  // Header
  ctx.fillStyle = '#e8a030';
  ctx.font = 'bold 18px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('WORLD MAP', W / 2, my - 14);
  ctx.fillStyle = '#888';
  ctx.font = '12px sans-serif';
  ctx.fillText(`Position: ${Math.floor(player.x)}, ${Math.floor(player.y)} â€” Press M or Esc to close`, W / 2, my + mapSize + 22);
}

// ============================================================
// SEASON & TEMPERATURE
// ============================================================
function getPlayerTemp() {
  const biome = getBiome(Math.floor(player.x), Math.floor(player.y));
  const bd = BIOMES[biome];
  let temp = bd.baseTemp + SEASONS[currentSeason].tempMod;

  // Fur coat warmth
  let hasFurCoat = false;
  for (let i = 0; i < 8; i++) {
    if (player.hotbar[i] && player.hotbar[i].id === 'fur_coat') hasFurCoat = true;
  }
  for (let i = 0; i < BACKPACK_SIZE; i++) {
    if (player.backpack[i] && player.backpack[i].id === 'fur_coat') hasFurCoat = true;
  }
  if (hasFurCoat) temp += 30;

  // Near campfire or torch = warmth
  const px = Math.floor(player.x), py = Math.floor(player.y);
  for (let dy2 = -3; dy2 <= 3; dy2++) {
    for (let dx2 = -3; dx2 <= 3; dx2++) {
      const blk = getBlock(px + dx2, py + dy2);
      if (blk === T.CAMPFIRE) temp += 20;
      else if (blk === T.TORCH) temp += 8;
    }
  }

  return temp;
}

function updateSeason(dt) {
  seasonTimer += dt;
  if (seasonTimer >= SEASON_DURATION) {
    seasonTimer -= SEASON_DURATION;
    currentSeason = (currentSeason + 1) % 4;
    notify('Season changed to ' + SEASONS[currentSeason].name + '!');
  }
  playerTemp = getPlayerTemp();

  // Freeze damage
  if (playerTemp < FREEZE_TEMP) {
    const severity = (FREEZE_TEMP - playerTemp) / 20;
    player.hp -= severity * dt;
    if (player.hp <= 0) playerDeath();
  }

  // Heat damage (extreme)
  if (playerTemp > HEAT_TEMP) {
    const severity = (playerTemp - HEAT_TEMP) / 15;
    player.hp -= severity * dt;
    if (player.hp <= 0) playerDeath();
  }

  // Potion timers
  if (speedBoostTimer > 0) speedBoostTimer = Math.max(0, speedBoostTimer - dt);
  if (strengthBoostTimer > 0) strengthBoostTimer = Math.max(0, strengthBoostTimer - dt);
}

// ============================================================
// GAME UPDATE
// ============================================================
function update(dt) {
  if (!gameRunning || craftingOpen || buildMenuOpen || fullscreenMapOpen || backpackOpen || tradeOpen || smeltOpen) return;

  // Update seasons and temperature
  updateSeason(dt);

  // Day/night cycle
  dayTimer += dt;
  if (dayTimer >= DAY_LENGTH) dayTimer -= DAY_LENGTH;

  // Damage flash decay
  if (damageFlash > 0) damageFlash = Math.max(0, damageFlash - dt);
  if (damageIndicatorTimer > 0) damageIndicatorTimer = Math.max(0, damageIndicatorTimer - dt);

  // Tree growth (every 10 seconds)
  treeGrowthTimer += dt;
  if (treeGrowthTimer >= 10) {
    treeGrowthTimer = 0;
    updateTreeGrowth();
  }

  // Mouse look
  player.angle += mouseDX * ROT_SPEED;
  player.pitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, player.pitch - mouseDY * PITCH_SPEED * H * 0.5));
  mouseDX = 0;
  mouseDY = 0;

  // Sprint
  player.sprinting = !!(keys['ShiftLeft'] || keys['ShiftRight']) && player.hunger > 10;

  // Movement
  const cosA = Math.cos(player.angle), sinA = Math.sin(player.angle);
  let moveX = 0, moveY = 0;
  if (keys['KeyW']) { moveX += cosA; moveY += sinA; }
  if (keys['KeyS']) { moveX -= cosA; moveY -= sinA; }
  if (keys['KeyA']) { moveX += sinA; moveY -= cosA; }
  if (keys['KeyD']) { moveX -= sinA; moveY += cosA; }

  // Check if holding boat
  const heldForMove = getHeldItem();
  const hasBoat = heldForMove && heldForMove.tool === 'boat';
  function isPassable(block) {
    if (block === T.AIR || block === T.DOOR) return true;
    if (block === T.WATER) return true;
    if (block === T.HOLE) return true;
    return false;
  }

  if (!player.inTree && (moveX !== 0 || moveY !== 0)) {
    let baseSpeed = player.sprinting ? SPRINT_SPEED : MOVE_SPEED;
    if (player.riding) baseSpeed = 5.0; // horse gallop speed
    let speed = speedBoostTimer > 0 ? baseSpeed * 1.6 : baseSpeed;
    // Water: boat = 1.5x, swimming = 0.5x
    const onBlockMove = getBlock(Math.floor(player.x), Math.floor(player.y));
    if (onBlockMove === T.WATER && !player.riding) {
      if (hasBoat) speed *= 1.5;
      else speed *= 0.5;
    }
    if (player.sprinting && !player.riding) player.hunger -= SPRINT_HUNGER * dt;
    const len = Math.sqrt(moveX * moveX + moveY * moveY);
    moveX = moveX / len * speed * dt;
    moveY = moveY / len * speed * dt;

    // Collision - slide along walls
    const margin = 0.2;
    const nx = player.x + moveX;
    const ny = player.y + moveY;

    const bx = getBlock(Math.floor(nx + (moveX > 0 ? margin : -margin)), Math.floor(player.y));
    const by = getBlock(Math.floor(player.x), Math.floor(ny + (moveY > 0 ? margin : -margin)));

    if (isPassable(bx)) player.x = nx;
    if (isPassable(by)) player.y = ny;

    // Lava damage
    const onBlock = getBlock(Math.floor(player.x), Math.floor(player.y));
    if (onBlock === T.LAVA) {
      player.hp -= 20 * dt;
      if (player.hp <= 0) playerDeath();
    }

    // Keep mounted horse at player position
    if (player.riding) {
      player.riding.x = player.x;
      player.riding.y = player.y;
      player.riding.angle = player.angle;
    }
  }

  // Validate mount still exists
  if (player.riding && !creatures.includes(player.riding)) {
    player.riding = null;
  }

  // Swimming stamina
  const swimBlock = getBlock(Math.floor(player.x), Math.floor(player.y));
  if (swimBlock === T.WATER) {
    if (hasBoat || player.riding) {
      // No stamina drain with boat or horse
    } else {
      player.swimStamina -= 5 * dt;
      if (player.swimStamina <= 0) {
        player.swimStamina = 0;
        player.hp -= 3 * dt; // drowning
        if (player.hp <= 0) playerDeath();
      }
    }
  } else {
    // Recharge on land
    player.swimStamina = Math.min(player.maxSwimStamina, player.swimStamina + 15 * dt);
  }

  // Layer transitions (underground holes)
  // Check HOLE on current layer
  const holeCheck = getBlockOnLayer(Math.floor(player.x), Math.floor(player.y), player.level);
  if (holeCheck === T.HOLE) {
    if (player.level === 0) {
      // Check underground has air at this spot
      const ugBlock = getBlockOnLayer(Math.floor(player.x), Math.floor(player.y), 1);
      if (ugBlock === T.AIR || ugBlock === T.HOLE) {
        player.level = 1;
        notify('Descended underground!');
        updateTorchCache();
      }
    } else {
      player.level = 0;
      notify('Returned to surface!');
      updateTorchCache();
    }
  }

  // Hunger
  player.hunger -= HUNGER_RATE * dt;
  if (player.hunger <= 0) {
    player.hunger = 0;
    player.hp -= STARVE_DMG * dt;
    if (player.hp <= 0) playerDeath();
  }

  // Near well - restore hunger slowly
  const px = Math.floor(player.x), py = Math.floor(player.y);
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      if (getBlock(px + dx, py + dy) === T.WELL) {
        player.hunger = Math.min(player.maxHunger, player.hunger + 5 * dt);
        player.hp = Math.min(player.maxHp, player.hp + 1 * dt);
      }
    }
  }

  // HP regen when well fed
  if (player.hunger > 80) {
    player.hp = Math.min(player.maxHp, player.hp + 0.5 * dt);
  }

  // Attack cooldown
  player.attackCooldown = Math.max(0, player.attackCooldown - dt);

  // Left click: mine or attack
  if (mouseDown.left) {
    handleMineOrAttack(dt);
  } else {
    player.miningTarget = null;
    player.miningProgress = 0;
  }

  // Right click: place, eat, or tame
  if (mouseDown.right) {
    handleRightClick(dt);
    mouseDown.right = false; // single action
  }

  // Update creatures
  updateCreatures(dt);

  // Update NPCs (face toward player)
  for (const n of npcs) {
    const dx = player.x - n.x, dy = player.y - n.y;
    if (Math.sqrt(dx * dx + dy * dy) < 8) {
      n.angle = Math.atan2(dy, dx);
    }
  }

  // Update notifications
  for (let i = notifications.length - 1; i >= 0; i--) {
    notifications[i].time -= dt;
    if (notifications[i].time <= 0) notifications.splice(i, 1);
  }

  // Update torch cache periodically
  if (Math.random() < 0.02) updateTorchCache();
}

function handleMineOrAttack(dt) {
  // Can't mine or attack while in a tree or on a horse
  if (player.inTree) return;
  if (player.riding) return;
  // First check for creature attack
  if (player.attackCooldown <= 0) {
    const fov = Math.PI / 6; // narrow cone
    for (const c of creatures) {
      if (c.tamed) continue;
      const dx = c.x - player.x, dy = c.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > ATTACK_RANGE) continue;
      const angleToCreature = Math.atan2(dy, dx);
      let angleDiff = angleToCreature - player.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      if (Math.abs(angleDiff) < fov) {
        const dmg = getSwordDmg();
        c.hp -= dmg;
        c.knockback = 1;
        c.kbAngle = Math.atan2(dy, dx);
        player.attackCooldown = ATTACK_COOLDOWN;
        SFX.attack();
        if (c.hp <= 0) {
          const ct = CREATURE_TYPES[c.type];
          if (ct.drop) {
            const added = addItem(ct.drop, 1);
            if (added > 0) notify('+1 ' + ITEMS[ct.drop].name);
          }
          if (ct.specialDrop) {
            const sa = addItem(ct.specialDrop, 1);
            if (sa > 0) notify('+1 ' + ITEMS[ct.specialDrop].name);
          }
          const killXP = Math.ceil(ct.hp / 10);
          gainXP(killXP);
          creatures.splice(creatures.indexOf(c), 1);
        }
        return;
      }
    }
  }

  // Mining â€” dig at feet when looking far down, dig up when underground looking up, otherwise raycast
  let mineX, mineY, mineBlock;
  let virtualDig = false; // digging through AIR ground with shovel
  let digUp = false; // digging upward from underground
  if (player.pitch > MAX_PITCH * 0.6 && player.level === 1 && getShovelTier() > 0) {
    // Dig upward from underground â€” mine ceiling to create exit hole
    mineX = Math.floor(player.x);
    mineY = Math.floor(player.y);
    mineBlock = getBlockOnLayer(mineX, mineY, 1); // underground tile at feet
    if (mineBlock === T.AIR || mineBlock === T.HOLE) {
      // Ceiling above is virtual stone
      mineBlock = T.STONE;
      digUp = true;
    } else {
      // Mine the underground block normally
    }
  } else if (player.pitch < -MAX_PITCH * 0.6) {
    // Dig at feet
    mineX = Math.floor(player.x);
    mineY = Math.floor(player.y);
    mineBlock = getBlock(mineX, mineY);
    if (mineBlock === T.AIR && player.level === 0 && getShovelTier() > 0) {
      // Standing on open ground on surface â€” allow digging down through the "ground"
      mineBlock = T.DIRT; // treat as virtual dirt
      virtualDig = true;
    } else if (mineBlock === T.AIR || mineBlock === T.WATER) {
      player.miningTarget = null;
      player.miningProgress = 0;
      return;
    }
  } else {
    const hit = castRay(player.x, player.y, player.angle);
    if (hit.dist > MINE_RANGE || hit.block === T.AIR) {
      player.miningTarget = null;
      player.miningProgress = 0;
      return;
    }
    mineX = hit.mapX;
    mineY = hit.mapY;
    mineBlock = hit.block;
  }

  const key = mineX + ',' + mineY;
  if (player.miningTarget !== key) {
    player.miningTarget = key;
    player.miningProgress = 0;
  }

  const info = TILE_INFO[mineBlock];
  if (!info || info.hits >= 999) return;

  // Mining speed based on pickaxe tier + shovel bonus on soft blocks
  const tier = getPickaxeTier();
  const shovelTier = getShovelTier();
  let speedMult = 1 + tier * 0.6;
  if (isSoftBlock(mineBlock) && shovelTier > 0) {
    speedMult = Math.max(speedMult, 1 + shovelTier * 1.2);
  }
  player.miningProgress += (dt * speedMult) / info.hits * 2;
  if (Math.random() < dt * 8) SFX.mine(); // mining hit sounds

  if (player.miningProgress >= 1) {
    // Dig-up from underground: looking up with shovel
    if (digUp) {
      const digKey = 'up_' + mineX + ',' + mineY;
      player.digProgress[digKey] = (player.digProgress[digKey] || 0) + 1;
      SFX.blockBreak();
      const added = addItem('stone', 1);
      if (added > 0) notify('+1 Stone');
      if (player.digProgress[digKey] >= 3) {
        // Create hole on both layers
        setBlockOnLayer(mineX, mineY, T.HOLE, 1); // underground hole
        setBlockOnLayer(mineX, mineY, T.HOLE, 0); // surface hole
        delete player.digProgress[digKey];
        notify('Dug a hole to the surface!');
      } else {
        notify('Digging upward... (' + player.digProgress[digKey] + '/3)');
      }
      gainXP(1);
      player.miningTarget = null;
      player.miningProgress = 0;
      updateTorchCache();
      return;
    }

    // Dig-to-underground: surface, looking down, holding shovel, soft block (or virtual dirt ground)
    const isDiggingDown = player.level === 0 && player.pitch < -MAX_PITCH * 0.6 && getShovelTier() > 0 && (isSoftBlock(mineBlock) || virtualDig);
    if (isDiggingDown) {
      const digKey = mineX + ',' + mineY;
      player.digProgress[digKey] = (player.digProgress[digKey] || 0) + 1;
      SFX.blockBreak();
      // Drop dirt when digging
      const added = addItem('dirt', 1);
      if (added > 0) notify('+1 Dirt');
      if (player.digProgress[digKey] >= 3) {
        // Create hole on surface
        setBlockOnLayer(mineX, mineY, T.HOLE, 0);
        // Clear underground tile below for entry
        setBlockOnLayer(mineX, mineY, T.AIR, 1);
        delete player.digProgress[digKey];
        notify('Dug a hole to the underground!');
      } else {
        // Restore the soft block so player can dig again (unless virtual dig â€” ground stays AIR)
        if (!virtualDig) setBlock(mineX, mineY, mineBlock);
        notify('Digging deeper... (' + player.digProgress[digKey] + '/3)');
      }
    } else {
      // Normal mining â€” break the block
      setBlock(mineX, mineY, T.AIR);
      SFX.blockBreak();
      if (info.drop) {
        const added = addItem(info.drop, info.dropAmt || 1);
        if (added > 0) notify('+' + (info.dropAmt || 1) + ' ' + ITEMS[info.drop].name);
      }
      // Force climb-down if player's tree was mined
      if (player.inTree && player.treePos && mineX === player.treePos.x && mineY === player.treePos.y) {
        player.inTree = false; player.treePos = null; player.treeStealth = false;
        notify('Tree destroyed â€” fell down!');
      }
      // Drop seeds from tree tiles
      const treeSeedMap = {[T.OAK]:'oak_seed',[T.PINE]:'pine_seed',[T.JUNGLE_TREE]:'jungle_seed',[T.PALM]:'palm_seed'};
      if (treeSeedMap[mineBlock]) {
        const seedAdded = addItem(treeSeedMap[mineBlock], 1);
        if (seedAdded > 0) notify('+1 ' + ITEMS[treeSeedMap[mineBlock]].name);
      }
      // Return seed when breaking sapling
      if (mineBlock === T.SAPLING) {
        const sapKey = mineX + ',' + mineY;
        const species = saplingData[sapKey] || 'oak';
        const seedId = species + '_seed';
        if (ITEMS[seedId]) {
          const sa = addItem(seedId, 1);
          if (sa > 0) notify('+1 ' + ITEMS[seedId].name);
        }
        delete saplingData[sapKey];
      }
    }
    gainXP(1);
    player.miningTarget = null;
    player.miningProgress = 0;
    updateTorchCache();
  }
}

function isNearCampfire() {
  const px = Math.floor(player.x), py = Math.floor(player.y);
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      if (getBlock(px + dx, py + dy) === T.CAMPFIRE) return true;
    }
  }
  return false;
}

function handleRightClick() {
  const held = getHeldItem();
  const heldId = getHeldItemId();

  // Use health potion
  if (heldId === 'health_potion' && player.hp < player.maxHp) {
    player.hp = Math.min(player.maxHp, player.hp + 50);
    removeItem('health_potion', 1);
    notify('Used Health Potion (+50 HP)'); SFX.potion();
    return;
  }

  // Use speed potion
  if (heldId === 'speed_potion') {
    speedBoostTimer = 30; // 30 seconds
    removeItem('speed_potion', 1);
    notify('Speed Boost active for 30s!'); SFX.potion();
    return;
  }

  // Use strength potion
  if (heldId === 'strength_potion') {
    strengthBoostTimer = 30;
    removeItem('strength_potion', 1);
    notify('Strength Boost active for 30s!'); SFX.potion();
    return;
  }

  // Matches â†’ place campfire
  if (heldId === 'matches') {
    let placeX, placeY;
    if (player.pitch < -MAX_PITCH * 0.5) {
      placeX = Math.floor(player.x);
      placeY = Math.floor(player.y);
    } else {
      placeX = Math.floor(player.x + Math.cos(player.angle) * 2);
      placeY = Math.floor(player.y + Math.sin(player.angle) * 2);
    }
    if (placeX > 0 && placeX < MAP_SIZE - 1 && placeY > 0 && placeY < MAP_SIZE - 1) {
      if (getBlock(placeX, placeY) === T.AIR) {
        setBlock(placeX, placeY, T.CAMPFIRE);
        removeItem('matches', 1);
        updateTorchCache();
        notify('Lit a fire!'); SFX.build();
        return;
      }
    }
  }

  // Summon tamed animal from whistle/egg/pup
  if (held && held.summon) {
    const ct = CREATURE_TYPES[held.summon];
    if (ct) {
      const sx = player.x + Math.cos(player.angle) * 2;
      const sy = player.y + Math.sin(player.angle) * 2;
      creatures.push({
        type: held.summon, x: sx, y: sy,
        hp: ct.hp, maxHp: ct.hp,
        angle: player.angle, state: 'follow',
        tamed: true, stateTimer: 3,
        knockback: 0, kbAngle: 0, attackTimer: 0,
        age: 120, breedTimer: 0, attackAnim: 0,
        produceTimer: 0, penned: false,
      });
      removeItem(heldId, 1);
      notify('Summoned tame ' + ct.name + '!'); SFX.tame();
      return;
    }
  }

  // Cook raw meat on campfire
  if (heldId === 'raw_meat' && isNearCampfire()) {
    removeItem('raw_meat', 1);
    addItem('cooked_meat', 1);
    notify('Cooked meat on campfire!'); SFX.craft();
    return;
  }

  // Cook raw fish on campfire
  if (heldId === 'raw_fish' && isNearCampfire()) {
    removeItem('raw_fish', 1);
    addItem('cooked_fish', 1);
    notify('Cooked fish on campfire!'); SFX.craft();
    return;
  }

  // Farm animal production (right-click tamed animal: collect product or toggle pen/follow)
  for (const c of creatures) {
    if (!c.tamed) continue;
    const dx2 = c.x - player.x, dy2 = c.y - player.y;
    if (Math.sqrt(dx2 * dx2 + dy2 * dy2) >= 3) continue;
    // Check for ready product
    if (c.produceTimer <= 0) {
      if (c.type === 'chicken') {
        addItem('chicken_egg', 1);
        c.produceTimer = 60; // 60s cooldown
        notify('+1 Egg'); SFX.eat();
        return;
      } else if (c.type === 'cow') {
        addItem('milk', 1);
        c.produceTimer = 90;
        notify('+1 Milk'); SFX.eat();
        return;
      } else if (c.type === 'sheep') {
        addItem('wool', 1);
        c.produceTimer = 75;
        notify('+1 Wool'); SFX.eat();
        return;
      } else if (c.type === 'pig') {
        const pigDrops = ['bacon', 'ribs', 'raw_meat'];
        const drop = pigDrops[Math.floor(Math.random() * pigDrops.length)];
        addItem(drop, 1);
        c.produceTimer = 75;
        notify('+1 ' + ITEMS[drop].name); SFX.eat();
        return;
      }
    }
    // No product ready â€” toggle penned/follow
    if (c.type === 'chicken' || c.type === 'cow' || c.type === 'sheep' || c.type === 'pig'
        || c.type === 'horse' || c.type === 'goat') {
      c.penned = !c.penned;
      c.state = c.penned ? 'idle' : 'follow';
      notify(CREATURE_TYPES[c.type].name + ': ' + (c.penned ? 'Staying (penned)' : 'Following'));
      return;
    }
  }

  // Empty bucket + water â†’ fill bucket
  if (heldId === 'empty_bucket') {
    // Check if looking at water (raycast) or standing in water (look down)
    const bucketHit = castRay(player.x, player.y, player.angle);
    const standBlock = getBlock(Math.floor(player.x), Math.floor(player.y));
    if ((bucketHit.block === T.WATER && bucketHit.dist < MINE_RANGE) || (player.pitch < -MAX_PITCH * 0.5 && standBlock === T.WATER)) {
      removeItem('empty_bucket', 1);
      addItem('water_bucket', 1);
      notify('Filled bucket with water!'); SFX.build();
      return;
    }
  }

  // Water bucket â†’ pour water on ground
  if (heldId === 'water_bucket') {
    let pourX, pourY;
    if (player.pitch < -MAX_PITCH * 0.5) {
      pourX = Math.floor(player.x);
      pourY = Math.floor(player.y);
    } else {
      pourX = Math.floor(player.x + Math.cos(player.angle) * PLACE_DIST);
      pourY = Math.floor(player.y + Math.sin(player.angle) * PLACE_DIST);
    }
    if (pourX > 0 && pourX < MAP_SIZE - 1 && pourY > 0 && pourY < MAP_SIZE - 1) {
      const pourBlock = getBlock(pourX, pourY);
      if (pourBlock === T.AIR) {
        setBlock(pourX, pourY, T.WATER);
        removeItem('water_bucket', 1);
        addItem('empty_bucket', 1);
        notify('Placed water!'); SFX.build();
        return;
      }
    }
  }

  // Try to eat food
  if (held && held.food) {
    player.hunger = Math.min(player.maxHunger, player.hunger + held.food);
    if (held.food >= 30) player.hp = Math.min(player.maxHp, player.hp + held.food * 0.3);
    removeItem(heldId, 1);
    notify('Ate ' + held.name + ' (+' + held.food + ' hunger)'); SFX.eat();
    return;
  }

  // Try to tame creature with berries
  if (heldId === 'berries') {
    for (const c of creatures) {
      if (c.tamed) continue;
      const ct = CREATURE_TYPES[c.type];
      if (!ct.tameable) continue;
      const dx = c.x - player.x, dy = c.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 3) {
        const tameChance = 0.3 + (c.hp < c.maxHp ? 0.2 : 0);
        if (Math.random() < tameChance) {
          c.tamed = true;
          c.state = 'follow';
          c.hp = c.maxHp;
          notify('Tamed ' + ct.name + '!'); SFX.tame();
        } else {
          notify(ct.name + ' sniffed the berries...');
        }
        removeItem('berries', 1);
        return;
      }
    }
  }

  // Open furnace if looking at one
  const hitF = castRay(player.x, player.y, player.angle);
  if (hitF.block === T.FURNACE && hitF.dist < 3) {
    openSmeltMenu();
    return;
  }

  // Open chest if looking at one
  const hit = castRay(player.x, player.y, player.angle);
  if (hit.block === T.CHEST && hit.dist < 3) {
    openChest(hit.mapX, hit.mapY);
    return;
  }

  // Plant seed â†’ creates sapling with species tracking
  if (held && held.seedSpecies) {
    const dist = PLACE_DIST;
    const placeX = Math.floor(player.x + Math.cos(player.angle) * dist);
    const placeY = Math.floor(player.y + Math.sin(player.angle) * dist);
    if (placeX !== Math.floor(player.x) || placeY !== Math.floor(player.y)) {
      if (placeX > 0 && placeX < MAP_SIZE - 1 && placeY > 0 && placeY < MAP_SIZE - 1) {
        if (getBlock(placeX, placeY) === T.AIR) {
          setBlock(placeX, placeY, T.SAPLING);
          saplingData[placeX + ',' + placeY] = held.seedSpecies;
          removeItem(heldId, 1);
          notify('Planted ' + held.name + '!');
          SFX.build();
          return;
        }
      }
    }
  }

  // Try to place block
  if (held && held.placeTile) {
    const placeDist = buildMode ? BUILD_PLACE_DIST : PLACE_DIST;
    // If looking at a wall, place adjacent to it; otherwise place at fixed distance
    let placeX, placeY;
    if (hit.block !== T.AIR && hit.dist <= placeDist + 1) {
      placeX = hit.mapX;
      placeY = hit.mapY;
      // Step back one tile from the wall on the hit side
      if (hit.side === 0) placeX += (Math.cos(player.angle) > 0 ? -1 : 1);
      else placeY += (Math.sin(player.angle) > 0 ? -1 : 1);
      // Fallback if adjacent tile isn't air
      if (placeX < 1 || placeX >= MAP_SIZE - 1 || placeY < 1 || placeY >= MAP_SIZE - 1 || getBlock(placeX, placeY) !== T.AIR) {
        placeX = Math.floor(player.x + Math.cos(player.angle) * placeDist);
        placeY = Math.floor(player.y + Math.sin(player.angle) * placeDist);
      }
    } else {
      placeX = Math.floor(player.x + Math.cos(player.angle) * placeDist);
      placeY = Math.floor(player.y + Math.sin(player.angle) * placeDist);
    }

    // Place under self when looking far down
    if (player.pitch < -MAX_PITCH * 0.5) {
      placeX = Math.floor(player.x);
      placeY = Math.floor(player.y);
    }

    // Don't place on self (unless looking down â€” already overridden above)
    if (player.pitch >= -MAX_PITCH * 0.5 && placeX === Math.floor(player.x) && placeY === Math.floor(player.y)) return;

    if (placeX > 0 && placeX < MAP_SIZE - 1 && placeY > 0 && placeY < MAP_SIZE - 1) {
      if (getBlock(placeX, placeY) === T.AIR || (player.pitch < -MAX_PITCH * 0.5 && getBlock(placeX, placeY) === T.WATER)) {
        setBlock(placeX, placeY, held.placeTile);
        removeItem(heldId, 1);
        SFX.build();
        if (held.placeTile === T.TORCH || held.placeTile === T.CAMPFIRE || held.placeTile === T.FURNACE) updateTorchCache();
        return;
      }
    }
  }
}

// ============================================================
// CHEST SYSTEM
// ============================================================
function openChest(cx, cy) {
  const key = cx + ',' + cy;
  if (!chestInventories[key]) chestInventories[key] = new Array(8).fill(null);
  // Simple: transfer held item to chest or take from chest
  const held = player.hotbar[player.selectedSlot];
  if (held) {
    // Deposit into chest
    for (let i = 0; i < 8; i++) {
      if (!chestInventories[key][i]) {
        chestInventories[key][i] = {...held};
        player.hotbar[player.selectedSlot] = null;
        notify('Deposited ' + ITEMS[held.id].name + ' in chest');
        return;
      }
    }
    notify('Chest is full!');
  } else {
    // Withdraw from chest
    for (let i = 7; i >= 0; i--) {
      if (chestInventories[key][i]) {
        player.hotbar[player.selectedSlot] = {...chestInventories[key][i]};
        chestInventories[key][i] = null;
        notify('Took ' + ITEMS[player.hotbar[player.selectedSlot].id].name + ' from chest');
        return;
      }
    }
    notify('Chest is empty');
  }
}

function updateTorchCache() {
  torchPositions = [];
  const px = Math.floor(player.x), py = Math.floor(player.y);
  const r = 15;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const blk = getBlock(px + dx, py + dy);
      if (blk === T.TORCH || blk === T.CAMPFIRE || blk === T.FURNACE) {
        torchPositions.push([px + dx, py + dy]);
      }
    }
  }
}

// ============================================================
// SAVE / LOAD (5 SLOTS)
// ============================================================
function saveGame() {
  if (activeSlot < 0) return;
  const data = {
    worldSeed,
    blockChanges,
    player: {
      x: player.x, y: player.y, angle: player.angle, pitch: player.pitch,
      hp: player.hp, hunger: player.hunger,
      hotbar: player.hotbar,
      backpack: player.backpack,
      selectedSlot: player.selectedSlot,
      swimStamina: player.swimStamina,
      inTree: player.inTree,
      treePos: player.treePos,
      treeStealth: player.treeStealth,
      level: player.level,
      digProgress: player.digProgress,
    },
    undergroundBlockChanges,
    creatures: creatures.map(c => ({
      type: c.type, x: c.x, y: c.y, hp: c.hp,
      tamed: c.tamed, angle: c.angle,
      age: c.age || 0, breedTimer: c.breedTimer || 0,
      produceTimer: c.produceTimer || 0, penned: c.penned || false,
    })),
    npcs: npcs.map(n => ({ type: n.type, x: n.x, y: n.y, town: n.town })),
    minimapSize,
    currentSeason,
    seasonTimer,
    chestInventories,
    saplingData,
    playerXP,
    playerLevel,
    maxHp: player.maxHp,
    dayTimer,
    savedAt: Date.now(),
  };
  try {
    localStorage.setItem(SAVE_KEY_PREFIX + activeSlot, JSON.stringify(data));
  } catch (e) { /* storage full */ }
}

function loadGame(slot) {
  try {
    const raw = localStorage.getItem(SAVE_KEY_PREFIX + slot);
    if (!raw) return false;
    const data = JSON.parse(raw);
    activeSlot = slot;

    worldSeed = data.worldSeed;
    blockChanges = data.blockChanges || {};
    undergroundBlockChanges = data.undergroundBlockChanges || {};
    generateWorld(worldSeed);

    player.x = data.player.x;
    player.y = data.player.y;
    player.angle = data.player.angle;
    player.pitch = data.player.pitch || 0;
    player.hp = data.player.hp;
    player.hunger = data.player.hunger;
    player.hotbar = data.player.hotbar;
    player.backpack = data.player.backpack || new Array(BACKPACK_SIZE).fill(null);
    player.selectedSlot = data.player.selectedSlot || 0;
    player.swimStamina = data.player.swimStamina || 100;
    player.inTree = data.player.inTree || false;
    player.treePos = data.player.treePos || null;
    player.treeStealth = data.player.treeStealth || false;
    player.level = data.player.level || 0;
    player.digProgress = data.player.digProgress || {};
    minimapSize = data.minimapSize || 0;
    currentSeason = data.currentSeason || 0;
    seasonTimer = data.seasonTimer || 0;
    chestInventories = data.chestInventories || {};
    saplingData = data.saplingData || {};
    playerXP = data.playerXP || 0;
    playerLevel = data.playerLevel || 1;
    player.maxHp = data.maxHp || 100;
    dayTimer = data.dayTimer || 0;

    creatures = [];
    if (data.creatures) {
      for (const cd of data.creatures) {
        const ct = CREATURE_TYPES[cd.type];
        if (!ct) continue;
        creatures.push({
          type: cd.type,
          x: cd.x, y: cd.y,
          hp: cd.hp, maxHp: ct.hp,
          angle: cd.angle || 0,
          state: (cd.tamed && cd.penned) ? 'idle' : (cd.tamed ? 'follow' : 'idle'),
          tamed: cd.tamed || false,
          stateTimer: Math.random() * 3,
          knockback: 0, kbAngle: 0,
          attackTimer: 0, attackAnim: 0,
          age: cd.age || 120,
          breedTimer: cd.breedTimer || 0,
          produceTimer: cd.produceTimer || 0,
          penned: cd.penned || false,
        });
      }
    }

    if (data.npcs && data.npcs.length > 0) {
      npcs = data.npcs.map(nd => ({
        type: nd.type, x: nd.x, y: nd.y,
        town: nd.town || '', angle: 0,
      }));
    } else {
      spawnNPCs();
    }

    updateTorchCache();
    return true;
  } catch (e) {
    return false;
  }
}

function getSlotInfo(slot) {
  try {
    const raw = localStorage.getItem(SAVE_KEY_PREFIX + slot);
    if (!raw) return null;
    const data = JSON.parse(raw);
    return {
      seed: data.worldSeed,
      hp: Math.ceil(data.player.hp),
      hunger: Math.ceil(data.player.hunger),
      season: SEASONS[data.currentSeason || 0].name,
      level: data.playerLevel || 1,
      savedAt: data.savedAt ? new Date(data.savedAt).toLocaleDateString() : 'Unknown',
    };
  } catch (e) { return null; }
}

function deleteSlot(slot) {
  localStorage.removeItem(SAVE_KEY_PREFIX + slot);
  renderTitleScreen();
}

function hasSave() {
  for (let i = 0; i < 5; i++) {
    if (localStorage.getItem(SAVE_KEY_PREFIX + i)) return true;
  }
  return false;
}

// ============================================================
// GAME LIFECYCLE
// ============================================================
function playerDeath() {
  player.hp = 0;
  gameRunning = false;
  document.exitPointerLock();
  SFX.death();
  // Lose everything on death
  player.hotbar = new Array(8).fill(null);
  player.backpack = new Array(BACKPACK_SIZE).fill(null);
  player.selectedSlot = 0;
  speedBoostTimer = 0;
  strengthBoostTimer = 0;
  player.riding = null;
  player.inTree = false;
  player.treePos = null;
  player.treeStealth = false;
  // Lose half XP on death, but keep level
  playerXP = Math.floor(playerXP / 2);
  notify('You lost all your items!');
  // Save the loss
  if (activeSlot >= 0) saveGame();
  document.getElementById('death-screen').style.display = 'flex';
}

function respawn() {
  document.getElementById('death-screen').style.display = 'none';
  player.x = MAP_SIZE / 2 + 0.5;
  player.y = MAP_SIZE / 2 + 0.5;
  player.hp = player.maxHp;
  player.hunger = player.maxHunger;
  player.swimStamina = player.maxSwimStamina;
  player.level = 0;
  player.inTree = false;
  player.treePos = null;
  player.treeStealth = false;
  player.riding = null;
  player.digProgress = {};
  // Give minimal starter items
  addItem('wood', 5);
  addItem('berries', 4);
  gameRunning = true;
  C.requestPointerLock();
}

function renderTitleScreen() {
  const container = document.getElementById('save-slots');
  let html = '';
  for (let i = 0; i < 5; i++) {
    const info = getSlotInfo(i);
    if (info) {
      html += `<div style="background:rgba(30,30,50,0.9);border:2px solid #555;border-radius:8px;padding:14px 18px;min-width:140px;text-align:center;pointer-events:auto;">
        <div style="color:#e8a030;font-weight:bold;font-size:14px;margin-bottom:6px;">Slot ${i + 1}</div>
        <div style="color:#aaa;font-size:11px;">Seed: ${info.seed}</div>
        <div style="color:#aaa;font-size:11px;">HP: ${info.hp} | Hunger: ${info.hunger}</div>
        <div style="color:#8844DD;font-size:11px;">Level ${info.level}</div>
        <div style="color:#88CC88;font-size:11px;">${info.season} | ${info.savedAt}</div>
        <button class="menu-btn" style="font-size:14px;padding:8px 20px;margin:8px 2px 0;min-width:auto;" onclick="startGame(${i},true)">Load</button>
        <button class="menu-btn" style="font-size:12px;padding:6px 12px;margin:4px 2px 0;min-width:auto;border-color:#aa3333;color:#aa3333;" onclick="deleteSlot(${i})">Delete</button>
      </div>`;
    } else {
      html += `<div style="background:rgba(30,30,50,0.9);border:2px solid #333;border-radius:8px;padding:14px 18px;min-width:140px;text-align:center;pointer-events:auto;">
        <div style="color:#666;font-weight:bold;font-size:14px;margin-bottom:6px;">Slot ${i + 1}</div>
        <div style="color:#444;font-size:11px;margin-bottom:8px;">â€” Empty â€”</div>
        <button class="menu-btn" style="font-size:14px;padding:8px 20px;margin:4px 0 0;min-width:auto;" onclick="startGame(${i},false)">New Game</button>
      </div>`;
    }
  }
  container.innerHTML = html;
}

function startGame(slot, isLoad) {
  document.getElementById('title-screen').style.display = 'none';
  activeSlot = slot;

  if (isLoad && loadGame(slot)) {
    // Loaded successfully
  } else {
    worldSeed = Math.floor(Math.random() * 999999) + 1;
    blockChanges = {};
    undergroundBlockChanges = {};
    chestInventories = {};
    saplingData = {};
    generateWorld(worldSeed);
    player.x = MAP_SIZE / 2 + 0.5;
    player.y = MAP_SIZE / 2 + 0.5;
    player.angle = 0;
    player.pitch = 0;
    player.hp = 100;
    player.hunger = 100;
    player.hotbar = new Array(8).fill(null);
    player.backpack = new Array(BACKPACK_SIZE).fill(null);
    player.selectedSlot = 0;
    minimapSize = 1;
    buildMode = false;
    currentSeason = 0;
    seasonTimer = 0;
    speedBoostTimer = 0;
    strengthBoostTimer = 0;
    playerXP = 0;
    playerLevel = 1;
    player.maxHp = 100;
    dayTimer = 0;
    player.swimStamina = 100;
    player.inTree = false;
    player.treePos = null;
    player.treeStealth = false;
    player.level = 0;
    player.digProgress = {};
    player.riding = null;
    // Give starter items
    addItem('wood', 10);
    addItem('berries', 8);
    addItem('bread', 3);
    addItem('gold_coin', 5);
    spawnCreatures();
    spawnNPCs();
  }

  updateTorchCache();
  initAudio();
  gameRunning = true;
  C.requestPointerLock();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = 0;
let autoSaveTimer = 0;

function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  if (gameRunning) {
    update(dt);
  }

  if (gameRunning) {
    renderScene();
    renderCreatures();
    renderNPCs();
    renderHUD();
    // Damage flash overlay
    if (damageFlash > 0) {
      ctx.fillStyle = `rgba(255,0,0,${damageFlash * 0.5})`;
      ctx.fillRect(0, 0, W, H);
    }
    renderBuildMenu();
    renderFullscreenMap();

    // Auto-save
    autoSaveTimer += dt;
    if (autoSaveTimer >= 60) {
      autoSaveTimer = 0;
      saveGame();
    }
  }

  requestAnimationFrame(gameLoop);
}

// ============================================================
// INIT
// ============================================================
function init() {
  initTextures();

  // Render save slot UI on title screen
  renderTitleScreen();

  // Save on page close
  window.addEventListener('beforeunload', () => {
    if (gameRunning) saveGame();
  });

  // Start loop (renders title screen)
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
