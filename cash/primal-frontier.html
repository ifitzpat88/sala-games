<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Primal Frontier</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;font-family:'Segoe UI',Tahoma,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;}
canvas{display:block;image-rendering:pixelated;cursor:none;}
#ui{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}
#title-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:default;}
#title-screen h1{font-size:64px;color:#e8a030;text-shadow:0 0 30px rgba(232,160,48,.5),0 4px 8px rgba(0,0,0,.8);letter-spacing:4px;margin-bottom:8px;}
#title-screen .subtitle{color:#888;font-size:18px;margin-bottom:50px;letter-spacing:2px;}
#title-screen .menu-btn{background:none;border:2px solid #555;color:#ccc;font-size:22px;padding:14px 50px;margin:8px;cursor:pointer;border-radius:6px;font-family:inherit;transition:all .2s;pointer-events:auto;min-width:260px;}
#title-screen .menu-btn:hover{border-color:#e8a030;color:#e8a030;background:rgba(232,160,48,.08);box-shadow:0 0 20px rgba(232,160,48,.2);}
#title-screen .menu-btn.disabled{opacity:.35;cursor:not-allowed;}
#title-screen .menu-btn.disabled:hover{border-color:#555;color:#555;background:none;box-shadow:none;}
#title-screen .hint{color:#555;font-size:13px;margin-top:40px;}
#death-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(80,0,0,.85);z-index:90;display:none;flex-direction:column;align-items:center;justify-content:center;}
#death-screen h2{font-size:52px;color:#ff4444;margin-bottom:20px;text-shadow:0 0 20px rgba(255,0,0,.5);}
#death-screen p{color:#ccc;font-size:18px;margin-bottom:30px;}
#death-screen button{background:none;border:2px solid #ff4444;color:#ff4444;font-size:20px;padding:12px 40px;cursor:pointer;border-radius:6px;font-family:inherit;pointer-events:auto;}
#death-screen button:hover{background:rgba(255,68,68,.15);}
#crafting-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #555;border-radius:12px;padding:20px;z-index:80;display:none;min-width:420px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
#crafting-menu h3{color:#e8a030;font-size:20px;margin-bottom:14px;text-align:center;}
.recipe-row{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border:1px solid #333;border-radius:6px;margin-bottom:6px;transition:all .15s;}
.recipe-row:hover{border-color:#e8a030;background:rgba(232,160,48,.05);}
.recipe-name{color:#ddd;font-size:14px;font-weight:600;min-width:120px;}
.recipe-cost{color:#888;font-size:12px;flex:1;margin:0 12px;}
.recipe-craft{background:none;border:1px solid #4a4;color:#4a4;padding:4px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-family:inherit;pointer-events:auto;}
.recipe-craft:hover{background:rgba(68,170,68,.15);}
.recipe-craft.cannot{border-color:#555;color:#555;cursor:not-allowed;}
.recipe-craft.cannot:hover{background:none;}
#backpack-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #44aaff;border-radius:12px;padding:20px;z-index:80;display:none;min-width:460px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
#backpack-menu h3{color:#44aaff;font-size:20px;margin-bottom:14px;text-align:center;}
.bp-slot{display:inline-flex;flex-direction:column;align-items:center;justify-content:center;width:54px;height:60px;border:1px solid #444;border-radius:6px;cursor:pointer;transition:all .15s;background:rgba(30,30,50,.8);vertical-align:top;margin:2px;}
.bp-slot:hover{border-color:#44aaff;background:rgba(68,170,255,.1);}
#trade-menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(15,15,30,.95);border:2px solid #e8a030;border-radius:12px;padding:20px;z-index:80;display:none;min-width:480px;max-height:80vh;overflow-y:auto;pointer-events:auto;cursor:default;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui"></div>
<div id="title-screen">
  <h1>PRIMAL FRONTIER</h1>
  <div class="subtitle">FIRST-PERSON SURVIVAL</div>
  <button class="menu-btn" id="btn-continue" onclick="startGame(true)">Continue</button>
  <button class="menu-btn" onclick="startGame(false)">New Game</button>
  <div class="hint">WASD move &bull; Shift sprint &bull; Mouse look &bull; Left-click mine/attack &bull; Right-click place/eat<br>E craft/trade &bull; Tab backpack &bull; B build mode &bull; M minimap &bull; 1-8 hotbar</div>
</div>
<div id="death-screen">
  <h2>YOU DIED</h2>
  <p>The frontier claims another soul...</p>
  <button onclick="respawn()">Respawn</button>
</div>
<div id="crafting-menu">
  <h3>Crafting</h3>
  <div id="recipe-list"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Press E or Escape to close</div>
</div>
<div id="backpack-menu">
  <h3>Backpack</h3>
  <div id="backpack-slots"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Click items to move between hotbar and backpack &bull; Tab or Escape to close</div>
</div>
<div id="trade-menu">
  <div id="trade-list"></div>
  <div style="text-align:center;margin-top:10px;color:#666;font-size:12px;">Press E or Escape to close</div>
</div>

<script>
// ============================================================
// PRIMAL FRONTIER - First-Person Survival Game
// DDA Raycasting Engine + Mining + Building + Creatures + Taming
// ============================================================

const C = document.getElementById('game');
const ctx = C.getContext('2d');
const W = 800, H = 500;
C.width = W; C.height = H;

// ---- CONSTANTS ----
const MAP_SIZE = 2048;
const TEX_SIZE = 16;
const TILE_EMPTY = 0;
const MOVE_SPEED = 2.0;
const SPRINT_SPEED = 3.5;
const ROT_SPEED = 0.003;
const MINE_RANGE = 3.5;
const PLACE_DIST = 1.8;
const BUILD_PLACE_DIST = 3.5;
const HUNGER_RATE = 0.06; // per second (was 0.4)
const SPRINT_HUNGER = 0.3; // extra hunger when sprinting
const STARVE_DMG = 2;
const AUTOSAVE_INTERVAL = 60000;
const MAX_CREATURES = 300;
const CREATURE_SPAWN_DIST = 6;
const ATTACK_RANGE = 2.5;
const ATTACK_COOLDOWN = 0.5;
const BACKPACK_SIZE = 10;
const TOWN_COUNT = 5;

// ---- TILE TYPES ----
const T = {
  AIR:0, DIRT:1, STONE:2, IRON:3, GOLD:4, CRYSTAL:5,
  WOOD:6, LEAVES:7, SAND:8, SNOW:9, OBSIDIAN:10, LAVA:11,
  WOOD_WALL:20, STONE_WALL:21, FENCE:22, DOOR:23, TORCH:24, WELL:25,
  BRICK:26, WATER:27,
  HOUSE_WALL:28, THATCH_ROOF:29, MARKET_STALL:30, GLASS:31
};

const TILE_INFO = {
  [T.DIRT]:{name:'Dirt',color:[0x8B,0x6B,0x4B],hits:3,drop:'dirt',dropAmt:1},
  [T.STONE]:{name:'Stone',color:[0x80,0x80,0x80],hits:6,drop:'stone',dropAmt:1},
  [T.IRON]:{name:'Iron Ore',color:[0x90,0x70,0x50],hits:8,drop:'iron',dropAmt:1},
  [T.GOLD]:{name:'Gold Ore',color:[0xD4,0xA0,0x17],hits:10,drop:'gold',dropAmt:1},
  [T.CRYSTAL]:{name:'Crystal',color:[0x80,0x40,0xD0],hits:12,drop:'crystal',dropAmt:1},
  [T.WOOD]:{name:'Wood',color:[0x6B,0x4B,0x2B],hits:4,drop:'wood',dropAmt:2},
  [T.LEAVES]:{name:'Leaves',color:[0x22,0x8B,0x22],hits:1,drop:'berries',dropAmt:2},
  [T.SAND]:{name:'Sand',color:[0xD2,0xB4,0x8C],hits:2,drop:'sand',dropAmt:1},
  [T.SNOW]:{name:'Snow',color:[0xE8,0xE8,0xF0],hits:2,drop:'snow',dropAmt:1},
  [T.OBSIDIAN]:{name:'Obsidian',color:[0x20,0x10,0x30],hits:15,drop:'obsidian',dropAmt:1},
  [T.LAVA]:{name:'Lava',color:[0xFF,0x44,0x00],hits:999},
  [T.WOOD_WALL]:{name:'Wood Wall',color:[0x8B,0x6B,0x3B],hits:5,drop:'wood',dropAmt:1},
  [T.STONE_WALL]:{name:'Stone Wall',color:[0x70,0x70,0x70],hits:8,drop:'stone',dropAmt:1},
  [T.FENCE]:{name:'Fence',color:[0x9B,0x7B,0x4B],hits:3,drop:'wood',dropAmt:1},
  [T.DOOR]:{name:'Door',color:[0x6B,0x4B,0x1B],hits:3,drop:'wood',dropAmt:1},
  [T.TORCH]:{name:'Torch',color:[0xFF,0xA5,0x00],hits:1,drop:'wood',dropAmt:1},
  [T.WELL]:{name:'Well',color:[0x40,0x60,0x90],hits:8,drop:'stone',dropAmt:2},
  [T.BRICK]:{name:'Brick',color:[0xA0,0x50,0x30],hits:10,drop:'stone',dropAmt:1},
  [T.WATER]:{name:'Water',color:[0x20,0x60,0xC0],hits:999},
  [T.HOUSE_WALL]:{name:'House Wall',color:[0xE0,0xD8,0xC0],hits:10,drop:'stone',dropAmt:2},
  [T.THATCH_ROOF]:{name:'Thatch Roof',color:[0xAA,0x88,0x44],hits:4,drop:'wood',dropAmt:2},
  [T.MARKET_STALL]:{name:'Market Stall',color:[0xBB,0x66,0x22],hits:5,drop:'wood',dropAmt:3},
  [T.GLASS]:{name:'Glass',color:[0x88,0xCC,0xEE],hits:1,drop:null,dropAmt:0},
};

// ---- ITEMS ----
const ITEMS = {
  dirt:{name:'Dirt',color:'#8B6B4B',placeTile:T.DIRT,stack:64},
  stone:{name:'Stone',color:'#808080',stack:64},
  iron:{name:'Iron',color:'#B08050',stack:64},
  gold:{name:'Gold',color:'#D4A017',stack:64},
  crystal:{name:'Crystal',color:'#A040FF',stack:64},
  wood:{name:'Wood',color:'#8B6B3B',stack:64},
  sand:{name:'Sand',color:'#D2B48C',stack:64},
  snow:{name:'Snow',color:'#E0E0F0',stack:64},
  obsidian:{name:'Obsidian',color:'#302030',stack:64},
  berries:{name:'Berries',color:'#DD3366',stack:32,food:10},
  raw_meat:{name:'Raw Meat',color:'#CC4444',stack:16,food:10},
  cooked_meat:{name:'Cooked Meat',color:'#AA6633',stack:16,food:40},
  bread:{name:'Bread',color:'#DAA520',stack:16,food:30},
  wood_pickaxe:{name:'Wood Pick',color:'#8B6B3B',stack:1,tool:'pickaxe',tier:1},
  stone_pickaxe:{name:'Stone Pick',color:'#808080',stack:1,tool:'pickaxe',tier:2},
  iron_pickaxe:{name:'Iron Pick',color:'#B08050',stack:1,tool:'pickaxe',tier:3},
  wood_sword:{name:'Wood Sword',color:'#8B6B3B',stack:1,tool:'sword',tier:1,dmg:8},
  stone_sword:{name:'Stone Sword',color:'#808080',stack:1,tool:'sword',tier:2,dmg:15},
  iron_sword:{name:'Iron Sword',color:'#B08050',stack:1,tool:'sword',tier:3,dmg:25},
  wood_wall:{name:'Wood Wall',color:'#8B6B3B',placeTile:T.WOOD_WALL,stack:64},
  stone_wall:{name:'Stone Wall',color:'#707070',placeTile:T.STONE_WALL,stack:64},
  fence:{name:'Fence',color:'#9B7B4B',placeTile:T.FENCE,stack:64},
  door:{name:'Door',color:'#6B4B1B',placeTile:T.DOOR,stack:16},
  torch:{name:'Torch',color:'#FFA500',placeTile:T.TORCH,stack:32},
  well:{name:'Well',color:'#4060A0',placeTile:T.WELL,stack:4},
  house_wall:{name:'House Wall',color:'#E0D8C0',placeTile:T.HOUSE_WALL,stack:64},
  thatch_roof:{name:'Thatch Roof',color:'#AA8844',placeTile:T.THATCH_ROOF,stack:64},
  market_stall:{name:'Market Stall',color:'#BB6622',placeTile:T.MARKET_STALL,stack:16},
  glass:{name:'Glass',color:'#88CCEE',placeTile:T.GLASS,stack:32},
  gold_coin:{name:'Gold Coin',color:'#FFD700',stack:999},
};

// ---- RECIPES ----
const RECIPES = [
  {result:'wood_pickaxe',amt:1,cost:{wood:5},cat:'Tools'},
  {result:'stone_pickaxe',amt:1,cost:{wood:3,stone:5},cat:'Tools'},
  {result:'iron_pickaxe',amt:1,cost:{wood:2,iron:5},cat:'Tools'},
  {result:'wood_sword',amt:1,cost:{wood:6},cat:'Tools'},
  {result:'stone_sword',amt:1,cost:{wood:3,stone:6},cat:'Tools'},
  {result:'iron_sword',amt:1,cost:{wood:2,iron:6},cat:'Tools'},
  {result:'wood_wall',amt:4,cost:{wood:2},cat:'Building'},
  {result:'stone_wall',amt:4,cost:{stone:2},cat:'Building'},
  {result:'fence',amt:4,cost:{wood:3},cat:'Building'},
  {result:'door',amt:1,cost:{wood:4},cat:'Building'},
  {result:'torch',amt:4,cost:{wood:1,berries:1},cat:'Building'},
  {result:'well',amt:1,cost:{stone:8,iron:2},cat:'Building'},
  {result:'house_wall',amt:4,cost:{stone:3,wood:2},cat:'Building'},
  {result:'thatch_roof',amt:4,cost:{wood:4},cat:'Building'},
  {result:'glass',amt:2,cost:{sand:4,crystal:1},cat:'Building'},
  {result:'market_stall',amt:1,cost:{wood:8,iron:2},cat:'Building'},
  {result:'cooked_meat',amt:1,cost:{raw_meat:1,wood:1},cat:'Food'},
  {result:'bread',amt:2,cost:{berries:4,wood:1},cat:'Food'},
];

// ---- CREATURE TYPES ----
const CREATURE_TYPES = {
  rabbit:{name:'Rabbit',hp:10,dmg:0,speed:1.8,color:'#C0A080',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.4},
  chicken:{name:'Chicken',hp:8,dmg:0,speed:1.2,color:'#FFFFFF',hostile:false,tameable:true,drop:'raw_meat',biome:'meadow',size:0.35},
  wolf:{name:'Wolf',hp:35,dmg:8,speed:2.2,color:'#808080',hostile:true,tameable:true,drop:'raw_meat',biome:'meadow',size:0.6},
  lizard:{name:'Lizard',hp:15,dmg:3,speed:1.5,color:'#669944',hostile:false,tameable:true,drop:'raw_meat',biome:'desert',size:0.4},
  scorpion:{name:'Scorpion',hp:25,dmg:10,speed:1.8,color:'#884422',hostile:true,tameable:false,drop:'raw_meat',biome:'desert',size:0.45},
  bear:{name:'Bear',hp:60,dmg:15,speed:1.6,color:'#5A3A1A',hostile:true,tameable:true,drop:'raw_meat',biome:'tundra',size:0.8},
  snow_fox:{name:'Snow Fox',hp:18,dmg:4,speed:2.5,color:'#E8E8F0',hostile:false,tameable:true,drop:'raw_meat',biome:'tundra',size:0.45},
  raptor:{name:'Raptor',hp:50,dmg:18,speed:2.8,color:'#446622',hostile:true,tameable:true,drop:'raw_meat',biome:'jungle',size:0.75},
  triceratops:{name:'Triceratops',hp:100,dmg:12,speed:1.2,color:'#667744',hostile:false,tameable:true,drop:'raw_meat',biome:'jungle',size:1.0},
  fire_drake:{name:'Fire Drake',hp:80,dmg:22,speed:2.0,color:'#DD4400',hostile:true,tameable:true,drop:'raw_meat',biome:'volcanic',size:0.9},
  elemental:{name:'Elemental',hp:60,dmg:16,speed:1.4,color:'#FF6600',hostile:true,tameable:false,drop:'obsidian',biome:'volcanic',size:0.7},
};

// ---- BIOME DEFINITIONS ----
const BIOMES = {
  meadow:{name:'Meadow',ground:[0x55,0x88,0x33],sky1:'#5588CC',sky2:'#88BBEE',wall:T.DIRT,ore1:T.STONE,ore2:T.IRON,tree:true},
  desert:{name:'Desert',ground:[0xC0,0xA0,0x60],sky1:'#CC9944',sky2:'#EEDD88',wall:T.SAND,ore1:T.STONE,ore2:T.GOLD,tree:false},
  tundra:{name:'Tundra',ground:[0xCC,0xCC,0xDD],sky1:'#8899AA',sky2:'#BBCCDD',wall:T.SNOW,ore1:T.STONE,ore2:T.IRON,tree:true},
  jungle:{name:'Jungle',ground:[0x22,0x66,0x22],sky1:'#336633',sky2:'#66AA66',wall:T.DIRT,ore1:T.IRON,ore2:T.CRYSTAL,tree:true},
  volcanic:{name:'Volcanic',ground:[0x44,0x22,0x11],sky1:'#442200',sky2:'#884400',wall:T.OBSIDIAN,ore1:T.IRON,ore2:T.GOLD,tree:false},
};

// ---- NPC TYPES ----
const NPC_TYPES = {
  merchant:{name:'Merchant',color:'#DDAA44',size:0.65,
    trades:[
      {give:{gold_coin:3},get:{cooked_meat:2}},
      {give:{gold_coin:5},get:{bread:3}},
      {give:{gold_coin:2},get:{torch:4}},
      {give:{gold_coin:8},get:{iron:5}},
      {give:{wood:20},get:{gold_coin:2}},
      {give:{stone:20},get:{gold_coin:2}},
    ]},
  blacksmith:{name:'Blacksmith',color:'#AA6644',size:0.7,
    trades:[
      {give:{gold_coin:10},get:{iron_pickaxe:1}},
      {give:{gold_coin:12},get:{iron_sword:1}},
      {give:{gold_coin:6},get:{stone_pickaxe:1}},
      {give:{gold_coin:7},get:{stone_sword:1}},
      {give:{iron:10},get:{gold_coin:3}},
      {give:{gold:5},get:{gold_coin:8}},
    ]},
  farmer:{name:'Farmer',color:'#66AA44',size:0.6,
    trades:[
      {give:{gold_coin:1},get:{berries:5}},
      {give:{gold_coin:3},get:{bread:2}},
      {give:{gold_coin:2},get:{cooked_meat:1}},
      {give:{berries:10},get:{gold_coin:1}},
      {give:{raw_meat:5},get:{gold_coin:2}},
    ]},
};

// ---- TOWN TEMPLATES ----
const TOWN_NAMES = ['Hearthville','Ironhaven','Dustwatch','Frostholm','Ashridge'];

// ============================================================
// TEXTURE GENERATION
// ============================================================
const textures = {};

function genTex(id, baseR, baseG, baseB, pattern) {
  const data = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
  for (let y = 0; y < TEX_SIZE; y++) {
    for (let x = 0; x < TEX_SIZE; x++) {
      let r = baseR, g = baseG, b = baseB;
      const i = (y * TEX_SIZE + x) * 3;
      const noise = ((x * 7 + y * 13 + x * y) % 17) - 8;
      r += noise; g += noise; b += noise;
      if (pattern === 'brick') {
        const row = y >> 2;
        const off = (row & 1) ? 4 : 0;
        if (y % 4 === 0 || (x + off) % 8 === 0) { r -= 30; g -= 30; b -= 30; }
      } else if (pattern === 'ore') {
        if ((x + y * 3) % 11 < 2 && (x * y) % 7 < 3) { r += 40; g += 40; b += 20; }
      } else if (pattern === 'crystal') {
        if (Math.abs(x - 8) + Math.abs(y - 8) < 5 + ((x * y) % 3)) { r += 50; g -= 10; b += 60; }
      } else if (pattern === 'wood') {
        const ring = (y + (x >> 2)) % 5;
        if (ring < 1) { r -= 20; g -= 15; b -= 15; }
      } else if (pattern === 'leaves') {
        if ((x + y) % 3 === 0) { r -= 20; g += 10; b -= 20; }
      } else if (pattern === 'plank') {
        if (x % 5 === 0 || y === 0 || y === 15) { r -= 25; g -= 25; b -= 25; }
      } else if (pattern === 'cobble') {
        const bx = ((x + ((y >> 2) * 3)) % 6); const by = y % 4;
        if (bx === 0 || by === 0) { r -= 20; g -= 20; b -= 20; }
      } else if (pattern === 'lava') {
        const wave = Math.sin(x * 0.8 + y * 0.5) * 30;
        r = Math.min(255, r + wave); g = Math.max(0, g + wave * 0.3);
      } else if (pattern === 'water') {
        const wave = Math.sin(x * 0.6 + y * 0.4) * 20;
        b = Math.min(255, b + wave); g = Math.max(0, g + wave * 0.3);
      } else if (pattern === 'snow') {
        if ((x + y * 5) % 13 < 2) { r += 10; g += 10; b += 15; }
      } else if (pattern === 'fence') {
        if (x < 3 || x > 12 || (y > 5 && y < 10)) { /* keep */ } else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'door') {
        if (x === 0 || x === 15 || y === 0 || y === 15) { r -= 30; g -= 30; b -= 30; }
        if (x > 10 && x < 14 && y > 7 && y < 10) { r += 40; g += 30; b -= 10; }
      } else if (pattern === 'torch') {
        const cx = Math.abs(x - 8), cy = Math.abs(y - 4);
        if (cx < 2 && y > 4) { r = 0x6B; g = 0x4B; b = 0x2B; }
        else if (cx + cy < 4 && y < 8) { r = 0xFF; g = 0xAA + ((x * y) % 30); b = 0x20; }
        else { r = 0; g = 0; b = 0; }
      } else if (pattern === 'well') {
        if (y < 4) { r = 0x50; g = 0x50; b = 0x60; }
        else if (y > 11) { r = 0x50; g = 0x50; b = 0x60; }
        else if (x < 3 || x > 12) { r = 0x50; g = 0x50; b = 0x60; }
        else { r = 0x20; g = 0x50; b = 0xB0; }
      } else if (pattern === 'plaster') {
        const speckle = ((x * 13 + y * 7) % 11) - 5;
        r += speckle; g += speckle - 2; b += speckle - 5;
        if (y === 0 || y === 15) { r -= 20; g -= 20; b -= 15; }
        if (x === 0 || x === 15) { r -= 15; g -= 15; b -= 10; }
      } else if (pattern === 'thatch') {
        const strand = (x + y * 2) % 4;
        if (strand === 0) { r -= 20; g -= 15; b -= 10; }
        if ((x + y) % 7 === 0) { r += 15; g += 10; }
      } else if (pattern === 'glass') {
        const shine = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 20;
        r += shine; g += shine; b += shine * 0.5;
        if (x === 0 || x === 15 || y === 0 || y === 15) { r -= 40; g -= 30; b -= 20; }
      }
      data[i] = Math.max(0, Math.min(255, r));
      data[i + 1] = Math.max(0, Math.min(255, g));
      data[i + 2] = Math.max(0, Math.min(255, b));
    }
  }
  textures[id] = data;
}

function initTextures() {
  genTex(T.DIRT, 0x8B, 0x6B, 0x4B, 'noise');
  genTex(T.STONE, 0x80, 0x80, 0x80, 'cobble');
  genTex(T.IRON, 0x80, 0x70, 0x50, 'ore');
  genTex(T.GOLD, 0xB0, 0x90, 0x20, 'ore');
  genTex(T.CRYSTAL, 0x70, 0x30, 0xB0, 'crystal');
  genTex(T.WOOD, 0x6B, 0x4B, 0x2B, 'wood');
  genTex(T.LEAVES, 0x22, 0x7B, 0x22, 'leaves');
  genTex(T.SAND, 0xC2, 0xA4, 0x7C, 'noise');
  genTex(T.SNOW, 0xDD, 0xDD, 0xE8, 'snow');
  genTex(T.OBSIDIAN, 0x20, 0x10, 0x30, 'cobble');
  genTex(T.LAVA, 0xEE, 0x44, 0x00, 'lava');
  genTex(T.WOOD_WALL, 0x8B, 0x6B, 0x3B, 'plank');
  genTex(T.STONE_WALL, 0x70, 0x70, 0x70, 'cobble');
  genTex(T.FENCE, 0x9B, 0x7B, 0x4B, 'fence');
  genTex(T.DOOR, 0x6B, 0x4B, 0x1B, 'door');
  genTex(T.TORCH, 0xFF, 0xA5, 0x00, 'torch');
  genTex(T.WELL, 0x40, 0x60, 0x90, 'well');
  genTex(T.BRICK, 0xA0, 0x50, 0x30, 'brick');
  genTex(T.WATER, 0x20, 0x60, 0xC0, 'water');
  genTex(T.HOUSE_WALL, 0xE0, 0xD8, 0xC0, 'plaster');
  genTex(T.THATCH_ROOF, 0xAA, 0x88, 0x44, 'thatch');
  genTex(T.MARKET_STALL, 0xBB, 0x66, 0x22, 'plank');
  genTex(T.GLASS, 0x88, 0xCC, 0xEE, 'glass');
}

// ============================================================
// SEEDED RANDOM
// ============================================================
let seed = 12345;
function setSeed(s) { seed = s; }
function rng() {
  seed = (seed * 1103515245 + 12345) & 0x7fffffff;
  return (seed >> 16) / 32767;
}
function rngInt(min, max) { return Math.floor(rng() * (max - min + 1)) + min; }

// ============================================================
// WORLD GENERATION
// ============================================================
let worldMap = null;
let blockChanges = {}; // delta storage for save

function getBiome(x, y) {
  const cx = MAP_SIZE / 2, cy = MAP_SIZE / 2;
  const dx = x - cx, dy = y - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < MAP_SIZE * 0.12) return 'meadow';
  const angle = Math.atan2(dy, dx);
  if (angle > -0.5 && angle < 1.0) return 'desert';
  if (angle >= 1.0 || angle < -2.5) return 'jungle';
  if (angle >= -2.5 && angle < -1.5) return 'volcanic';
  return 'tundra';
}

let townPositions = []; // [{x,y,name}]

function generateWorld(worldSeed) {
  setSeed(worldSeed);
  worldMap = new Uint8Array(MAP_SIZE * MAP_SIZE);
  const half = MAP_SIZE / 2;

  // Fill with biome-appropriate terrain
  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const idx = y * MAP_SIZE + x;

      // Border walls
      if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) {
        worldMap[idx] = T.STONE; continue;
      }

      const biome = getBiome(x, y);
      const bd = BIOMES[biome];

      // Noise-based walls (scaled frequencies for larger map)
      const sx = x * 0.03, sy = y * 0.03;
      const n1 = Math.sin(sx * 5) * Math.cos(sy * 4) * 0.5;
      const n2 = Math.sin(sx * 2.7 + 42) * Math.cos(sy * 3 + 17) * 0.3;
      const n3 = Math.sin(sx * 7.3 + sy * 6) * 0.2;
      const density = n1 + n2 + n3;

      if (density > 0.25) {
        const oreRoll = rng();
        if (oreRoll < 0.02) worldMap[idx] = T.CRYSTAL;
        else if (oreRoll < 0.06) worldMap[idx] = bd.ore2;
        else if (oreRoll < 0.14) worldMap[idx] = bd.ore1;
        else worldMap[idx] = bd.wall;
      } else if (density > 0.15 && bd.tree && rng() < 0.08) {
        worldMap[idx] = rng() < 0.5 ? T.WOOD : T.LEAVES;
      } else {
        worldMap[idx] = T.AIR;
      }
    }
  }

  // Clear spawn area
  const spawnX = Math.floor(half), spawnY = Math.floor(half);
  for (let dy = -4; dy <= 4; dy++) {
    for (let dx = -4; dx <= 4; dx++) {
      worldMap[(spawnY + dy) * MAP_SIZE + (spawnX + dx)] = T.AIR;
    }
  }

  // Water pools (scattered across meadow)
  setSeed(worldSeed + 100);
  for (let i = 0; i < 40; i++) {
    const wx = rngInt(half - 200, half + 200);
    const wy = rngInt(half - 200, half + 200);
    if (getBiome(wx, wy) === 'meadow' && worldMap[wy * MAP_SIZE + wx] === T.AIR) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          if (Math.abs(dx) + Math.abs(dy) < 4) {
            const ni = (wy + dy) * MAP_SIZE + (wx + dx);
            if (ni >= 0 && ni < MAP_SIZE * MAP_SIZE && worldMap[ni] === T.AIR) worldMap[ni] = T.WATER;
          }
        }
      }
    }
  }

  // Lava in volcanic region
  setSeed(worldSeed + 200);
  for (let i = 0; i < 60; i++) {
    const lx = rngInt(50, half - 50);
    const ly = rngInt(half + 100, MAP_SIZE - 50);
    if (getBiome(lx, ly) === 'volcanic' && worldMap[ly * MAP_SIZE + lx] === T.AIR) {
      worldMap[ly * MAP_SIZE + lx] = T.LAVA;
      if (rng() < 0.5 && worldMap[(ly + 1) * MAP_SIZE + lx] === T.AIR) worldMap[(ly + 1) * MAP_SIZE + lx] = T.LAVA;
    }
  }

  // Generate towns
  generateTowns(worldSeed);

  // Apply saved block changes
  for (const key in blockChanges) {
    const [bx, by] = key.split(',').map(Number);
    if (by >= 0 && by < MAP_SIZE && bx >= 0 && bx < MAP_SIZE)
      worldMap[by * MAP_SIZE + bx] = blockChanges[key];
  }
}

function generateTowns(ws) {
  setSeed(ws + 777);
  townPositions = [];
  // Place towns spread across biomes
  const offsets = [
    {dx: 180, dy: 0},     // east (desert)
    {dx: 0, dy: 180},     // south (jungle)
    {dx: -180, dy: -120}, // northwest (tundra)
    {dx: -200, dy: 80},   // southwest (volcanic edge)
    {dx: 60, dy: -160},   // north-meadow border
  ];
  const half = MAP_SIZE / 2;
  for (let i = 0; i < TOWN_COUNT; i++) {
    const tx = Math.floor(half + offsets[i].dx + rngInt(-30, 30));
    const ty = Math.floor(half + offsets[i].dy + rngInt(-30, 30));
    const name = TOWN_NAMES[i];
    townPositions.push({x: tx, y: ty, name});
    buildTown(tx, ty);
  }
}

function buildTown(cx, cy) {
  const R = 12; // town radius
  // Clear area
  for (let dy = -R; dy <= R; dy++) {
    for (let dx = -R; dx <= R; dx++) {
      const x = cx + dx, y = cy + dy;
      if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1) {
        worldMap[y * MAP_SIZE + x] = T.AIR;
      }
    }
  }
  // Town perimeter wall with gaps
  for (let d = -R; d <= R; d++) {
    const positions = [
      {x: cx + d, y: cy - R}, {x: cx + d, y: cy + R},
      {x: cx - R, y: cy + d}, {x: cx + R, y: cy + d},
    ];
    for (const p of positions) {
      if (p.x > 0 && p.x < MAP_SIZE - 1 && p.y > 0 && p.y < MAP_SIZE - 1) {
        // Leave gaps for entrances
        if (Math.abs(p.x - cx) < 2 || Math.abs(p.y - cy) < 2) continue;
        worldMap[p.y * MAP_SIZE + p.x] = T.HOUSE_WALL;
      }
    }
  }
  // Central well
  if (cy > 0 && cy < MAP_SIZE - 1 && cx > 0 && cx < MAP_SIZE - 1)
    worldMap[cy * MAP_SIZE + cx] = T.WELL;
  // Small houses (3 houses at fixed offsets)
  const houses = [{dx: -6, dy: -6}, {dx: 5, dy: -5}, {dx: -4, dy: 5}];
  for (const h of houses) {
    const hx = cx + h.dx, hy = cy + h.dy;
    // 4x4 house shell
    for (let dy = 0; dy < 4; dy++) {
      for (let dx = 0; dx < 4; dx++) {
        const x = hx + dx, y = hy + dy;
        if (x <= 0 || x >= MAP_SIZE - 1 || y <= 0 || y >= MAP_SIZE - 1) continue;
        if (dy === 0 || dy === 3 || dx === 0 || dx === 3) {
          worldMap[y * MAP_SIZE + x] = T.HOUSE_WALL;
        }
      }
    }
    // Door
    const doorX = hx + 2, doorY = hy + 3;
    if (doorX > 0 && doorX < MAP_SIZE - 1 && doorY > 0 && doorY < MAP_SIZE - 1)
      worldMap[doorY * MAP_SIZE + doorX] = T.DOOR;
  }
  // Torches along paths
  const torchSpots = [{dx: -2, dy: 0}, {dx: 2, dy: 0}, {dx: 0, dy: -2}, {dx: 0, dy: 2},
    {dx: -5, dy: -2}, {dx: 5, dy: -2}, {dx: -3, dy: 4}, {dx: 4, dy: 3}];
  for (const ts of torchSpots) {
    const x = cx + ts.dx, y = cy + ts.dy;
    if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
      worldMap[y * MAP_SIZE + x] = T.TORCH;
  }
  // Market stalls
  const stalls = [{dx: 3, dy: 2}, {dx: -3, dy: 3}];
  for (const s of stalls) {
    const x = cx + s.dx, y = cy + s.dy;
    if (x > 0 && x < MAP_SIZE - 1 && y > 0 && y < MAP_SIZE - 1 && worldMap[y * MAP_SIZE + x] === T.AIR)
      worldMap[y * MAP_SIZE + x] = T.MARKET_STALL;
  }
}

function getBlock(x, y) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return T.STONE;
  return worldMap[y * MAP_SIZE + x];
}

function setBlock(x, y, val) {
  if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return;
  worldMap[y * MAP_SIZE + x] = val;
  blockChanges[x + ',' + y] = val;
}

// ============================================================
// GAME STATE
// ============================================================
let gameRunning = false;
let craftingOpen = false;

const player = {
  x: MAP_SIZE / 2 + 0.5,
  y: MAP_SIZE / 2 + 0.5,
  angle: 0,
  hp: 100,
  maxHp: 100,
  hunger: 100,
  maxHunger: 100,
  hotbar: new Array(8).fill(null),
  backpack: new Array(BACKPACK_SIZE).fill(null),
  selectedSlot: 0,
  miningTarget: null,
  miningProgress: 0,
  attackCooldown: 0,
  sprinting: false,
};

let creatures = [];
let npcs = []; // town NPCs
let minimapSize = 0;
let worldSeed = 12345;
let notifications = [];
let torchPositions = [];
let buildMode = false;
let backpackOpen = false;
let tradeOpen = false;
let tradeNPC = null; // currently trading NPC

// ---- INPUT ----
const keys = {};
let mouseDown = {left: false, right: false};
let mouseDX = 0;
let pointerLocked = false;

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (gameRunning && !craftingOpen && !backpackOpen && !tradeOpen) {
    if (e.code === 'KeyE') {
      // Check for nearby NPC first
      const nearNPC = findNearbyNPC();
      if (nearNPC) { openTrade(nearNPC); e.preventDefault(); return; }
      toggleCrafting(); e.preventDefault();
    }
    if (e.code === 'KeyM') { minimapSize = (minimapSize + 1) % 3; e.preventDefault(); }
    if (e.code === 'Tab') { toggleBackpack(); e.preventDefault(); }
    if (e.code === 'KeyB') { buildMode = !buildMode; notify(buildMode ? 'Build Mode ON — Right-click to place' : 'Build Mode OFF'); e.preventDefault(); }
    if (e.code >= 'Digit1' && e.code <= 'Digit8') {
      player.selectedSlot = parseInt(e.code[5]) - 1;
      e.preventDefault();
    }
  } else if (craftingOpen) {
    if (e.code === 'KeyE' || e.code === 'Escape') { toggleCrafting(); e.preventDefault(); }
  } else if (backpackOpen) {
    if (e.code === 'Tab' || e.code === 'Escape') { toggleBackpack(); e.preventDefault(); }
  } else if (tradeOpen) {
    if (e.code === 'KeyE' || e.code === 'Escape') { closeTrade(); e.preventDefault(); }
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

C.addEventListener('mousedown', e => {
  if (!pointerLocked && gameRunning && !craftingOpen) {
    C.requestPointerLock();
    return;
  }
  if (e.button === 0) mouseDown.left = true;
  if (e.button === 2) mouseDown.right = true;
});
C.addEventListener('mouseup', e => {
  if (e.button === 0) mouseDown.left = false;
  if (e.button === 2) mouseDown.right = false;
});
C.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('mousemove', e => {
  if (pointerLocked) mouseDX += e.movementX;
});
document.addEventListener('pointerlockchange', () => {
  pointerLocked = document.pointerLockElement === C;
  if (!pointerLocked && gameRunning && !craftingOpen) {
    // Lost pointer lock unexpectedly
  }
});

// ============================================================
// INVENTORY HELPERS
// ============================================================
function addItem(id, count) {
  if (!ITEMS[id]) return 0;
  const maxStack = ITEMS[id].stack || 64;
  let remaining = count;

  // Try to stack with existing hotbar
  for (let i = 0; i < 8 && remaining > 0; i++) {
    const slot = player.hotbar[i];
    if (slot && slot.id === id && slot.count < maxStack) {
      const add = Math.min(remaining, maxStack - slot.count);
      slot.count += add;
      remaining -= add;
    }
  }
  // Try empty hotbar slots
  for (let i = 0; i < 8 && remaining > 0; i++) {
    if (!player.hotbar[i]) {
      const add = Math.min(remaining, maxStack);
      player.hotbar[i] = { id, count: add };
      remaining -= add;
    }
  }
  // Overflow to backpack - stack first
  for (let i = 0; i < BACKPACK_SIZE && remaining > 0; i++) {
    const slot = player.backpack[i];
    if (slot && slot.id === id && slot.count < maxStack) {
      const add = Math.min(remaining, maxStack - slot.count);
      slot.count += add;
      remaining -= add;
    }
  }
  // Overflow to backpack - empty slots
  for (let i = 0; i < BACKPACK_SIZE && remaining > 0; i++) {
    if (!player.backpack[i]) {
      const add = Math.min(remaining, maxStack);
      player.backpack[i] = { id, count: add };
      remaining -= add;
    }
  }
  return count - remaining;
}

function removeItem(id, count) {
  let remaining = count;
  for (let i = 7; i >= 0 && remaining > 0; i--) {
    const slot = player.hotbar[i];
    if (slot && slot.id === id) {
      const take = Math.min(remaining, slot.count);
      slot.count -= take;
      remaining -= take;
      if (slot.count <= 0) player.hotbar[i] = null;
    }
  }
  // Also take from backpack
  for (let i = BACKPACK_SIZE - 1; i >= 0 && remaining > 0; i--) {
    const slot = player.backpack[i];
    if (slot && slot.id === id) {
      const take = Math.min(remaining, slot.count);
      slot.count -= take;
      remaining -= take;
      if (slot.count <= 0) player.backpack[i] = null;
    }
  }
  return remaining === 0;
}

function countItem(id) {
  let total = 0;
  for (let i = 0; i < 8; i++) {
    if (player.hotbar[i] && player.hotbar[i].id === id) total += player.hotbar[i].count;
  }
  for (let i = 0; i < BACKPACK_SIZE; i++) {
    if (player.backpack[i] && player.backpack[i].id === id) total += player.backpack[i].count;
  }
  return total;
}

function getHeldItem() {
  const slot = player.hotbar[player.selectedSlot];
  if (!slot) return null;
  return ITEMS[slot.id];
}

function getHeldItemId() {
  const slot = player.hotbar[player.selectedSlot];
  return slot ? slot.id : null;
}

function getPickaxeTier() {
  for (let i = 0; i < 8; i++) {
    const slot = player.hotbar[i];
    if (slot) {
      const item = ITEMS[slot.id];
      if (item && item.tool === 'pickaxe') return item.tier;
    }
  }
  return 0; // bare hands
}

function getSwordDmg() {
  const held = getHeldItem();
  if (held && held.tool === 'sword') return held.dmg;
  return 3; // fist damage
}

function notify(msg) {
  notifications.push({ msg, time: 3.0 });
  if (notifications.length > 5) notifications.shift();
}

// ============================================================
// CRAFTING
// ============================================================
function toggleCrafting() {
  craftingOpen = !craftingOpen;
  const menu = document.getElementById('crafting-menu');
  menu.style.display = craftingOpen ? 'block' : 'none';
  if (craftingOpen) {
    document.exitPointerLock();
    renderCraftingMenu();
  } else {
    if (gameRunning) C.requestPointerLock();
  }
}

function canCraft(recipe) {
  for (const [itemId, need] of Object.entries(recipe.cost)) {
    if (countItem(itemId) < need) return false;
  }
  return true;
}

function doCraft(idx) {
  const recipe = RECIPES[idx];
  if (!canCraft(recipe)) return;
  for (const [itemId, need] of Object.entries(recipe.cost)) {
    removeItem(itemId, need);
  }
  const added = addItem(recipe.result, recipe.amt);
  if (added > 0) notify('Crafted ' + ITEMS[recipe.result].name + (recipe.amt > 1 ? ' x' + recipe.amt : ''));
  renderCraftingMenu();
}

function renderCraftingMenu() {
  const list = document.getElementById('recipe-list');
  let html = '';
  let lastCat = '';
  RECIPES.forEach((r, i) => {
    if (r.cat !== lastCat) {
      html += `<div style="color:#888;font-size:11px;text-transform:uppercase;letter-spacing:1px;margin:10px 0 6px;padding-top:6px;border-top:1px solid #333;">${r.cat}</div>`;
      lastCat = r.cat;
    }
    const can = canCraft(r);
    const costStr = Object.entries(r.cost).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    html += `<div class="recipe-row">
      <span class="recipe-name">${ITEMS[r.result].name}${r.amt > 1 ? ' x' + r.amt : ''}</span>
      <span class="recipe-cost">${costStr}</span>
      <button class="recipe-craft ${can ? '' : 'cannot'}" onclick="doCraft(${i})">${can ? 'Craft' : 'Need'}</button>
    </div>`;
  });
  list.innerHTML = html;
}

// ============================================================
// BACKPACK UI
// ============================================================
function toggleBackpack() {
  backpackOpen = !backpackOpen;
  const menu = document.getElementById('backpack-menu');
  menu.style.display = backpackOpen ? 'block' : 'none';
  if (backpackOpen) {
    document.exitPointerLock();
    renderBackpackMenu();
  } else {
    if (gameRunning) C.requestPointerLock();
  }
}

function renderBackpackMenu() {
  const el = document.getElementById('backpack-slots');
  let html = '<div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-bottom:14px;">';
  // Hotbar
  html += '<div style="width:100%;color:#e8a030;font-size:12px;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px;">Hotbar</div>';
  for (let i = 0; i < 8; i++) {
    const slot = player.hotbar[i];
    const sel = i === player.selectedSlot ? 'border-color:#e8a030;' : '';
    html += `<div class="bp-slot" style="${sel}" onclick="bpClickHotbar(${i})">`;
    if (slot) {
      const item = ITEMS[slot.id];
      html += `<div style="width:28px;height:28px;background:${item.color};border-radius:3px;margin:2px auto;"></div>`;
      html += `<div style="font-size:9px;color:#ccc;">${item.name}</div>`;
      if (slot.count > 1) html += `<div style="font-size:9px;color:#aaa;">x${slot.count}</div>`;
    }
    html += '</div>';
  }
  // Backpack
  html += `<div style="width:100%;color:#44aaff;font-size:12px;text-transform:uppercase;letter-spacing:1px;margin:10px 0 4px;">Backpack (${BACKPACK_SIZE} slots)</div>`;
  for (let i = 0; i < BACKPACK_SIZE; i++) {
    const slot = player.backpack[i];
    html += `<div class="bp-slot" onclick="bpClickBackpack(${i})">`;
    if (slot) {
      const item = ITEMS[slot.id];
      html += `<div style="width:28px;height:28px;background:${item.color};border-radius:3px;margin:2px auto;"></div>`;
      html += `<div style="font-size:9px;color:#ccc;">${item.name}</div>`;
      if (slot.count > 1) html += `<div style="font-size:9px;color:#aaa;">x${slot.count}</div>`;
    }
    html += '</div>';
  }
  html += '</div>';
  el.innerHTML = html;
}

function bpClickHotbar(i) {
  // Move hotbar item to first empty backpack slot
  if (!player.hotbar[i]) return;
  for (let j = 0; j < BACKPACK_SIZE; j++) {
    if (!player.backpack[j]) {
      player.backpack[j] = player.hotbar[i];
      player.hotbar[i] = null;
      renderBackpackMenu();
      return;
    }
  }
  notify('Backpack full!');
}

function bpClickBackpack(i) {
  // Move backpack item to first empty hotbar slot
  if (!player.backpack[i]) return;
  for (let j = 0; j < 8; j++) {
    if (!player.hotbar[j]) {
      player.hotbar[j] = player.backpack[i];
      player.backpack[i] = null;
      renderBackpackMenu();
      return;
    }
  }
  notify('Hotbar full!');
}

// ============================================================
// NPC SYSTEM
// ============================================================
function spawnNPCs() {
  npcs = [];
  const npcTypes = Object.keys(NPC_TYPES);
  for (const town of townPositions) {
    // 3 NPCs per town
    for (let i = 0; i < 3; i++) {
      const typeId = npcTypes[i % npcTypes.length];
      const offsetX = (i - 1) * 4;
      const offsetY = (i === 1) ? 3 : -1;
      npcs.push({
        type: typeId,
        x: town.x + offsetX + 0.5,
        y: town.y + offsetY + 0.5,
        town: town.name,
        angle: 0,
      });
    }
  }
}

function findNearbyNPC() {
  for (const n of npcs) {
    const dx = n.x - player.x, dy = n.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return n;
  }
  return null;
}

// ============================================================
// TRADE SYSTEM
// ============================================================
function openTrade(npc) {
  tradeOpen = true;
  tradeNPC = npc;
  document.exitPointerLock();
  const menu = document.getElementById('trade-menu');
  menu.style.display = 'block';
  renderTradeMenu();
}

function closeTrade() {
  tradeOpen = false;
  tradeNPC = null;
  document.getElementById('trade-menu').style.display = 'none';
  if (gameRunning) C.requestPointerLock();
}

function renderTradeMenu() {
  if (!tradeNPC) return;
  const nt = NPC_TYPES[tradeNPC.type];
  const el = document.getElementById('trade-list');
  let html = `<div style="color:#e8a030;font-size:16px;font-weight:700;text-align:center;margin-bottom:4px;">${nt.name} — ${tradeNPC.town}</div>`;
  html += `<div style="color:#888;font-size:11px;text-align:center;margin-bottom:12px;">Gold Coins: ${countItem('gold_coin')}</div>`;
  nt.trades.forEach((t, i) => {
    const giveStr = Object.entries(t.give).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    const getStr = Object.entries(t.get).map(([id, n]) => `${ITEMS[id].name} x${n}`).join(', ');
    let canTrade = true;
    for (const [id, n] of Object.entries(t.give)) { if (countItem(id) < n) canTrade = false; }
    html += `<div class="recipe-row">
      <span class="recipe-cost" style="color:#ff8888;">${giveStr}</span>
      <span style="color:#666;margin:0 8px;">→</span>
      <span class="recipe-cost" style="color:#88ff88;">${getStr}</span>
      <button class="recipe-craft ${canTrade ? '' : 'cannot'}" onclick="doTrade(${i})">${canTrade ? 'Trade' : 'Need'}</button>
    </div>`;
  });
  el.innerHTML = html;
}

function doTrade(idx) {
  if (!tradeNPC) return;
  const nt = NPC_TYPES[tradeNPC.type];
  const t = nt.trades[idx];
  for (const [id, n] of Object.entries(t.give)) { if (countItem(id) < n) return; }
  for (const [id, n] of Object.entries(t.give)) { removeItem(id, n); }
  for (const [id, n] of Object.entries(t.get)) { addItem(id, n); }
  notify('Traded!');
  renderTradeMenu();
}

// ============================================================
// CREATURES
// ============================================================
function spawnCreatures() {
  creatures = [];
  setSeed(worldSeed + 500);
  let spawned = 0;
  const types = Object.keys(CREATURE_TYPES);
  let attempts = 0;
  while (spawned < MAX_CREATURES && attempts < 20000) {
    attempts++;
    const typeId = types[rngInt(0, types.length - 1)];
    const ct = CREATURE_TYPES[typeId];
    const x = rngInt(3, MAP_SIZE - 4) + 0.5;
    const y = rngInt(3, MAP_SIZE - 4) + 0.5;
    // Skip town areas
    let inTown = false;
    for (const t of townPositions) { if (Math.abs(x - t.x) < 15 && Math.abs(y - t.y) < 15) { inTown = true; break; } }
    if (inTown) continue;
    const biome = getBiome(Math.floor(x), Math.floor(y));
    if (biome !== ct.biome) continue;
    if (getBlock(Math.floor(x), Math.floor(y)) !== T.AIR) continue;
    creatures.push({
      type: typeId,
      x, y,
      hp: ct.hp,
      maxHp: ct.hp,
      angle: rng() * Math.PI * 2,
      state: 'idle', // idle, chase, flee, follow
      tamed: false,
      stateTimer: rng() * 3,
      knockback: 0,
      kbAngle: 0,
      attackTimer: 0,
    });
    spawned++;
  }
}

function updateCreatures(dt) {
  for (let i = creatures.length - 1; i >= 0; i--) {
    const c = creatures[i];
    const ct = CREATURE_TYPES[c.type];
    const dx = player.x - c.x;
    const dy = player.y - c.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angleToPlayer = Math.atan2(dy, dx);

    // Knockback
    if (c.knockback > 0) {
      const kbSpeed = c.knockback * 5 * dt;
      const nx = c.x + Math.cos(c.kbAngle) * kbSpeed;
      const ny = c.y + Math.sin(c.kbAngle) * kbSpeed;
      if (getBlock(Math.floor(nx), Math.floor(ny)) === T.AIR) {
        c.x = nx; c.y = ny;
      }
      c.knockback = Math.max(0, c.knockback - dt * 4);
    }

    c.attackTimer = Math.max(0, c.attackTimer - dt);
    c.stateTimer -= dt;

    if (c.tamed) {
      // Follow player
      if (dist > 3) {
        c.x += Math.cos(angleToPlayer) * ct.speed * dt;
        c.y += Math.sin(angleToPlayer) * ct.speed * dt;
      }
      c.angle = angleToPlayer;
      // Attack nearby hostile creatures
      for (let j = 0; j < creatures.length; j++) {
        if (j === i) continue;
        const other = creatures[j];
        if (other.tamed || !CREATURE_TYPES[other.type].hostile) continue;
        const odx = other.x - c.x, ody = other.y - c.y;
        const odist = Math.sqrt(odx * odx + ody * ody);
        if (odist < 2 && c.attackTimer <= 0) {
          other.hp -= Math.floor(ct.dmg * 0.6) || 3;
          c.attackTimer = 1.0;
          if (other.hp <= 0) {
            const drop = CREATURE_TYPES[other.type].drop;
            if (drop) addItem(drop, 1);
            notify('Your ' + ct.name + ' killed a ' + CREATURE_TYPES[other.type].name + '!');
            creatures.splice(j, 1);
            if (j < i) i--;
          }
          break;
        }
      }
      continue;
    }

    // AI state machine
    if (ct.hostile && dist < 8) {
      c.state = 'chase';
    } else if (!ct.hostile && dist < 4) {
      c.state = 'flee';
      c.stateTimer = 2;
    } else if (c.stateTimer <= 0) {
      c.state = 'idle';
      c.angle += (rng() - 0.5) * 2;
      c.stateTimer = 1 + rng() * 3;
    }

    let speed = 0;
    if (c.state === 'chase') {
      c.angle = angleToPlayer;
      speed = ct.speed;
      // Attack player
      if (dist < 1.5 && c.attackTimer <= 0) {
        player.hp -= ct.dmg;
        c.attackTimer = 1.2;
        if (player.hp <= 0) playerDeath();
      }
    } else if (c.state === 'flee') {
      c.angle = angleToPlayer + Math.PI;
      speed = ct.speed;
    } else if (c.state === 'idle') {
      speed = ct.speed * 0.2;
    }

    if (speed > 0) {
      const nx = c.x + Math.cos(c.angle) * speed * dt;
      const ny = c.y + Math.sin(c.angle) * speed * dt;
      const bx = Math.floor(nx), by = Math.floor(ny);
      if (bx > 0 && bx < MAP_SIZE - 1 && by > 0 && by < MAP_SIZE - 1 && getBlock(bx, by) === T.AIR) {
        c.x = nx;
        c.y = ny;
      } else {
        c.angle += Math.PI * 0.5; // turn on wall hit
      }
    }
  }
}

// ============================================================
// RAYCASTING RENDERER
// ============================================================
const zBuffer = new Float64Array(W);
const columnBuf = ctx.createImageData(1, H);

function castRay(px, py, angle) {
  const dirX = Math.cos(angle), dirY = Math.sin(angle);
  let mapX = Math.floor(px), mapY = Math.floor(py);
  const deltaDistX = Math.abs(1 / dirX), deltaDistY = Math.abs(1 / dirY);
  let stepX, stepY, sideDistX, sideDistY;

  if (dirX < 0) { stepX = -1; sideDistX = (px - mapX) * deltaDistX; }
  else { stepX = 1; sideDistX = (mapX + 1 - px) * deltaDistX; }
  if (dirY < 0) { stepY = -1; sideDistY = (py - mapY) * deltaDistY; }
  else { stepY = 1; sideDistY = (mapY + 1 - py) * deltaDistY; }

  let side = 0;
  for (let i = 0; i < 64; i++) {
    if (sideDistX < sideDistY) {
      sideDistX += deltaDistX;
      mapX += stepX;
      side = 0;
    } else {
      sideDistY += deltaDistY;
      mapY += stepY;
      side = 1;
    }
    const block = getBlock(mapX, mapY);
    if (block !== T.AIR) {
      let dist;
      if (side === 0) dist = sideDistX - deltaDistX;
      else dist = sideDistY - deltaDistY;
      // Calculate wall X (texture coordinate)
      let wallX;
      if (side === 0) wallX = py + dist * dirY;
      else wallX = px + dist * dirX;
      wallX -= Math.floor(wallX);
      return { dist, side, block, mapX, mapY, wallX };
    }
  }
  return { dist: 64, side: 0, block: T.AIR, mapX, mapY, wallX: 0 };
}

function renderScene() {
  const fov = Math.PI / 3; // 60 degrees
  const halfH = H / 2;
  const biome = getBiome(Math.floor(player.x), Math.floor(player.y));
  const bd = BIOMES[biome];

  // Draw sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, halfH);
  skyGrad.addColorStop(0, bd.sky1);
  skyGrad.addColorStop(1, bd.sky2);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, halfH);

  // Draw floor gradient
  const flrGrad = ctx.createLinearGradient(0, halfH, 0, H);
  const gc = bd.ground;
  flrGrad.addColorStop(0, `rgb(${gc[0] >> 1},${gc[1] >> 1},${gc[2] >> 1})`);
  flrGrad.addColorStop(1, `rgb(${gc[0]},${gc[1]},${gc[2]})`);
  ctx.fillStyle = flrGrad;
  ctx.fillRect(0, halfH, W, halfH);

  // Raycast walls
  const imgData = ctx.getImageData(0, 0, W, H);
  const pixels = imgData.data;

  for (let col = 0; col < W; col++) {
    const rayAngle = player.angle + (col / W - 0.5) * fov;
    const hit = castRay(player.x, player.y, rayAngle);
    const perpDist = hit.dist * Math.cos(rayAngle - player.angle); // fisheye correction
    zBuffer[col] = perpDist;

    if (hit.block === T.AIR) continue;

    const lineHeight = Math.floor(H / perpDist);
    const drawStart = Math.max(0, Math.floor(halfH - lineHeight / 2));
    const drawEnd = Math.min(H - 1, Math.floor(halfH + lineHeight / 2));

    const tex = textures[hit.block];
    const texX = Math.floor(hit.wallX * TEX_SIZE) & (TEX_SIZE - 1);
    const shade = hit.side ? 0.7 : 1.0;
    const distShade = Math.max(0.15, 1.0 - perpDist / 20);
    const finalShade = shade * distShade;

    // Check for nearby torches for extra lighting
    let torchLight = 0;
    for (const tp of torchPositions) {
      const td = Math.sqrt((hit.mapX - tp[0]) ** 2 + (hit.mapY - tp[1]) ** 2);
      if (td < 6) torchLight = Math.max(torchLight, (1 - td / 6) * 0.5);
    }

    for (let y = drawStart; y <= drawEnd; y++) {
      const texY = Math.floor((y - (halfH - lineHeight / 2)) / lineHeight * TEX_SIZE) & (TEX_SIZE - 1);
      const ti = (texY * TEX_SIZE + texX) * 3;
      const pi = (y * W + col) * 4;
      const s = Math.min(1, finalShade + torchLight);

      if (tex) {
        pixels[pi] = Math.floor(tex[ti] * s);
        pixels[pi + 1] = Math.floor(tex[ti + 1] * s);
        pixels[pi + 2] = Math.floor(tex[ti + 2] * s);
      } else {
        const info = TILE_INFO[hit.block];
        const c = info ? info.color : [128, 128, 128];
        pixels[pi] = Math.floor(c[0] * s);
        pixels[pi + 1] = Math.floor(c[1] * s);
        pixels[pi + 2] = Math.floor(c[2] * s);
      }
      pixels[pi + 3] = 255;
    }
  }

  ctx.putImageData(imgData, 0, 0);
}

// ============================================================
// BILLBOARD SPRITE RENDERING (creatures)
// ============================================================
function renderCreatures() {
  // Sort by distance (far first)
  const spriteList = creatures.map(c => {
    const dx = c.x - player.x, dy = c.y - player.y;
    return { creature: c, dist: Math.sqrt(dx * dx + dy * dy), dx, dy };
  }).sort((a, b) => b.dist - a.dist);

  const fov = Math.PI / 3;
  const halfH = H / 2;

  for (const s of spriteList) {
    const { creature: c, dist, dx, dy } = s;
    if (dist < 0.3 || dist > 30) continue;

    const ct = CREATURE_TYPES[c.type];

    // Angle relative to player view
    const spriteAngle = Math.atan2(dy, dx) - player.angle;
    // Normalize to -PI..PI
    let normAngle = spriteAngle;
    while (normAngle > Math.PI) normAngle -= Math.PI * 2;
    while (normAngle < -Math.PI) normAngle += Math.PI * 2;

    // Skip if behind
    if (Math.abs(normAngle) > fov * 0.7) continue;

    const screenX = Math.floor(W / 2 + (normAngle / fov) * W);
    const spriteHeight = Math.floor((H / dist) * ct.size);
    const spriteWidth = Math.floor(spriteHeight * 0.8);
    const drawY = Math.floor(halfH - spriteHeight / 2 + (1 - ct.size) * (H / dist) * 0.3);

    const startX = Math.max(0, screenX - spriteWidth / 2);
    const endX = Math.min(W - 1, screenX + spriteWidth / 2);

    // Z-buffer check per column
    let visible = false;
    for (let x = Math.floor(startX); x <= Math.floor(endX); x++) {
      if (x >= 0 && x < W && dist < zBuffer[x]) { visible = true; break; }
    }
    if (!visible) continue;

    // Parse color
    const col = ct.color;
    const r = parseInt(col.slice(1, 3), 16);
    const g = parseInt(col.slice(3, 5), 16);
    const b = parseInt(col.slice(5, 7), 16);

    const distShade = Math.max(0.2, 1.0 - dist / 20);

    // Draw sprite as filled rectangle with detail
    ctx.save();
    for (let x = Math.floor(startX); x <= Math.floor(endX); x++) {
      if (x < 0 || x >= W || dist >= zBuffer[x]) continue;
      const relX = (x - (screenX - spriteWidth / 2)) / spriteWidth;

      // Body shape: narrower at top and bottom
      const bodyTop = drawY + spriteHeight * 0.1;
      const bodyBot = drawY + spriteHeight;
      const headTop = drawY;
      const headBot = drawY + spriteHeight * 0.25;
      const headWidth = 0.4;

      // Head
      if (Math.abs(relX - 0.5) < headWidth / 2) {
        const ht = Math.floor(headTop);
        const hb = Math.floor(headBot);
        for (let y = Math.max(0, ht); y < Math.min(H, hb); y++) {
          if (y >= 0 && y < H) {
            ctx.fillStyle = `rgb(${Math.floor(r * distShade * 1.1)},${Math.floor(g * distShade * 1.1)},${Math.floor(b * distShade * 1.1)})`;
            ctx.fillRect(x, y, 1, 1);
          }
        }
        // Eyes
        if (spriteHeight > 20) {
          const eyeY = Math.floor(headTop + (headBot - headTop) * 0.4);
          if (Math.abs(relX - 0.4) < 0.05 || Math.abs(relX - 0.6) < 0.05) {
            ctx.fillStyle = '#000';
            ctx.fillRect(x, eyeY, 1, Math.max(1, spriteHeight * 0.05));
          }
        }
      }

      // Body
      const bodyNarrow = Math.abs(relX - 0.5) < 0.35 ? 1 : 0;
      if (bodyNarrow) {
        const bt = Math.floor(headBot);
        const bb = Math.floor(bodyBot);
        for (let y = Math.max(0, bt); y < Math.min(H, bb); y++) {
          const shade = 0.8 + 0.2 * ((y - bt) / (bb - bt));
          ctx.fillStyle = `rgb(${Math.floor(r * distShade * shade)},${Math.floor(g * distShade * shade)},${Math.floor(b * distShade * shade)})`;
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }

    // Draw HP bar if damaged
    if (c.hp < c.maxHp) {
      const barW = spriteWidth;
      const barH = 3;
      const barX = screenX - barW / 2;
      const barY = drawY - 6;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = c.tamed ? '#44FF44' : '#FF4444';
      ctx.fillRect(barX, barY, barW * (c.hp / c.maxHp), barH);
    }

    // Tamed indicator
    if (c.tamed) {
      ctx.fillStyle = '#44FF44';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(ct.name, screenX, drawY - 10);
    }

    ctx.restore();
  }
}

// ============================================================
// NPC BILLBOARD RENDERING
// ============================================================
function renderNPCs() {
  const fov = Math.PI / 3;
  const halfH = H / 2;
  for (const n of npcs) {
    const dx = n.x - player.x, dy = n.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 0.3 || dist > 30) continue;
    const nt = NPC_TYPES[n.type];
    let normAngle = Math.atan2(dy, dx) - player.angle;
    while (normAngle > Math.PI) normAngle -= Math.PI * 2;
    while (normAngle < -Math.PI) normAngle += Math.PI * 2;
    if (Math.abs(normAngle) > fov * 0.7) continue;
    const screenX = Math.floor(W / 2 + (normAngle / fov) * W);
    const spriteHeight = Math.floor((H / dist) * nt.size);
    const spriteWidth = Math.floor(spriteHeight * 0.6);
    const drawY = Math.floor(halfH - spriteHeight / 2 + (1 - nt.size) * (H / dist) * 0.3);
    const distShade = Math.max(0.2, 1.0 - dist / 20);
    const col = nt.color;
    const r = parseInt(col.slice(1, 3), 16);
    const g = parseInt(col.slice(3, 5), 16);
    const b = parseInt(col.slice(5, 7), 16);
    // Check z-buffer
    let visible = false;
    for (let x = Math.max(0, screenX - spriteWidth / 2); x <= Math.min(W - 1, screenX + spriteWidth / 2); x++) {
      if (dist < zBuffer[Math.floor(x)]) { visible = true; break; }
    }
    if (!visible) continue;
    // Draw body
    ctx.fillStyle = `rgb(${Math.floor(r * distShade)},${Math.floor(g * distShade)},${Math.floor(b * distShade)})`;
    const bodyX = screenX - spriteWidth / 2;
    ctx.fillRect(bodyX, drawY + spriteHeight * 0.25, spriteWidth, spriteHeight * 0.75);
    // Head
    ctx.fillStyle = `rgb(${Math.floor(0xDD * distShade)},${Math.floor(0xBB * distShade)},${Math.floor(0x99 * distShade)})`;
    ctx.beginPath();
    ctx.arc(screenX, drawY + spriteHeight * 0.15, spriteWidth * 0.35, 0, Math.PI * 2);
    ctx.fill();
    // Name label
    ctx.fillStyle = '#FFDD44';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(nt.name, screenX, drawY - 6);
    // E prompt if close
    if (dist < 3) {
      ctx.fillStyle = '#44FF44';
      ctx.font = 'bold 12px sans-serif';
      ctx.fillText('[E] Trade', screenX, drawY - 18);
    }
  }
}

// ============================================================
// HUD RENDERING
// ============================================================
function renderHUD() {
  // Crosshair
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 10, H / 2); ctx.lineTo(W / 2 - 4, H / 2);
  ctx.moveTo(W / 2 + 4, H / 2); ctx.lineTo(W / 2 + 10, H / 2);
  ctx.moveTo(W / 2, H / 2 - 10); ctx.lineTo(W / 2, H / 2 - 4);
  ctx.moveTo(W / 2, H / 2 + 4); ctx.lineTo(W / 2, H / 2 + 10);
  ctx.stroke();

  // Hotbar
  const slotSize = 48;
  const hotbarW = slotSize * 8 + 16;
  const hotbarX = (W - hotbarW) / 2;
  const hotbarY = H - slotSize - 12;

  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(hotbarX - 4, hotbarY - 4, hotbarW + 8, slotSize + 8);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;

  for (let i = 0; i < 8; i++) {
    const sx = hotbarX + i * (slotSize + 2);
    // Slot background
    ctx.fillStyle = i === player.selectedSlot ? 'rgba(232,160,48,0.3)' : 'rgba(30,30,50,0.8)';
    ctx.fillRect(sx, hotbarY, slotSize, slotSize);
    ctx.strokeStyle = i === player.selectedSlot ? '#e8a030' : '#444';
    ctx.lineWidth = i === player.selectedSlot ? 2 : 1;
    ctx.strokeRect(sx, hotbarY, slotSize, slotSize);

    const slot = player.hotbar[i];
    if (slot) {
      const item = ITEMS[slot.id];
      // Item color block
      ctx.fillStyle = item.color;
      ctx.fillRect(sx + 8, hotbarY + 6, slotSize - 16, slotSize - 20);

      // Item count
      if (slot.count > 1) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(slot.count, sx + slotSize - 4, hotbarY + slotSize - 4);
      }

      // Item name (small)
      ctx.fillStyle = '#ccc';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(item.name, sx + slotSize / 2, hotbarY + slotSize - 2);
    }

    // Slot number
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(i + 1, sx + 3, hotbarY + 11);
  }

  // HP bar
  const barW = 180, barH = 14;
  const hpX = 12, hpY = 12;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(hpX - 2, hpY - 2, barW + 4, barH + 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(hpX, hpY, barW, barH);
  const hpPct = Math.max(0, player.hp / player.maxHp);
  ctx.fillStyle = hpPct > 0.3 ? '#44CC44' : '#FF4444';
  ctx.fillRect(hpX, hpY, barW * hpPct, barH);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`HP ${Math.ceil(player.hp)}/${player.maxHp}`, hpX + barW / 2, hpY + 11);

  // Hunger bar
  const hunY = hpY + barH + 6;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(hpX - 2, hunY - 2, barW + 4, barH + 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(hpX, hunY, barW, barH);
  const hunPct = Math.max(0, player.hunger / player.maxHunger);
  ctx.fillStyle = hunPct > 0.3 ? '#CC8822' : '#FF4444';
  ctx.fillRect(hpX, hunY, barW * hunPct, barH);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Hunger ${Math.ceil(player.hunger)}/${player.maxHunger}`, hpX + barW / 2, hunY + 11);

  // Biome indicator
  const biome = getBiome(Math.floor(player.x), Math.floor(player.y));
  ctx.fillStyle = '#aaa';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(BIOMES[biome].name, W - 12, 24);

  // Town name if nearby
  for (const t of townPositions) {
    if (Math.abs(player.x - t.x) < 15 && Math.abs(player.y - t.y) < 15) {
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(t.name, W / 2, 24);
      break;
    }
  }

  // Build mode indicator
  if (buildMode) {
    ctx.fillStyle = 'rgba(232,160,48,0.8)';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('BUILD MODE [B]', 12, H - 80);
    // Show ghost preview info
    const held2 = getHeldItem();
    if (held2 && held2.placeTile) {
      ctx.fillStyle = '#ccc';
      ctx.font = '11px sans-serif';
      ctx.fillText('Right-click to place: ' + held2.name, 12, H - 65);
    }
  }

  // Sprint indicator
  if (player.sprinting) {
    ctx.fillStyle = '#44FF44';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('SPRINTING', 12, hunY + barH + 18);
  }

  // Currently held item info
  const held = getHeldItem();
  if (held) {
    ctx.fillStyle = '#ddd';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(held.name, W / 2, hotbarY - 8);
  }

  // Mining progress
  if (player.miningTarget) {
    const progW = 100, progH = 8;
    const progX = W / 2 - progW / 2, progY = H / 2 + 30;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(progX - 1, progY - 1, progW + 2, progH + 2);
    ctx.fillStyle = '#333';
    ctx.fillRect(progX, progY, progW, progH);
    ctx.fillStyle = '#e8a030';
    ctx.fillRect(progX, progY, progW * player.miningProgress, progH);
  }

  // Notifications
  for (let i = 0; i < notifications.length; i++) {
    const n = notifications[i];
    const alpha = Math.min(1, n.time);
    ctx.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(n.msg, W / 2, H / 2 - 60 - i * 18);
  }

  // Minimap
  if (minimapSize > 0) {
    renderMinimap();
  }
}

function renderMinimap() {
  const size = minimapSize === 1 ? 120 : 200;
  const viewRadius = minimapSize === 1 ? 60 : 120; // tiles visible on minimap
  const mx = W - size - 10, my = 40;
  const scale = size / (viewRadius * 2);
  const startX = Math.floor(player.x - viewRadius);
  const startY = Math.floor(player.y - viewRadius);

  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(mx - 2, my - 2, size + 4, size + 4);

  // Draw local area around player (not entire map)
  const step = Math.max(1, Math.floor(1 / scale));
  for (let ty = 0; ty < viewRadius * 2; ty += step) {
    for (let tx = 0; tx < viewRadius * 2; tx += step) {
      const wx = startX + tx, wy = startY + ty;
      if (wx < 0 || wx >= MAP_SIZE || wy < 0 || wy >= MAP_SIZE) continue;
      const block = getBlock(wx, wy);
      if (block === T.AIR) {
        const b = getBiome(wx, wy);
        const gc = BIOMES[b].ground;
        ctx.fillStyle = `rgb(${gc[0] >> 1},${gc[1] >> 1},${gc[2] >> 1})`;
      } else {
        const info = TILE_INFO[block];
        if (info) {
          ctx.fillStyle = `rgb(${info.color[0]},${info.color[1]},${info.color[2]})`;
        } else {
          ctx.fillStyle = '#888';
        }
      }
      ctx.fillRect(mx + tx * scale, my + ty * scale, Math.ceil(scale * step), Math.ceil(scale * step));
    }
  }

  // Nearby creatures
  for (const c of creatures) {
    const rx = c.x - startX, ry = c.y - startY;
    if (rx < 0 || rx >= viewRadius * 2 || ry < 0 || ry >= viewRadius * 2) continue;
    ctx.fillStyle = c.tamed ? '#44FF44' : (CREATURE_TYPES[c.type].hostile ? '#FF4444' : '#FFFF44');
    ctx.fillRect(mx + rx * scale - 1, my + ry * scale - 1, 2, 2);
  }

  // Nearby NPCs
  for (const n of npcs) {
    const rx = n.x - startX, ry = n.y - startY;
    if (rx < 0 || rx >= viewRadius * 2 || ry < 0 || ry >= viewRadius * 2) continue;
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(mx + rx * scale - 1, my + ry * scale - 1, 3, 3);
  }

  // Town markers
  for (const t of townPositions) {
    const rx = t.x - startX, ry = t.y - startY;
    if (rx < -10 || rx >= viewRadius * 2 + 10 || ry < -10 || ry >= viewRadius * 2 + 10) continue;
    ctx.fillStyle = '#FFD700';
    ctx.font = '8px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(t.name, mx + rx * scale, my + ry * scale - 4);
  }

  // Player (always center)
  ctx.fillStyle = '#00FFFF';
  ctx.fillRect(mx + size / 2 - 2, my + size / 2 - 2, 4, 4);

  // Player direction line
  ctx.strokeStyle = '#00FFFF';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(mx + size / 2, my + size / 2);
  ctx.lineTo(mx + size / 2 + Math.cos(player.angle) * 12,
             my + size / 2 + Math.sin(player.angle) * 12);
  ctx.stroke();

  // Coordinates
  ctx.fillStyle = '#888';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(`${Math.floor(player.x)}, ${Math.floor(player.y)}`, mx + size, my + size + 12);

  // Border
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx - 2, my - 2, size + 4, size + 4);
}

// ============================================================
// GAME UPDATE
// ============================================================
function update(dt) {
  if (!gameRunning || craftingOpen) return;

  // Mouse look
  player.angle += mouseDX * ROT_SPEED;
  mouseDX = 0;

  // Sprint
  player.sprinting = !!(keys['ShiftLeft'] || keys['ShiftRight']) && player.hunger > 10;

  // Movement
  const cosA = Math.cos(player.angle), sinA = Math.sin(player.angle);
  let moveX = 0, moveY = 0;
  if (keys['KeyW']) { moveX += cosA; moveY += sinA; }
  if (keys['KeyS']) { moveX -= cosA; moveY -= sinA; }
  if (keys['KeyA']) { moveX += sinA; moveY -= cosA; }
  if (keys['KeyD']) { moveX -= sinA; moveY += cosA; }

  if (moveX !== 0 || moveY !== 0) {
    const speed = player.sprinting ? SPRINT_SPEED : MOVE_SPEED;
    if (player.sprinting) player.hunger -= SPRINT_HUNGER * dt;
    const len = Math.sqrt(moveX * moveX + moveY * moveY);
    moveX = moveX / len * speed * dt;
    moveY = moveY / len * speed * dt;

    // Collision - slide along walls
    const margin = 0.2;
    const nx = player.x + moveX;
    const ny = player.y + moveY;

    const bx = getBlock(Math.floor(nx + (moveX > 0 ? margin : -margin)), Math.floor(player.y));
    const by = getBlock(Math.floor(player.x), Math.floor(ny + (moveY > 0 ? margin : -margin)));

    if (bx === T.AIR || bx === T.WATER) player.x = nx;
    if (by === T.AIR || by === T.WATER) player.y = ny;

    // Lava damage
    const onBlock = getBlock(Math.floor(player.x), Math.floor(player.y));
    if (onBlock === T.LAVA) {
      player.hp -= 20 * dt;
      if (player.hp <= 0) playerDeath();
    }
  }

  // Hunger
  player.hunger -= HUNGER_RATE * dt;
  if (player.hunger <= 0) {
    player.hunger = 0;
    player.hp -= STARVE_DMG * dt;
    if (player.hp <= 0) playerDeath();
  }

  // Near well - restore hunger slowly
  const px = Math.floor(player.x), py = Math.floor(player.y);
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      if (getBlock(px + dx, py + dy) === T.WELL) {
        player.hunger = Math.min(player.maxHunger, player.hunger + 5 * dt);
        player.hp = Math.min(player.maxHp, player.hp + 1 * dt);
      }
    }
  }

  // HP regen when well fed
  if (player.hunger > 80) {
    player.hp = Math.min(player.maxHp, player.hp + 0.5 * dt);
  }

  // Attack cooldown
  player.attackCooldown = Math.max(0, player.attackCooldown - dt);

  // Left click: mine or attack
  if (mouseDown.left) {
    handleMineOrAttack(dt);
  } else {
    player.miningTarget = null;
    player.miningProgress = 0;
  }

  // Right click: place, eat, or tame
  if (mouseDown.right) {
    handleRightClick(dt);
    mouseDown.right = false; // single action
  }

  // Update creatures
  updateCreatures(dt);

  // Update NPCs (face toward player)
  for (const n of npcs) {
    const dx = player.x - n.x, dy = player.y - n.y;
    if (Math.sqrt(dx * dx + dy * dy) < 8) {
      n.angle = Math.atan2(dy, dx);
    }
  }

  // Update notifications
  for (let i = notifications.length - 1; i >= 0; i--) {
    notifications[i].time -= dt;
    if (notifications[i].time <= 0) notifications.splice(i, 1);
  }

  // Update torch cache periodically
  if (Math.random() < 0.02) updateTorchCache();
}

function handleMineOrAttack(dt) {
  // First check for creature attack
  if (player.attackCooldown <= 0) {
    const fov = Math.PI / 6; // narrow cone
    for (const c of creatures) {
      if (c.tamed) continue;
      const dx = c.x - player.x, dy = c.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > ATTACK_RANGE) continue;
      const angleToCreature = Math.atan2(dy, dx);
      let angleDiff = angleToCreature - player.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      if (Math.abs(angleDiff) < fov) {
        const dmg = getSwordDmg();
        c.hp -= dmg;
        c.knockback = 1;
        c.kbAngle = Math.atan2(dy, dx);
        player.attackCooldown = ATTACK_COOLDOWN;
        if (c.hp <= 0) {
          const ct = CREATURE_TYPES[c.type];
          if (ct.drop) {
            const added = addItem(ct.drop, 1);
            if (added > 0) notify('+1 ' + ITEMS[ct.drop].name);
          }
          creatures.splice(creatures.indexOf(c), 1);
        }
        return;
      }
    }
  }

  // Mining
  const hit = castRay(player.x, player.y, player.angle);
  if (hit.dist > MINE_RANGE || hit.block === T.AIR) {
    player.miningTarget = null;
    player.miningProgress = 0;
    return;
  }

  const key = hit.mapX + ',' + hit.mapY;
  if (player.miningTarget !== key) {
    player.miningTarget = key;
    player.miningProgress = 0;
  }

  const info = TILE_INFO[hit.block];
  if (!info || info.hits >= 999) return;

  // Mining speed based on pickaxe tier
  const tier = getPickaxeTier();
  const speedMult = 1 + tier * 0.6;
  player.miningProgress += (dt * speedMult) / info.hits * 2;

  if (player.miningProgress >= 1) {
    // Mine the block
    setBlock(hit.mapX, hit.mapY, T.AIR);
    if (info.drop) {
      const added = addItem(info.drop, info.dropAmt || 1);
      if (added > 0) notify('+' + (info.dropAmt || 1) + ' ' + ITEMS[info.drop].name);
    }
    player.miningTarget = null;
    player.miningProgress = 0;
    updateTorchCache();
  }
}

function handleRightClick() {
  const held = getHeldItem();
  const heldId = getHeldItemId();

  // Try to eat food
  if (held && held.food && player.hunger < player.maxHunger) {
    player.hunger = Math.min(player.maxHunger, player.hunger + held.food);
    if (held.food >= 30) player.hp = Math.min(player.maxHp, player.hp + held.food * 0.3);
    removeItem(heldId, 1);
    notify('Ate ' + held.name + ' (+' + held.food + ' hunger)');
    return;
  }

  // Try to tame creature with berries
  if (heldId === 'berries') {
    for (const c of creatures) {
      if (c.tamed) continue;
      const ct = CREATURE_TYPES[c.type];
      if (!ct.tameable) continue;
      const dx = c.x - player.x, dy = c.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 3) {
        const tameChance = 0.3 + (c.hp < c.maxHp ? 0.2 : 0);
        if (Math.random() < tameChance) {
          c.tamed = true;
          c.state = 'follow';
          c.hp = c.maxHp;
          notify('Tamed ' + ct.name + '!');
        } else {
          notify(ct.name + ' sniffed the berries...');
        }
        removeItem('berries', 1);
        return;
      }
    }
  }

  // Try to place block
  if (held && held.placeTile) {
    const dist = buildMode ? BUILD_PLACE_DIST : PLACE_DIST;
    const placeX = Math.floor(player.x + Math.cos(player.angle) * dist);
    const placeY = Math.floor(player.y + Math.sin(player.angle) * dist);

    // Don't place on self
    if (placeX === Math.floor(player.x) && placeY === Math.floor(player.y)) return;

    if (placeX > 0 && placeX < MAP_SIZE - 1 && placeY > 0 && placeY < MAP_SIZE - 1) {
      if (getBlock(placeX, placeY) === T.AIR) {
        setBlock(placeX, placeY, held.placeTile);
        removeItem(heldId, 1);
        if (held.placeTile === T.TORCH) updateTorchCache();
        return;
      }
    }
  }
}

function updateTorchCache() {
  torchPositions = [];
  const px = Math.floor(player.x), py = Math.floor(player.y);
  const r = 15;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (getBlock(px + dx, py + dy) === T.TORCH) {
        torchPositions.push([px + dx, py + dy]);
      }
    }
  }
}

// ============================================================
// SAVE / LOAD
// ============================================================
function saveGame() {
  const data = {
    worldSeed,
    blockChanges,
    player: {
      x: player.x, y: player.y, angle: player.angle,
      hp: player.hp, hunger: player.hunger,
      hotbar: player.hotbar,
      backpack: player.backpack,
      selectedSlot: player.selectedSlot,
    },
    creatures: creatures.map(c => ({
      type: c.type, x: c.x, y: c.y, hp: c.hp,
      tamed: c.tamed, angle: c.angle,
    })),
    npcs: npcs.map(n => ({ type: n.type, x: n.x, y: n.y, town: n.town })),
    minimapSize,
  };
  try {
    localStorage.setItem('primal_frontier_save', JSON.stringify(data));
  } catch (e) { /* storage full */ }
}

function loadGame() {
  try {
    const raw = localStorage.getItem('primal_frontier_save');
    if (!raw) return false;
    const data = JSON.parse(raw);

    worldSeed = data.worldSeed;
    blockChanges = data.blockChanges || {};
    generateWorld(worldSeed);

    player.x = data.player.x;
    player.y = data.player.y;
    player.angle = data.player.angle;
    player.hp = data.player.hp;
    player.hunger = data.player.hunger;
    player.hotbar = data.player.hotbar;
    player.backpack = data.player.backpack || new Array(BACKPACK_SIZE).fill(null);
    player.selectedSlot = data.player.selectedSlot || 0;
    minimapSize = data.minimapSize || 0;

    // Restore creatures
    creatures = [];
    if (data.creatures) {
      for (const cd of data.creatures) {
        const ct = CREATURE_TYPES[cd.type];
        if (!ct) continue;
        creatures.push({
          type: cd.type,
          x: cd.x, y: cd.y,
          hp: cd.hp, maxHp: ct.hp,
          angle: cd.angle || 0,
          state: cd.tamed ? 'follow' : 'idle',
          tamed: cd.tamed || false,
          stateTimer: Math.random() * 3,
          knockback: 0, kbAngle: 0,
          attackTimer: 0,
        });
      }
    }

    // Restore NPCs
    if (data.npcs && data.npcs.length > 0) {
      npcs = data.npcs.map(nd => ({
        type: nd.type, x: nd.x, y: nd.y,
        town: nd.town || '', angle: 0,
      }));
    } else {
      spawnNPCs();
    }

    updateTorchCache();
    return true;
  } catch (e) {
    return false;
  }
}

function hasSave() {
  return localStorage.getItem('primal_frontier_save') !== null;
}

// ============================================================
// GAME LIFECYCLE
// ============================================================
function playerDeath() {
  player.hp = 0;
  gameRunning = false;
  document.exitPointerLock();
  document.getElementById('death-screen').style.display = 'flex';
}

function respawn() {
  document.getElementById('death-screen').style.display = 'none';
  player.x = MAP_SIZE / 2 + 0.5;
  player.y = MAP_SIZE / 2 + 0.5;
  player.hp = player.maxHp;
  player.hunger = player.maxHunger;
  // Keep inventory
  gameRunning = true;
  C.requestPointerLock();
}

function startGame(continueGame) {
  document.getElementById('title-screen').style.display = 'none';

  if (continueGame && hasSave()) {
    loadGame();
  } else {
    worldSeed = Math.floor(Math.random() * 999999) + 1;
    blockChanges = {};
    generateWorld(worldSeed);
    player.x = MAP_SIZE / 2 + 0.5;
    player.y = MAP_SIZE / 2 + 0.5;
    player.angle = 0;
    player.hp = 100;
    player.hunger = 100;
    player.hotbar = new Array(8).fill(null);
    player.backpack = new Array(BACKPACK_SIZE).fill(null);
    player.selectedSlot = 0;
    minimapSize = 1;
    buildMode = false;
    // Give starter items
    addItem('wood', 10);
    addItem('berries', 8);
    addItem('bread', 3);
    addItem('gold_coin', 5);
    spawnCreatures();
    spawnNPCs();
  }

  updateTorchCache();
  gameRunning = true;
  C.requestPointerLock();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = 0;
let autoSaveTimer = 0;

function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  if (gameRunning && !craftingOpen) {
    update(dt);
  }

  if (gameRunning) {
    renderScene();
    renderCreatures();
    renderNPCs();
    renderHUD();

    // Auto-save
    autoSaveTimer += dt;
    if (autoSaveTimer >= 60) {
      autoSaveTimer = 0;
      saveGame();
    }
  }

  requestAnimationFrame(gameLoop);
}

// ============================================================
// INIT
// ============================================================
function init() {
  initTextures();

  // Setup continue button state
  const continueBtn = document.getElementById('btn-continue');
  if (!hasSave()) {
    continueBtn.classList.add('disabled');
    continueBtn.onclick = null;
  }

  // Save on page close
  window.addEventListener('beforeunload', () => {
    if (gameRunning) saveGame();
  });

  // Start loop (renders title screen)
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
