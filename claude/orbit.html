<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ORBIT - A Gravitational Puzzle</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    height: 100vh; overflow: hidden;
    font-family: 'Courier New', monospace;
    color: #ccc;
  }
  canvas { max-width: 100%; height: auto; cursor: crosshair; }
  #info {
    margin-top: 8px; font-size: 11px; color: #445;
    text-align: center; letter-spacing: 0.5px;
  }
</style>
</head>
<body>
<canvas id="c" width="800" height="500"></canvas>
<div id="info">Click to place · Click planet to remove · Scroll or 1/2/3 for size · Space to launch · R to reset · Esc for menu</div>
<script>
// ═══════════════════════════════════════════════════════════
//  O R B I T  —  A Gravitational Puzzle
//  crafted by Claude
// ═══════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 800, H = 500;

// ─── AUDIO ────────────────────────────────────────────────
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function tone(freq, dur, type = 'sine', vol = 0.07) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
const sfx = {
  place:  () => { tone(260, 0.12); tone(390, 0.12, 'sine', 0.04); },
  launch: () => { for (let i = 0; i < 6; i++) setTimeout(() => tone(180 + i * 60, 0.08, 'triangle', 0.03), i * 25); },
  win:    () => { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => tone(f, 0.35, 'sine', 0.06), i * 110)); },
  crash:  () => { tone(70, 0.5, 'sawtooth', 0.05); tone(55, 0.6, 'square', 0.03); },
  remove: () => tone(200, 0.08, 'sine', 0.04),
  click:  () => tone(500, 0.04, 'sine', 0.03),
  select: () => tone(440, 0.06, 'triangle', 0.03),
};

// ─── UTILITIES ────────────────────────────────────────────
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const rand  = (lo, hi) => lo + Math.random() * (hi - lo);

// ─── CONSTANTS ────────────────────────────────────────────
const G_CONST   = 40000;
const PLANET_R  = { 1: 12, 2: 18, 3: 24 };
const PLANET_COL = {
  1: { fill: '#4488ff', glow: '#2255cc', ring: 'rgba(68,136,255,0.08)' },
  2: { fill: '#44dd88', glow: '#22aa55', ring: 'rgba(68,221,136,0.08)' },
  3: { fill: '#ff8844', glow: '#cc6622', ring: 'rgba(255,136,68,0.08)' },
};
const SHIP_R    = 5;
const SIM_LIMIT = 25;
const MAX_TRAIL = 2500;
const SUB_STEPS = 8;

// ─── LEVELS ───────────────────────────────────────────────
const LEVELS = [
  {
    name: 'First Contact',
    hint: 'Place your planet below the flight path to pull the ship toward the portal.',
    ship: { x: 70, y: 180, angle: 0.05, speed: 130 },
    target: { x: 710, y: 340, r: 30 },
    obstacles: [],
    fixed: [],
    inv: { 1: 1, 2: 0, 3: 0 },
  },
  {
    name: 'The Arc',
    hint: 'A heavier planet bends the path more. Try the medium planet.',
    ship: { x: 70, y: 80, angle: 0.18, speed: 120 },
    target: { x: 710, y: 400, r: 28 },
    obstacles: [],
    fixed: [],
    inv: { 1: 1, 2: 1, 3: 0 },
  },
  {
    name: 'Obstacle',
    hint: 'Curve around the asteroid to reach the portal on the other side.',
    ship: { x: 70, y: 250, angle: 0, speed: 140 },
    target: { x: 710, y: 250, r: 26 },
    obstacles: [{ x: 390, y: 250, r: 40 }],
    fixed: [],
    inv: { 1: 0, 2: 1, 3: 0 },
  },
  {
    name: 'Gravity Well',
    hint: 'Use a heavy planet to pull the ship sharply upward.',
    ship: { x: 70, y: 380, angle: -0.1, speed: 120 },
    target: { x: 710, y: 100, r: 26 },
    obstacles: [],
    fixed: [],
    inv: { 1: 0, 2: 0, 3: 1 },
  },
  {
    name: 'Binary',
    hint: 'Two fixed stars already pull the ship. Fine-tune the trajectory.',
    ship: { x: 70, y: 250, angle: 0, speed: 125 },
    target: { x: 710, y: 250, r: 24 },
    obstacles: [],
    fixed: [{ x: 340, y: 130, mass: 2 }, { x: 460, y: 370, mass: 2 }],
    inv: { 1: 2, 2: 0, 3: 0 },
  },
  {
    name: 'Corridor',
    hint: 'Thread the ship through the gap between asteroids.',
    ship: { x: 70, y: 380, angle: -0.25, speed: 130 },
    target: { x: 710, y: 120, r: 24 },
    obstacles: [
      { x: 260, y: 180, r: 30 }, { x: 260, y: 330, r: 30 },
      { x: 500, y: 130, r: 30 }, { x: 500, y: 280, r: 30 },
    ],
    fixed: [],
    inv: { 1: 1, 2: 1, 3: 0 },
  },
  {
    name: 'Cascade',
    hint: 'Chain multiple small gravity assists to weave through.',
    ship: { x: 70, y: 80, angle: 0.1, speed: 115 },
    target: { x: 710, y: 420, r: 24 },
    obstacles: [
      { x: 300, y: 340, r: 35 },
      { x: 540, y: 160, r: 35 },
    ],
    fixed: [],
    inv: { 1: 3, 2: 0, 3: 0 },
  },
  {
    name: 'Reversal',
    hint: 'The portal is behind you. Use gravity to reverse the ship\'s course.',
    ship: { x: 500, y: 250, angle: 0, speed: 90 },
    target: { x: 120, y: 250, r: 30 },
    obstacles: [],
    fixed: [],
    inv: { 1: 0, 2: 1, 3: 1 },
  },
  {
    name: 'Starfield',
    hint: 'Navigate a busy field of fixed stars and debris.',
    ship: { x: 60, y: 430, angle: -0.55, speed: 120 },
    target: { x: 740, y: 70, r: 22 },
    obstacles: [
      { x: 200, y: 120, r: 25 },
      { x: 520, y: 380, r: 25 },
    ],
    fixed: [
      { x: 300, y: 290, mass: 1 },
      { x: 560, y: 180, mass: 2 },
    ],
    inv: { 1: 2, 2: 1, 3: 0 },
  },
  {
    name: 'Harmony',
    hint: 'Craft a beautiful trajectory through the cosmos.',
    ship: { x: 70, y: 250, angle: -0.35, speed: 105 },
    target: { x: 730, y: 250, r: 20 },
    obstacles: [
      { x: 230, y: 120, r: 30 },
      { x: 400, y: 360, r: 35 },
      { x: 570, y: 120, r: 30 },
    ],
    fixed: [{ x: 400, y: 55, mass: 1 }],
    inv: { 1: 2, 2: 1, 3: 1 },
  },
];

// ─── GAME STATE ───────────────────────────────────────────
let state = 'title'; // title | select | placing | sim | won | lost
let lvl = 0;
let ship = {};
let trail = [];
let placed = [];
let selMass = 1;
let inv = {};
let simTime = 0;
let time = 0;
let mouse = { x: 0, y: 0, over: false };
let particles = [];
let stars = [];
let hoverIdx = -1;
let ghostOk = true;
let bestScores = JSON.parse(localStorage.getItem('orbit_best') || '{}');
let maxUnlocked = parseInt(localStorage.getItem('orbit_max') || '0');

// ─── STARS ────────────────────────────────────────────────
function makeStars() {
  stars = [];
  for (let i = 0; i < 180; i++) {
    stars.push({
      x: rand(0, W), y: rand(0, H),
      s: rand(0.3, 1.8), b: rand(0.15, 0.8),
      tw: rand(1, 4), to: rand(0, 6.28),
    });
  }
}
makeStars();

// ─── PARTICLES ────────────────────────────────────────────
function spawn(x, y, n, col, spd = 80, life = 0.8) {
  for (let i = 0; i < n; i++) {
    const a = rand(0, 6.28), s = rand(spd * 0.2, spd);
    particles.push({
      x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: rand(life * 0.4, life), ml: life, col, sz: rand(1, 3),
    });
  }
}

// ─── INIT LEVEL ───────────────────────────────────────────
function initLevel(n) {
  const L = LEVELS[n];
  lvl = n;
  ship = {
    x: L.ship.x, y: L.ship.y,
    vx: Math.cos(L.ship.angle) * L.ship.speed,
    vy: Math.sin(L.ship.angle) * L.ship.speed,
    alive: true,
  };
  trail = [{ x: ship.x, y: ship.y }];
  placed = [];
  inv = { ...L.inv };
  selMass = [1, 2, 3].find(m => inv[m] > 0) || 1;
  simTime = 0;
  particles = [];
  state = 'placing';
  ghostOk = true;
  hoverIdx = -1;
}

// ─── PHYSICS ──────────────────────────────────────────────
function allBodies() {
  const L = LEVELS[lvl];
  const bodies = placed.map(p => ({ x: p.x, y: p.y, mass: p.mass }));
  if (L.fixed) L.fixed.forEach(f => bodies.push(f));
  return bodies;
}

function simStep(dt) {
  const bodies = allBodies();
  const L = LEVELS[lvl];
  let ax = 0, ay = 0;

  for (const b of bodies) {
    const dx = b.x - ship.x, dy = b.y - ship.y;
    const r2 = dx * dx + dy * dy;
    const pr = PLANET_R[b.mass] || 15;
    const r = Math.sqrt(r2);
    if (r < pr + SHIP_R) return 'crash_planet';
    const soft = Math.max(r2, pr * pr);
    const f = G_CONST * b.mass / soft;
    ax += f * dx / r;
    ay += f * dy / r;
  }

  ship.vx += ax * dt;
  ship.vy += ay * dt;
  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;

  for (const ob of L.obstacles) {
    if (Math.hypot(ship.x - ob.x, ship.y - ob.y) < ob.r + SHIP_R) return 'crash_obstacle';
  }

  const margin = 60;
  if (ship.x < -margin || ship.x > W + margin || ship.y < -margin || ship.y > H + margin) return 'oob';

  const T = L.target;
  if (Math.hypot(ship.x - T.x, ship.y - T.y) < T.r) return 'win';

  return 'ok';
}

function simulate(dt) {
  const subDt = dt / SUB_STEPS;
  for (let i = 0; i < SUB_STEPS; i++) {
    const result = simStep(subDt);
    trail.push({ x: ship.x, y: ship.y });
    if (trail.length > MAX_TRAIL) trail.shift();

    if (result === 'win') {
      state = 'won';
      sfx.win();
      spawn(ship.x, ship.y, 40, '#ffd700', 120, 1.2);
      spawn(ship.x, ship.y, 20, '#ffffff', 80, 0.8);
      const T = LEVELS[lvl].target;
      spawn(T.x, T.y, 30, '#ffd700', 60, 1);
      if (bestScores[lvl] === undefined || placed.length < bestScores[lvl]) {
        bestScores[lvl] = placed.length;
        localStorage.setItem('orbit_best', JSON.stringify(bestScores));
      }
      if (lvl + 1 > maxUnlocked) {
        maxUnlocked = lvl + 1;
        localStorage.setItem('orbit_max', String(maxUnlocked));
      }
      return;
    }
    if (result !== 'ok') {
      state = 'lost';
      ship.alive = false;
      sfx.crash();
      spawn(ship.x, ship.y, 30, '#ff4444', 100, 0.8);
      spawn(ship.x, ship.y, 15, '#ffaa44', 60, 0.6);
      return;
    }
  }
  simTime += dt;
  if (simTime > SIM_LIMIT) {
    state = 'lost';
    ship.alive = false;
  }
}

// ─── DRAWING ──────────────────────────────────────────────
function drawBg() {
  const g = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, W * 0.65);
  g.addColorStop(0, '#0e0e2e');
  g.addColorStop(1, '#040410');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
}

function drawStars(t) {
  for (const s of stars) {
    const b = s.b * (0.6 + 0.4 * Math.sin(t * s.tw + s.to));
    ctx.fillStyle = `rgba(255,255,255,${b})`;
    ctx.fillRect(s.x, s.y, s.s, s.s);
  }
}

function drawShip(x, y, vx, vy) {
  const angle = Math.atan2(vy, vx);
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.shadowBlur = 12;
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = '#00ffff';
  ctx.beginPath();
  ctx.moveTo(10, 0);
  ctx.lineTo(-7, -5);
  ctx.lineTo(-4, 0);
  ctx.lineTo(-7, 5);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(6, 0);
  ctx.lineTo(-1, -2);
  ctx.lineTo(-1, 2);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawPlanet(x, y, mass, ghost, hover) {
  const c = PLANET_COL[mass];
  const r = PLANET_R[mass];
  ctx.save();
  ctx.globalAlpha = ghost ? 0.35 : 1;

  if (!ghost) {
    for (let i = 1; i <= 3; i++) {
      const rr = r + i * 20 + 3 * Math.sin(time * 2 + i);
      ctx.strokeStyle = c.ring;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.arc(x, y, rr, 0, 6.28);
      ctx.stroke();
    }
  }

  ctx.shadowBlur = ghost ? 6 : 18;
  ctx.shadowColor = c.glow;
  ctx.fillStyle = c.fill;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 6.28);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath();
  ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.35, 0, 6.28);
  ctx.fill();

  if (hover) {
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(x, y, r + 6, 0, 6.28);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawTarget(x, y, r, t) {
  const pulse = 1 + 0.12 * Math.sin(t * 3);
  ctx.save();
  ctx.shadowBlur = 25;
  ctx.shadowColor = '#ffd700';
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(x, y, r * pulse, 0, 6.28);
  ctx.stroke();

  ctx.shadowBlur = 10;
  ctx.strokeStyle = 'rgba(255,215,0,0.35)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(x, y, r * pulse * 0.55, 0, 6.28);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,215,0,0.25)';
  ctx.shadowBlur = 0;
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, 6.28);
  ctx.fill();

  for (let i = 0; i < 4; i++) {
    const a = t * 1.5 + i * 1.57;
    ctx.strokeStyle = 'rgba(255,215,0,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y, r * pulse + 8, a, a + 0.5);
    ctx.stroke();
  }
  ctx.restore();
}

function drawObstacle(x, y, r, seed) {
  ctx.save();
  ctx.fillStyle = '#2a2a3a';
  ctx.strokeStyle = '#4a4a5a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  const n = 10;
  for (let i = 0; i < n; i++) {
    const a = (i / n) * 6.28;
    const w = 0.82 + 0.18 * Math.sin(seed * 7.3 + i * 4.1);
    const px = x + Math.cos(a) * r * w;
    const py = y + Math.sin(a) * r * w;
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#1a1a2a';
  for (let i = 0; i < 3; i++) {
    const a = seed * 3.7 + i * 2.1;
    const d = r * (0.3 + 0.2 * Math.sin(seed + i));
    ctx.beginPath();
    ctx.arc(x + Math.cos(a) * d, y + Math.sin(a) * d, r * 0.1, 0, 6.28);
    ctx.fill();
  }
  ctx.restore();
}

function drawTrail() {
  if (trail.length < 2) return;
  for (let i = 1; i < trail.length; i++) {
    const a = (i / trail.length) * 0.65;
    ctx.strokeStyle = `rgba(0,255,255,${a})`;
    ctx.lineWidth = 0.5 + a * 1.5;
    ctx.beginPath();
    ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
    ctx.lineTo(trail[i].x, trail[i].y);
    ctx.stroke();
  }
}

function drawParticles() {
  for (const p of particles) {
    const a = clamp(p.life / p.ml, 0, 1);
    ctx.globalAlpha = a;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.sz * a, 0, 6.28);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawLaunchArrow() {
  const L = LEVELS[lvl];
  const len = 40;
  const ax = L.ship.x + Math.cos(L.ship.angle) * len;
  const ay = L.ship.y + Math.sin(L.ship.angle) * len;
  ctx.save();
  ctx.strokeStyle = 'rgba(0,255,255,0.25)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 6]);
  ctx.beginPath();
  ctx.moveTo(L.ship.x, L.ship.y);
  ctx.lineTo(ax, ay);
  ctx.stroke();
  ctx.setLineDash([]);
  const ha = L.ship.angle;
  ctx.fillStyle = 'rgba(0,255,255,0.25)';
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax - 7 * Math.cos(ha - 0.4), ay - 7 * Math.sin(ha - 0.4));
  ctx.lineTo(ax - 7 * Math.cos(ha + 0.4), ay - 7 * Math.sin(ha + 0.4));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ─── HUD ──────────────────────────────────────────────────
function drawHUD() {
  const L = LEVELS[lvl];
  ctx.save();
  ctx.fillStyle = '#7788aa';
  ctx.font = '13px "Courier New", monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`${lvl + 1}/${LEVELS.length}  ${L.name}`, 12, 22);

  let ix = 12, iy = 44;
  ctx.font = '11px "Courier New", monospace';
  ctx.fillStyle = '#556';
  ctx.fillText('Planets:', ix, iy);
  ix += 64;

  for (const m of [1, 2, 3]) {
    if (L.inv[m] > 0) {
      const c = PLANET_COL[m];
      const r = PLANET_R[m] * 0.45;

      if (m === selMass && state === 'placing') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(ix + r + 2, iy - 4, r + 5, 0, 6.28);
        ctx.stroke();
      }

      ctx.globalAlpha = inv[m] > 0 ? 1 : 0.25;
      ctx.fillStyle = c.fill;
      ctx.beginPath();
      ctx.arc(ix + r + 2, iy - 4, r, 0, 6.28);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = inv[m] > 0 ? '#aab' : '#445';
      ctx.fillText(`x${inv[m]}`, ix + r * 2 + 10, iy);
      ix += 58;
    }
  }

  if (state === 'placing' && placed.length === 0) {
    ctx.fillStyle = '#445';
    ctx.font = '11px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(L.hint, W / 2, H - 14);
  }

  if (state === 'placing') {
    ctx.fillStyle = '#4a6a4a';
    ctx.font = '12px "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.fillText('[SPACE] Launch   [R] Reset', W - 12, 22);
  }
  if (state === 'sim') {
    ctx.fillStyle = '#8a8a5a';
    ctx.font = '12px "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.fillText(`Simulating... ${simTime.toFixed(1)}s`, W - 12, 22);
  }
  ctx.restore();
}

function drawOverlay(title, titleCol, shadowCol, subtitle) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0, 0, W, H);
  ctx.shadowBlur = 20;
  ctx.shadowColor = shadowCol;
  ctx.fillStyle = titleCol;
  ctx.font = 'bold 34px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText(title, W / 2, H / 2 - 25);
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#999';
  ctx.font = '13px "Courier New", monospace';
  ctx.fillText(subtitle, W / 2, H / 2 + 15);
  ctx.restore();
}

function drawWon() {
  const sub = lvl < LEVELS.length - 1
    ? 'SPACE for next level  ·  R to replay'
    : 'All levels complete! R to replay.';
  drawOverlay('ORBIT ACHIEVED', '#ffd700', '#ffd700', sub);
  ctx.save();
  ctx.fillStyle = '#667';
  ctx.font = '11px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText(`Planets: ${placed.length}   Time: ${simTime.toFixed(1)}s`, W / 2, H / 2 + 45);
  ctx.restore();
}

function drawLost() {
  const msg = simTime >= SIM_LIMIT ? 'LOST IN SPACE' : 'SHIP DESTROYED';
  drawOverlay(msg, '#ff6666', '#ff4444', 'R to retry  ·  ESC for level select');
}

// ─── TITLE ────────────────────────────────────────────────
function drawTitle() {
  drawBg();
  drawStars(time);

  // Orbiting dots
  for (let j = 0; j < 2; j++) {
    const speed = j === 0 ? 0.7 : -0.5;
    const rx = j === 0 ? 140 : 100;
    const ry = j === 0 ? 35 : 50;
    const col = j === 0 ? '#00ffff' : '#ffd700';
    for (let i = 0; i <= 15; i++) {
      const t2 = time * speed - i * 0.04;
      const tx = W / 2 + rx * Math.cos(t2);
      const ty = H / 2 - 30 + ry * Math.sin(t2);
      const alpha = i === 0 ? 0.9 : 0.35 - i * 0.02;
      const sz = i === 0 ? 3 : 2;
      if (i === 0) {
        ctx.shadowBlur = 8;
        ctx.shadowColor = col;
      }
      ctx.fillStyle = col.replace(')', `,${Math.max(0, alpha)})`).replace('rgb', 'rgba').replace('##', '#');
      // Simpler: use hex with globalAlpha
      ctx.globalAlpha = Math.max(0, alpha);
      ctx.fillStyle = col;
      ctx.beginPath();
      ctx.arc(tx, ty, sz, 0, 6.28);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.shadowBlur = 40;
  ctx.shadowColor = '#4488ff';
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 64px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('ORBIT', W / 2, H / 2 - 15);
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#6678aa';
  ctx.font = '14px "Courier New", monospace';
  ctx.fillText('A Gravitational Puzzle', W / 2, H / 2 + 15);
  ctx.fillStyle = '#445566';
  ctx.font = '13px "Courier New", monospace';
  const blink = Math.sin(time * 2.5) > 0;
  if (blink) ctx.fillText('Click to begin', W / 2, H / 2 + 55);
  ctx.fillStyle = '#2a2a3a';
  ctx.font = '11px "Courier New", monospace';
  ctx.fillText('crafted by Claude', W / 2, H - 20);
  ctx.restore();
}

// ─── LEVEL SELECT ─────────────────────────────────────────
function drawSelect() {
  drawBg();
  drawStars(time);
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 26px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT LEVEL', W / 2, 48);

  const cols = 5, pad = 16, bw = 136, bh = 65;
  const totalW = cols * bw + (cols - 1) * pad;
  const startX = (W - totalW) / 2;
  const startY = 80;

  for (let i = 0; i < LEVELS.length; i++) {
    const col = i % cols, row = Math.floor(i / cols);
    const x = startX + col * (bw + pad);
    const y = startY + row * (bh + pad);
    const unlocked = i <= maxUnlocked;
    const hov = mouse.x >= x && mouse.x <= x + bw && mouse.y >= y && mouse.y <= y + bh;

    ctx.fillStyle = hov && unlocked ? '#151530' : '#0a0a1e';
    ctx.strokeStyle = unlocked ? (hov ? '#4488ff' : '#1a1a3e') : '#111122';
    ctx.lineWidth = hov && unlocked ? 2 : 1;
    ctx.beginPath();
    ctx.roundRect(x, y, bw, bh, 6);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = unlocked ? '#ccd' : '#2a2a3a';
    ctx.font = 'bold 12px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${i + 1}. ${LEVELS[i].name}`, x + bw / 2, y + 26);

    if (!unlocked) {
      ctx.fillStyle = '#333';
      ctx.font = '10px "Courier New", monospace';
      ctx.fillText('LOCKED', x + bw / 2, y + 48);
    } else if (bestScores[i] !== undefined) {
      ctx.fillStyle = '#5a8a5a';
      ctx.font = '10px "Courier New", monospace';
      ctx.fillText(`\u2713 ${bestScores[i]} planet${bestScores[i] !== 1 ? 's' : ''}`, x + bw / 2, y + 48);
    }
  }

  ctx.fillStyle = '#334';
  ctx.font = '11px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('ESC to return to title', W / 2, H - 18);
  ctx.restore();
}

// ─── PLACEMENT VALIDATION ─────────────────────────────────
function isValidPlace(x, y, mass) {
  const L = LEVELS[lvl];
  const pr = PLANET_R[mass];
  if (Math.hypot(x - L.target.x, y - L.target.y) < L.target.r + pr + 5) return false;
  if (Math.hypot(x - L.ship.x, y - L.ship.y) < pr + 18) return false;
  for (const ob of L.obstacles) {
    if (Math.hypot(x - ob.x, y - ob.y) < ob.r + pr + 5) return false;
  }
  for (const f of L.fixed) {
    if (Math.hypot(x - f.x, y - f.y) < PLANET_R[f.mass] + pr + 5) return false;
  }
  for (const p of placed) {
    if (Math.hypot(x - p.x, y - p.y) < PLANET_R[p.mass] + pr + 5) return false;
  }
  if (x < pr + 2 || x > W - pr - 2 || y < pr + 2 || y > H - pr - 2) return false;
  return true;
}

// ─── INPUT ────────────────────────────────────────────────
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left) * (W / rect.width);
  mouse.y = (e.clientY - rect.top) * (H / rect.height);
  mouse.over = true;

  if (state === 'placing') {
    hoverIdx = -1;
    for (let i = placed.length - 1; i >= 0; i--) {
      if (Math.hypot(mouse.x - placed[i].x, mouse.y - placed[i].y) < PLANET_R[placed[i].mass] + 8) {
        hoverIdx = i;
        break;
      }
    }
    ghostOk = isValidPlace(mouse.x, mouse.y, selMass);
  }
});
canvas.addEventListener('mouseleave', () => { mouse.over = false; });

canvas.addEventListener('click', e => {
  ensureAudio();

  if (state === 'title') {
    state = 'select';
    sfx.click();
    return;
  }

  if (state === 'select') {
    const cols = 5, pad = 16, bw = 136, bh = 65;
    const totalW = cols * bw + (cols - 1) * pad;
    const startX = (W - totalW) / 2;
    const startY = 80;
    for (let i = 0; i < LEVELS.length; i++) {
      if (i > maxUnlocked) continue;
      const col = i % cols, row = Math.floor(i / cols);
      const x = startX + col * (bw + pad);
      const y = startY + row * (bh + pad);
      if (mouse.x >= x && mouse.x <= x + bw && mouse.y >= y && mouse.y <= y + bh) {
        initLevel(i);
        sfx.click();
        return;
      }
    }
    return;
  }

  if (state === 'placing') {
    if (hoverIdx >= 0) {
      const removed = placed.splice(hoverIdx, 1)[0];
      inv[removed.mass]++;
      sfx.remove();
      hoverIdx = -1;
    } else if (inv[selMass] > 0 && ghostOk) {
      placed.push({ x: mouse.x, y: mouse.y, mass: selMass });
      inv[selMass]--;
      sfx.place();
      if (inv[selMass] <= 0) {
        const next = [1, 2, 3].find(m => inv[m] > 0);
        if (next) selMass = next;
      }
    }
  }
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (state === 'placing' && hoverIdx >= 0) {
    const removed = placed.splice(hoverIdx, 1)[0];
    inv[removed.mass]++;
    sfx.remove();
    hoverIdx = -1;
  }
});

canvas.addEventListener('wheel', e => {
  if (state !== 'placing') return;
  e.preventDefault();
  const masses = [1, 2, 3].filter(m => LEVELS[lvl].inv[m] > 0);
  if (masses.length <= 1) return;
  let idx = masses.indexOf(selMass);
  if (idx < 0) idx = 0;
  idx = (idx + (e.deltaY > 0 ? 1 : -1) + masses.length) % masses.length;
  selMass = masses[idx];
  sfx.select();
}, { passive: false });

document.addEventListener('keydown', e => {
  ensureAudio();

  if (e.code === 'Space') {
    e.preventDefault();
    if (state === 'placing') {
      state = 'sim';
      simTime = 0;
      sfx.launch();
    } else if (state === 'won' && lvl < LEVELS.length - 1) {
      initLevel(lvl + 1);
      sfx.click();
    }
  }

  if (e.code === 'KeyR') {
    if (['placing', 'sim', 'won', 'lost'].includes(state)) {
      initLevel(lvl);
      sfx.click();
    }
  }

  if (e.code === 'Escape') {
    if (['placing', 'sim', 'won', 'lost'].includes(state)) {
      state = 'select';
      sfx.click();
    } else if (state === 'select') {
      state = 'title';
      sfx.click();
    }
  }

  if (state === 'placing') {
    const num = parseInt(e.key);
    if (num >= 1 && num <= 3 && LEVELS[lvl].inv[num] > 0) {
      selMass = num;
      sfx.select();
    }
  }
});

// ─── GAME LOOP ────────────────────────────────────────────
let lastTime = 0;
function frame(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  time += dt;

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.97;
    p.vy *= 0.97;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Simulate
  if (state === 'sim') {
    // Exhaust particles for first 0.4s
    if (simTime < 0.4 && Math.random() < 0.4) {
      const eAngle = Math.atan2(ship.vy, ship.vx) + Math.PI + (Math.random() - 0.5) * 0.6;
      const eSpd = rand(20, 50);
      particles.push({
        x: ship.x, y: ship.y,
        vx: Math.cos(eAngle) * eSpd, vy: Math.sin(eAngle) * eSpd,
        life: 0.25, ml: 0.25, col: '#0088aa', sz: 1.5,
      });
    }
    simulate(dt);
  }

  // ─── RENDER ───────────────────────────────────────────
  if (state === 'title') {
    drawTitle();
  } else if (state === 'select') {
    drawSelect();
  } else {
    drawBg();
    drawStars(time);

    const L = LEVELS[lvl];
    drawTarget(L.target.x, L.target.y, L.target.r, time);
    L.obstacles.forEach((ob, i) => drawObstacle(ob.x, ob.y, ob.r, i + lvl * 100));
    L.fixed.forEach(f => drawPlanet(f.x, f.y, f.mass, false, false));
    placed.forEach((p, i) => drawPlanet(p.x, p.y, p.mass, false, state === 'placing' && i === hoverIdx));

    // Ghost planet
    if (state === 'placing' && mouse.over && hoverIdx < 0 && inv[selMass] > 0) {
      drawPlanet(mouse.x, mouse.y, selMass, true, false);
      if (!ghostOk) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,60,60,0.5)';
        ctx.lineWidth = 1.5;
        const gr = PLANET_R[selMass] + 6;
        ctx.beginPath();
        ctx.moveTo(mouse.x - gr, mouse.y - gr);
        ctx.lineTo(mouse.x + gr, mouse.y + gr);
        ctx.moveTo(mouse.x + gr, mouse.y - gr);
        ctx.lineTo(mouse.x - gr, mouse.y + gr);
        ctx.stroke();
        ctx.restore();
      }
    }

    drawTrail();

    if (ship.alive || state === 'placing') {
      if (state === 'placing') {
        drawShip(L.ship.x, L.ship.y,
          Math.cos(L.ship.angle) * L.ship.speed,
          Math.sin(L.ship.angle) * L.ship.speed);
        drawLaunchArrow();
      } else {
        drawShip(ship.x, ship.y, ship.vx, ship.vy);
      }
    }

    drawParticles();
    drawHUD();

    if (state === 'won') drawWon();
    if (state === 'lost') drawLost();
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
