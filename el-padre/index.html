<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>El Padre's Tetris</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Press+Start+2P&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a1a;
  color: #e0e0ff;
  font-family: 'Rajdhani', sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  display: flex;
  justify-content: center;
  align-items: center;
  user-select: none;
}

#bg-canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
  pointer-events: none;
}

#game-wrapper {
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  transform-origin: center center;
}

.side-panel {
  width: 180px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.panel-box {
  background: rgba(10, 10, 40, 0.85);
  border: 1px solid rgba(0, 255, 255, 0.15);
  border-radius: 8px;
  padding: 14px;
  backdrop-filter: blur(4px);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.05), inset 0 0 20px rgba(0, 0, 0, 0.3);
}

.panel-box h3 {
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  color: #00e5ff;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 10px;
  text-align: center;
  text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
}

.hold-canvas, .next-canvas {
  display: block;
  margin: 0 auto;
  image-rendering: pixelated;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  padding: 4px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.stat-row:last-child { border-bottom: none; }

.stat-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 500;
  color: rgba(200, 200, 255, 0.6);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.stat-value {
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
  color: #fff;
  text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
}

#score-val { color: #00e5ff; }
#level-val { color: #ff6ec7; }
#lines-val { color: #39ff14; }
#combo-val { color: #ffe44d; }
#high-score-val { color: #ff9500; }

.controls-list {
  font-size: 10px;
  line-height: 1.8;
  color: rgba(200, 200, 255, 0.5);
  font-family: 'Rajdhani', sans-serif;
}

.controls-list span {
  color: rgba(0, 229, 255, 0.7);
  font-weight: 600;
}

#board-container {
  position: relative;
  border: 2px solid rgba(0, 229, 255, 0.3);
  border-radius: 4px;
  box-shadow: 0 0 30px rgba(0, 229, 255, 0.1), 0 0 60px rgba(0, 229, 255, 0.05), inset 0 0 30px rgba(0, 0, 0, 0.5);
  overflow: hidden;
}

#board-container::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 6px;
  border: 2px solid transparent;
  background: linear-gradient(45deg, #00e5ff, #ff6ec7, #39ff14, #ffe44d) border-box;
  mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  -webkit-mask-composite: xor;
  opacity: 0.4;
  animation: borderGlow 4s ease-in-out infinite;
  pointer-events: none;
  z-index: 2;
}

@keyframes borderGlow {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.7; }
}

#game-canvas {
  display: block;
  background: rgba(5, 5, 20, 0.95);
}

/* Overlay screens */
.overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 100;
  background: rgba(5, 5, 15, 0.92);
  backdrop-filter: blur(8px);
  transition: opacity 0.3s;
}

.overlay.hidden { display: none; }

.overlay h1 {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(28px, 5vw, 56px);
  font-weight: 900;
  text-transform: uppercase;
  margin-bottom: 10px;
  letter-spacing: 4px;
}

.overlay h1 .el { color: #ff6ec7; text-shadow: 0 0 30px rgba(255, 110, 199, 0.6); }
.overlay h1 .padre { color: #00e5ff; text-shadow: 0 0 30px rgba(0, 229, 255, 0.6); }
.overlay h1 .tetris-word { color: #39ff14; text-shadow: 0 0 30px rgba(57, 255, 20, 0.6); }

.overlay .subtitle {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(10px, 1.5vw, 16px);
  color: rgba(200, 200, 255, 0.4);
  letter-spacing: 6px;
  margin-bottom: 50px;
}

.blink {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(10px, 1.5vw, 14px);
  color: #ffe44d;
  animation: blink 1.2s ease-in-out infinite;
  text-shadow: 0 0 15px rgba(255, 228, 77, 0.5);
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.2; }
}

.game-over-stats {
  margin: 20px 0 30px;
  text-align: center;
}

.game-over-stats .go-stat {
  font-family: 'Press Start 2P', monospace;
  font-size: 11px;
  margin: 10px 0;
  color: rgba(200, 200, 255, 0.7);
}

.game-over-stats .go-stat em {
  font-style: normal;
  color: #fff;
  text-shadow: 0 0 8px rgba(255,255,255,0.3);
}

.new-high {
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  color: #ff9500;
  text-shadow: 0 0 20px rgba(255, 149, 0, 0.6);
  margin-bottom: 10px;
  animation: blink 0.8s ease-in-out infinite;
}

.leaderboard { margin: 16px auto; max-width: 320px; }
.leaderboard h4 {
  font-family: 'Orbitron', sans-serif;
  font-size: 11px; color: #00e5ff; text-transform: uppercase;
  letter-spacing: 2px; text-align: center; margin-bottom: 8px;
  text-shadow: 0 0 10px rgba(0,229,255,0.5);
}
.lb-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 5px 10px; font-family: 'Press Start 2P', monospace; font-size: 9px;
  color: rgba(200,200,255,0.6); border-bottom: 1px solid rgba(255,255,255,0.05);
}
.lb-row.lb-new { color: #ff9500; text-shadow: 0 0 8px rgba(255,149,0,0.4); }
.lb-rank { width: 24px; color: #00e5ff; }
.lb-score { color: #fff; flex: 1; text-align: right; margin-right: 10px; }
.lb-detail { color: rgba(200,200,255,0.4); font-size: 8px; }

#pause-overlay h1 {
  color: #ffe44d;
  text-shadow: 0 0 30px rgba(255, 228, 77, 0.5);
  font-size: clamp(24px, 4vw, 48px);
}

#pause-overlay .pause-hint {
  font-family: 'Rajdhani', sans-serif;
  font-size: 16px;
  color: rgba(200, 200, 255, 0.4);
  margin-top: 20px;
}

/* Floating text popups */
.float-text {
  position: fixed;
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  pointer-events: none;
  z-index: 50;
  text-shadow: 0 0 20px currentColor;
  animation: floatUp 1.2s ease-out forwards;
  white-space: nowrap;
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  30% { opacity: 1; transform: translateY(-20px) scale(1.15); }
  100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
}

.screen-flash {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: white;
  z-index: 90;
  pointer-events: none;
  animation: flash 0.3s ease-out forwards;
}

@keyframes flash {
  0% { opacity: 0.5; }
  100% { opacity: 0; }
}

.screen-shake {
  animation: shake 0.4s ease-out;
}

@keyframes shake {
  0%, 100% { transform: translate(0); }
  10% { transform: translate(-4px, 2px); }
  20% { transform: translate(4px, -2px); }
  30% { transform: translate(-3px, 3px); }
  40% { transform: translate(3px, -1px); }
  50% { transform: translate(-2px, 1px); }
  60% { transform: translate(2px, -2px); }
  70% { transform: translate(-1px, 1px); }
  80% { transform: translate(1px, -1px); }
}

/* Title screen falling pieces canvas */
#title-canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 99;
  pointer-events: none;
}

/* Name input on title screen */
.name-entry {
  z-index: 101;
  position: relative;
  margin-top: 30px;
  text-align: center;
}

.name-entry label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  color: rgba(200, 200, 255, 0.5);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.name-entry input {
  display: block;
  margin: 6px auto 0;
  background: rgba(10, 10, 40, 0.85);
  border: 1px solid rgba(0, 229, 255, 0.3);
  border-radius: 4px;
  padding: 6px 12px;
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
  color: #00e5ff;
  text-align: center;
  width: 180px;
  outline: none;
  text-shadow: 0 0 8px rgba(0, 229, 255, 0.4);
}

.name-entry input:focus {
  border-color: rgba(0, 229, 255, 0.6);
  box-shadow: 0 0 12px rgba(0, 229, 255, 0.2);
}

/* Title leaderboard hint */
.title-lb-hint {
  z-index: 101;
  position: relative;
  margin-top: 16px;
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 1.2vw, 11px);
  color: rgba(0, 229, 255, 0.5);
  letter-spacing: 1px;
  cursor: pointer;
  transition: color 0.2s;
}

.title-lb-hint:hover {
  color: rgba(0, 229, 255, 0.9);
}

/* Leaderboard overlay (full screen) */
#leaderboard-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 200;
  background: rgba(5, 5, 15, 0.95);
  backdrop-filter: blur(8px);
}

#leaderboard-overlay.hidden { display: none; }

#leaderboard-overlay h2 {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(20px, 3.5vw, 36px);
  font-weight: 900;
  color: #00e5ff;
  text-transform: uppercase;
  letter-spacing: 4px;
  margin-bottom: 24px;
  text-shadow: 0 0 20px rgba(0, 229, 255, 0.5);
}

.lb-full-table {
  width: 90%;
  max-width: 520px;
}

.lb-full-row {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  color: rgba(200, 200, 255, 0.7);
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.lb-full-row.lb-header {
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  color: rgba(200, 200, 255, 0.4);
  text-transform: uppercase;
  letter-spacing: 1px;
  border-bottom: 1px solid rgba(0, 229, 255, 0.2);
  padding-bottom: 10px;
  margin-bottom: 4px;
}

.lb-full-row .lb-f-rank { width: 36px; color: #00e5ff; }
.lb-full-row .lb-f-name { flex: 1; color: #ff6ec7; min-width: 0; overflow: hidden; text-overflow: ellipsis; }
.lb-full-row .lb-f-score { width: 90px; text-align: right; color: #fff; }
.lb-full-row .lb-f-level { width: 50px; text-align: right; color: #39ff14; }
.lb-full-row .lb-f-lines { width: 50px; text-align: right; color: #ffe44d; }
.lb-full-row .lb-f-date { width: 80px; text-align: right; color: rgba(200, 200, 255, 0.35); font-size: 8px; }

.lb-back-hint {
  margin-top: 30px;
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 1.2vw, 11px);
  color: rgba(255, 228, 77, 0.6);
  animation: blink 1.2s ease-in-out infinite;
}

.lb-back-btn {
  margin-top: 16px;
  background: none;
  border: 1px solid rgba(0, 229, 255, 0.3);
  border-radius: 4px;
  padding: 8px 24px;
  font-family: 'Orbitron', sans-serif;
  font-size: 12px;
  color: #00e5ff;
  cursor: pointer;
  letter-spacing: 2px;
  text-transform: uppercase;
  transition: all 0.2s;
}

.lb-back-btn:hover {
  border-color: rgba(0, 229, 255, 0.7);
  background: rgba(0, 229, 255, 0.1);
  box-shadow: 0 0 15px rgba(0, 229, 255, 0.2);
}
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>

<!-- Title Screen -->
<div class="overlay" id="title-overlay">
  <canvas id="title-canvas"></canvas>
  <h1 style="z-index:101;position:relative;"><span class="el">El</span> <span class="padre">Padre's</span> <span class="tetris-word">Tetris</span></h1>
  <div class="subtitle" style="z-index:101;position:relative;">THE ULTIMATE CHALLENGE</div>
  <div class="blink" style="z-index:101;position:relative;">PRESS ENTER TO START</div>
  <div class="title-lb-hint" id="title-lb-btn" onclick="window._openLeaderboard && window._openLeaderboard()">L &mdash; VIEW LEADERBOARD</div>
  <div class="name-entry">
    <label for="player-name-input">Your Name</label>
    <input type="text" id="player-name-input" maxlength="16" placeholder="???" spellcheck="false" autocomplete="off">
  </div>
</div>

<!-- Leaderboard Overlay -->
<div class="hidden" id="leaderboard-overlay">
  <h2>Leaderboard</h2>
  <div class="lb-full-table" id="lb-full-table"></div>
  <div class="lb-back-hint">PRESS ESCAPE TO GO BACK</div>
  <button class="lb-back-btn" id="lb-back-btn">Back</button>
</div>

<!-- Pause Overlay -->
<div class="overlay hidden" id="pause-overlay">
  <h1>PAUSED</h1>
  <div class="pause-hint">Press P or ESC to resume</div>
</div>

<!-- Game Over Overlay -->
<div class="overlay hidden" id="gameover-overlay">
  <h1 style="color:#ff3355;text-shadow:0 0 30px rgba(255,51,85,0.6);">GAME OVER</h1>
  <div id="new-high-indicator" class="new-high hidden">NEW HIGH SCORE!</div>
  <div class="game-over-stats" id="go-stats"></div>
  <div class="leaderboard" id="leaderboard"></div>
  <div class="blink">PRESS ENTER TO RESTART</div>
</div>

<!-- Main Game UI -->
<div id="game-wrapper" style="display:none;">
  <!-- Left Panel -->
  <div class="side-panel">
    <div class="panel-box">
      <h3>Hold</h3>
      <canvas class="hold-canvas" id="hold-canvas" width="120" height="80"></canvas>
    </div>
    <div class="panel-box">
      <h3>Controls</h3>
      <div class="controls-list">
        <span>&larr; &rarr;</span> Move<br>
        <span>&uarr;</span> Rotate CW<br>
        <span>Z</span> Rotate CCW<br>
        <span>Space</span> Hard Drop<br>
        <span>&darr;</span> Soft Drop<br>
        <span>C</span> Hold Piece<br>
        <span>P / Esc</span> Pause
      </div>
    </div>
  </div>

  <!-- Game Board -->
  <div id="board-container">
    <canvas id="game-canvas"></canvas>
  </div>

  <!-- Right Panel -->
  <div class="side-panel">
    <div class="panel-box">
      <h3>Next</h3>
      <canvas class="next-canvas" id="next-canvas" width="120" height="240"></canvas>
    </div>
    <div class="panel-box">
      <h3>Stats</h3>
      <div class="stat-row"><span class="stat-label">Score</span><span class="stat-value" id="score-val">0</span></div>
      <div class="stat-row"><span class="stat-label">High</span><span class="stat-value" id="high-score-val">0</span></div>
      <div class="stat-row"><span class="stat-label">Level</span><span class="stat-value" id="level-val">1</span></div>
      <div class="stat-row"><span class="stat-label">Lines</span><span class="stat-value" id="lines-val">0</span></div>
      <div class="stat-row"><span class="stat-label">Combo</span><span class="stat-value" id="combo-val">0</span></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// EL PADRE'S TETRIS - Complete Implementation
// ============================================================

(() => {
'use strict';

// --- Constants ---
const COLS = 10;
const ROWS = 20;
const HIDDEN_ROWS = 4; // Extra rows above visible area
const TOTAL_ROWS = ROWS + HIDDEN_ROWS;
const CELL = 30;
const BOARD_W = COLS * CELL;
const BOARD_H = ROWS * CELL;

// Piece definitions (SRS standard)
const PIECES = {
  I: { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00e5ff' },
  O: { shape: [[1,1],[1,1]], color: '#ffe44d' },
  T: { shape: [[0,1,0],[1,1,1],[0,0,0]], color: '#b44dff' },
  S: { shape: [[0,1,1],[1,1,0],[0,0,0]], color: '#39ff14' },
  Z: { shape: [[1,1,0],[0,1,1],[0,0,0]], color: '#ff3355' },
  J: { shape: [[1,0,0],[1,1,1],[0,0,0]], color: '#4d8bff' },
  L: { shape: [[0,0,1],[1,1,1],[0,0,0]], color: '#ff9500' }
};

const PIECE_NAMES = ['I','O','T','S','Z','J','L'];

// SRS Wall Kick Data
const WALL_KICKS = {
  // state transitions for J,L,S,T,Z
  '0>1': [[ 0, 0],[-1, 0],[-1, 1],[ 0,-2],[-1,-2]],
  '1>0': [[ 0, 0],[ 1, 0],[ 1,-1],[ 0, 2],[ 1, 2]],
  '1>2': [[ 0, 0],[ 1, 0],[ 1,-1],[ 0, 2],[ 1, 2]],
  '2>1': [[ 0, 0],[-1, 0],[-1, 1],[ 0,-2],[-1,-2]],
  '2>3': [[ 0, 0],[ 1, 0],[ 1, 1],[ 0,-2],[ 1,-2]],
  '3>2': [[ 0, 0],[-1, 0],[-1,-1],[ 0, 2],[-1, 2]],
  '3>0': [[ 0, 0],[-1, 0],[-1,-1],[ 0, 2],[-1, 2]],
  '0>3': [[ 0, 0],[ 1, 0],[ 1, 1],[ 0,-2],[ 1,-2]]
};

const I_WALL_KICKS = {
  '0>1': [[ 0, 0],[-2, 0],[ 1, 0],[-2,-1],[ 1, 2]],
  '1>0': [[ 0, 0],[ 2, 0],[-1, 0],[ 2, 1],[-1,-2]],
  '1>2': [[ 0, 0],[-1, 0],[ 2, 0],[-1, 2],[ 2,-1]],
  '2>1': [[ 0, 0],[ 1, 0],[-2, 0],[ 1,-2],[-2, 1]],
  '2>3': [[ 0, 0],[ 2, 0],[-1, 0],[ 2, 1],[-1,-2]],
  '3>2': [[ 0, 0],[-2, 0],[ 1, 0],[-2,-1],[ 1, 2]],
  '3>0': [[ 0, 0],[ 1, 0],[-2, 0],[ 1,-2],[-2, 1]],
  '0>3': [[ 0, 0],[-1, 0],[ 2, 0],[-1, 2],[ 2,-1]]
};

// Speed curve (ms per drop) by level
function getDropInterval(level) {
  // Standard Tetris speed curve (frames at 60fps converted to ms)
  const frames = [48,43,38,33,28,23,18,13,8,6,5,5,5,4,4,4,3,3,3,2,2,2,2,2,2,2,2,2,2,1];
  const idx = Math.min(level - 1, frames.length - 1);
  return frames[idx] * (1000 / 60);
}

// DAS settings
const DAS_DELAY = 170; // ms before auto-repeat starts
const DAS_REPEAT = 50;  // ms between repeats
const LOCK_DELAY = 500; // ms
const LOCK_MOVES_MAX = 15;
const SOFT_DROP_FACTOR = 20; // multiplier on drop speed

// --- State ---
let board = [];
let currentPiece = null;
let holdPiece = null;
let holdUsed = false;
let bag = [];
let nextQueue = [];
let score = 0;
let highScore = 0;
let level = 1;
let lines = 0;
let combo = -1;
let maxCombo = 0;

// --- Leaderboard (top 10, shared via server) ---
const LB_KEY = 'elpadre_tetris_leaderboard';
const LB_NAME_KEY = 'elpadre_tetris_name';
const LB_MAX = 10;
const LB_SEED = [{name:'EL PADRE',score:80776,level:11,lines:103,combo:4,date:'2026-02-09'}];

// API base — works both when served from spr-launcher (:9000) or standalone
const API_BASE = (() => {
  // If we're served from port 9000, use relative paths
  if (location.port === '9000') return '';
  // Otherwise try localhost:9000
  return 'http://localhost:9000';
})();

let cachedServerLB = null; // last fetched server leaderboard

function getPlayerName() {
  const input = document.getElementById('player-name-input');
  const stored = localStorage.getItem(LB_NAME_KEY) || '';
  if (input && !input.value && stored) input.value = stored;
  return (input && input.value.trim()) || stored || '???';
}

function savePlayerName(name) {
  try { localStorage.setItem(LB_NAME_KEY, name); } catch(e) {}
  const input = document.getElementById('player-name-input');
  if (input && !input.value) input.value = name;
}

function loadLeaderboard() {
  // If we have server data cached, prefer that
  if (cachedServerLB && cachedServerLB.length > 0) return cachedServerLB;
  try {
    const raw = localStorage.getItem(LB_KEY);
    if (raw) {
      const lb = JSON.parse(raw);
      if (Array.isArray(lb) && lb.length > 0) return lb;
    }
  } catch(e) {}
  saveLeaderboard(LB_SEED);
  return [...LB_SEED];
}

function saveLeaderboard(lb) {
  try { localStorage.setItem(LB_KEY, JSON.stringify(lb)); } catch(e) {}
}

async function fetchLeaderboard() {
  try {
    const res = await fetch(`${API_BASE}/api/tetris-leaderboard`);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    if (data.success && Array.isArray(data.leaderboard)) {
      cachedServerLB = data.leaderboard;
      saveLeaderboard(data.leaderboard);
      return data.leaderboard;
    }
  } catch(e) {
    // Server unreachable — fall back to localStorage
  }
  return loadLeaderboard();
}

async function submitScore(s, lv, ln, cmb) {
  const name = getPlayerName();
  savePlayerName(name);
  const entry = { name, score: s, level: lv, lines: ln, combo: cmb };
  try {
    const res = await fetch(`${API_BASE}/api/tetris-leaderboard`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(entry)
    });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    if (data.success && Array.isArray(data.leaderboard)) {
      cachedServerLB = data.leaderboard;
      saveLeaderboard(data.leaderboard);
      return data.rank;
    }
  } catch(e) {
    // Server unreachable — save locally only
  }
  return addToLeaderboardLocal(s, lv, ln, cmb, name);
}

function addToLeaderboardLocal(s, lv, ln, cmb, name) {
  const lb = loadLeaderboard();
  const entry = {name: name || '???', score:s, level:lv, lines:ln, combo:cmb, date:new Date().toISOString().slice(0,10)};
  lb.push(entry);
  lb.sort((a,b) => b.score - a.score);
  while (lb.length > LB_MAX) lb.pop();
  saveLeaderboard(lb);
  return lb.findIndex(e => e === entry);
}

function addToLeaderboard(s, lv, ln, cmb) {
  // This is now async — we call submitScore and return a promise
  return submitScore(s, lv, ln, cmb);
}

function renderLeaderboard(newRank) {
  const lb = loadLeaderboard();
  let html = '<h4>Top Scores</h4>';
  lb.forEach((e, i) => {
    const isNew = i === newRank;
    const name = e.name || '???';
    html += `<div class="lb-row ${isNew ? 'lb-new' : ''}">
      <span class="lb-rank">#${i+1}</span>
      <span class="lb-score">${e.score.toLocaleString()}</span>
      <span class="lb-detail">${name} · Lv${e.level} · ${e.lines}L</span>
    </div>`;
  });
  document.getElementById('leaderboard').innerHTML = html;
}

function renderFullLeaderboard() {
  const lb = loadLeaderboard();
  let html = `<div class="lb-full-row lb-header">
    <span class="lb-f-rank">#</span>
    <span class="lb-f-name">Name</span>
    <span class="lb-f-score">Score</span>
    <span class="lb-f-level">Lvl</span>
    <span class="lb-f-lines">Lines</span>
    <span class="lb-f-date">Date</span>
  </div>`;
  lb.forEach((e, i) => {
    const name = e.name || '???';
    html += `<div class="lb-full-row">
      <span class="lb-f-rank">${i+1}</span>
      <span class="lb-f-name">${name}</span>
      <span class="lb-f-score">${e.score.toLocaleString()}</span>
      <span class="lb-f-level">${e.level}</span>
      <span class="lb-f-lines">${e.lines}</span>
      <span class="lb-f-date">${e.date || ''}</span>
    </div>`;
  });
  document.getElementById('lb-full-table').innerHTML = html;
}

function openLeaderboard() {
  fetchLeaderboard().then(() => {
    renderFullLeaderboard();
    document.getElementById('leaderboard-overlay').classList.remove('hidden');
    gameState = 'leaderboard';
  });
}

function closeLeaderboard() {
  document.getElementById('leaderboard-overlay').classList.add('hidden');
  gameState = _returnFromLeaderboard || 'title';
}

let _returnFromLeaderboard = 'title';
// Expose for inline onclick
window._openLeaderboard = () => {
  _returnFromLeaderboard = gameState;
  openLeaderboard();
};
let backToBack = false;
let gameState = 'title'; // title, playing, paused, gameover
let dropTimer = 0;
let lockTimer = 0;
let lockMoves = 0;
let isLocking = false;
let lastTime = 0;
let animFrame = 0;

// DAS state
let keysDown = {};
let dasDirection = 0; // -1, 0, 1
let dasTimer = 0;
let dasActive = false;

// Animations
let clearingLines = [];
let clearAnimTimer = 0;
const CLEAR_ANIM_DURATION = 400;
let particles = [];
let floatingTexts = [];
let hardDropTrails = [];
let landingFlashes = [];
let boardShake = { x: 0, y: 0, timer: 0 };
let borderPulse = 0;

// Canvas refs
let gameCanvas, gameCtx;
let holdCanvas, holdCtx;
let nextCanvas, nextCtx;
let bgCanvas, bgCtx;
let titleCanvas, titleCtx;

// Background grid
let bgGridOffset = 0;

// Title screen pieces
let titlePieces = [];

// --- Initialization ---
function init() {
  gameCanvas = document.getElementById('game-canvas');
  gameCtx = gameCanvas.getContext('2d');
  gameCanvas.width = BOARD_W;
  gameCanvas.height = BOARD_H;

  holdCanvas = document.getElementById('hold-canvas');
  holdCtx = holdCanvas.getContext('2d');

  nextCanvas = document.getElementById('next-canvas');
  nextCtx = nextCanvas.getContext('2d');

  bgCanvas = document.getElementById('bg-canvas');
  bgCtx = bgCanvas.getContext('2d');
  resizeBg();

  titleCanvas = document.getElementById('title-canvas');
  titleCtx = titleCanvas.getContext('2d');
  resizeTitle();

  // Load player name from localStorage
  const savedName = localStorage.getItem(LB_NAME_KEY) || '';
  const nameInput = document.getElementById('player-name-input');
  if (nameInput && savedName) nameInput.value = savedName;
  // Save name on change
  if (nameInput) {
    nameInput.addEventListener('change', () => {
      const n = nameInput.value.trim();
      if (n) savePlayerName(n);
    });
  }

  // Wire up leaderboard back button
  document.getElementById('lb-back-btn').addEventListener('click', closeLeaderboard);

  // Load high score from leaderboard (local first, then fetch from server)
  const lb = loadLeaderboard();
  highScore = lb.length > 0 ? lb[0].score : 0;

  // Pre-fetch server leaderboard in background
  fetchLeaderboard().then(serverLB => {
    if (serverLB.length > 0 && serverLB[0].score > highScore) {
      highScore = serverLB[0].score;
    }
    updateHUD();
  });

  updateHUD();
  window.addEventListener('resize', () => { resizeBg(); resizeTitle(); scaleGame(); });
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  scaleGame();
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function resizeBg() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}

function resizeTitle() {
  titleCanvas.width = window.innerWidth;
  titleCanvas.height = window.innerHeight;
}

function scaleGame() {
  const wrapper = document.getElementById('game-wrapper');
  if (!wrapper) return;
  const totalW = 180 + 20 + BOARD_W + 20 + 180; // panels + gaps + board
  const totalH = BOARD_H + 20;
  const scaleX = (window.innerWidth - 40) / totalW;
  const scaleY = (window.innerHeight - 40) / totalH;
  const s = Math.min(scaleX, scaleY, 1.2);
  wrapper.style.transform = `scale(${s})`;
}

// --- Board ---
function createBoard() {
  board = [];
  for (let r = 0; r < TOTAL_ROWS; r++) {
    board.push(new Array(COLS).fill(null));
  }
}

function isValidPosition(shape, px, py) {
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        const bx = px + c;
        const by = py + r;
        if (bx < 0 || bx >= COLS || by >= TOTAL_ROWS) return false;
        if (by >= 0 && board[by][bx]) return false;
      }
    }
  }
  return true;
}

// --- Piece Management ---
function rotateCW(shape) {
  const n = shape.length;
  const result = [];
  for (let r = 0; r < n; r++) {
    result.push([]);
    for (let c = 0; c < n; c++) {
      result[r].push(shape[n - 1 - c][r]);
    }
  }
  return result;
}

function rotateCCW(shape) {
  const n = shape.length;
  const result = [];
  for (let r = 0; r < n; r++) {
    result.push([]);
    for (let c = 0; c < n; c++) {
      result[r].push(shape[c][n - 1 - r]);
    }
  }
  return result;
}

function fillBag() {
  const arr = [...PIECE_NAMES];
  // Fisher-Yates shuffle
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function getNextPiece() {
  while (nextQueue.length < 4) {
    if (bag.length === 0) bag = fillBag();
    nextQueue.push(bag.shift());
  }
  const name = nextQueue.shift();
  // Ensure queue stays filled
  if (bag.length === 0) bag = fillBag();
  nextQueue.push(bag.shift());
  return createPiece(name);
}

function createPiece(name) {
  const def = PIECES[name];
  const shape = def.shape.map(r => [...r]);
  const px = Math.floor((COLS - shape[0].length) / 2);
  const py = HIDDEN_ROWS - 2; // Spawn above visible area
  return {
    name, shape, color: def.color,
    x: px, y: py,
    rotation: 0
  };
}

function spawnPiece() {
  currentPiece = getNextPiece();
  holdUsed = false;
  isLocking = false;
  lockTimer = 0;
  lockMoves = 0;

  if (!isValidPosition(currentPiece.shape, currentPiece.x, currentPiece.y)) {
    // Try one row up
    currentPiece.y--;
    if (!isValidPosition(currentPiece.shape, currentPiece.x, currentPiece.y)) {
      gameOver();
      return false;
    }
  }
  return true;
}

// --- Movement ---
function movePiece(dx, dy) {
  if (!currentPiece) return false;
  if (isValidPosition(currentPiece.shape, currentPiece.x + dx, currentPiece.y + dy)) {
    currentPiece.x += dx;
    currentPiece.y += dy;
    if (dy === 0) resetLockIfNeeded();
    return true;
  }
  return false;
}

function resetLockIfNeeded() {
  if (isLocking && lockMoves < LOCK_MOVES_MAX) {
    lockTimer = 0;
    lockMoves++;
  }
}

function tryRotate(dir) {
  if (!currentPiece || currentPiece.name === 'O') return false;

  const oldRotation = currentPiece.rotation;
  const newRotation = (oldRotation + dir + 4) % 4;
  const newShape = dir === 1 ? rotateCW(currentPiece.shape) : rotateCCW(currentPiece.shape);

  const kickKey = `${oldRotation}>${newRotation}`;
  const kicks = currentPiece.name === 'I' ? I_WALL_KICKS[kickKey] : WALL_KICKS[kickKey];

  if (!kicks) return false;

  for (const [kx, ky] of kicks) {
    if (isValidPosition(newShape, currentPiece.x + kx, currentPiece.y - ky)) {
      currentPiece.shape = newShape;
      currentPiece.x += kx;
      currentPiece.y -= ky;
      currentPiece.rotation = newRotation;
      currentPiece.lastAction = 'rotate';
      currentPiece.lastKick = [kx, -ky];
      resetLockIfNeeded();
      return true;
    }
  }
  return false;
}

function hardDrop() {
  if (!currentPiece) return;
  let dropDist = 0;
  while (isValidPosition(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
    currentPiece.y++;
    dropDist++;
  }
  score += dropDist * 2;

  // Create hard drop trail
  createHardDropTrail(currentPiece);

  lockPiece();
}

function getGhostY() {
  if (!currentPiece) return 0;
  let gy = currentPiece.y;
  while (isValidPosition(currentPiece.shape, currentPiece.x, gy + 1)) {
    gy++;
  }
  return gy;
}

function softDrop() {
  if (movePiece(0, 1)) {
    score += 1;
    return true;
  }
  return false;
}

// --- Lock & Clear ---
function lockPiece() {
  if (!currentPiece) return;

  const shape = currentPiece.shape;
  const px = currentPiece.x;
  const py = currentPiece.y;
  const isTSpin = detectTSpin();

  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        const bx = px + c;
        const by = py + r;
        if (by >= 0 && by < TOTAL_ROWS && bx >= 0 && bx < COLS) {
          board[by][bx] = currentPiece.color;
        }
      }
    }
  }

  // Landing flash
  createLandingFlash(currentPiece);

  currentPiece = null;
  isLocking = false;
  lockTimer = 0;
  lockMoves = 0;

  // Check for line clears
  const fullLines = [];
  for (let r = 0; r < TOTAL_ROWS; r++) {
    if (board[r].every(cell => cell !== null)) {
      fullLines.push(r);
    }
  }

  if (fullLines.length > 0) {
    startLineClear(fullLines, isTSpin);
  } else {
    combo = -1;
    backToBack = false;
    spawnPiece();
  }
}

function detectTSpin() {
  if (!currentPiece || currentPiece.name !== 'T') return false;
  if (currentPiece.lastAction !== 'rotate') return false;

  // Check 4 corners of the T piece's 3x3 bounding box
  const cx = currentPiece.x;
  const cy = currentPiece.y;
  const corners = [[cx, cy], [cx+2, cy], [cx, cy+2], [cx+2, cy+2]];
  let filled = 0;
  for (const [x, y] of corners) {
    if (x < 0 || x >= COLS || y < 0 || y >= TOTAL_ROWS || (y >= 0 && board[y] && board[y][x])) {
      filled++;
    }
  }
  return filled >= 3;
}

function startLineClear(lineRows, isTSpin) {
  clearingLines = lineRows;
  clearAnimTimer = CLEAR_ANIM_DURATION;

  // Create particles for cleared lines
  for (const row of lineRows) {
    for (let c = 0; c < COLS; c++) {
      const color = board[row][c] || '#fff';
      const screenY = (row - HIDDEN_ROWS) * CELL;
      const screenX = c * CELL;
      for (let i = 0; i < 4; i++) {
        particles.push({
          x: screenX + CELL/2 + (Math.random()-0.5)*CELL,
          y: screenY + CELL/2 + (Math.random()-0.5)*CELL,
          vx: (Math.random()-0.5) * 6,
          vy: -Math.random() * 4 - 2,
          color: color,
          life: 1,
          size: Math.random() * 4 + 2
        });
      }
    }
  }

  // Scoring
  const n = lineRows.length;
  combo++;
  if (combo > maxCombo) maxCombo = combo;

  let lineScore = 0;
  let specialText = '';
  let specialColor = '#fff';
  let isSpecial = false;

  if (isTSpin) {
    if (n === 1) { lineScore = 800; specialText = 'T-SPIN SINGLE!'; }
    else if (n === 2) { lineScore = 1200; specialText = 'T-SPIN DOUBLE!'; }
    else if (n === 3) { lineScore = 1600; specialText = 'T-SPIN TRIPLE!'; }
    specialColor = '#b44dff';
    isSpecial = true;
  } else {
    if (n === 1) lineScore = 100;
    else if (n === 2) lineScore = 300;
    else if (n === 3) lineScore = 500;
    else if (n === 4) { lineScore = 800; specialText = 'TETRIS!'; specialColor = '#00e5ff'; isSpecial = true; }
  }

  // Back-to-back bonus
  if (isSpecial) {
    if (backToBack) {
      lineScore = Math.floor(lineScore * 1.5);
      specialText = 'B2B ' + specialText;
    }
    backToBack = true;
  } else if (n > 0) {
    backToBack = false;
  }

  // Combo bonus
  let comboBonus = 0;
  if (combo > 0) {
    comboBonus = 50 * combo * level;
  }

  lineScore *= level;
  score += lineScore + comboBonus;

  // Update lines and level
  lines += n;
  const newLevel = Math.floor(lines / 10) + 1;
  if (newLevel > level) {
    level = newLevel;
    showFloatingText('LEVEL UP!', '#39ff14', 28);
  }

  // Check high score (live update during game)
  if (score > highScore) {
    highScore = score;
  }

  // Show special text
  if (specialText) {
    showFloatingText(specialText, specialColor, n === 4 ? 36 : 24);
    if (n === 4 || isTSpin) {
      triggerScreenFlash();
      triggerBoardShake(n === 4 ? 8 : 4);
    }
  }

  if (combo > 0) {
    showFloatingText(`COMBO x${combo + 1}!`, '#ffe44d', 18);
  }

  updateHUD();
}

function finishLineClear() {
  // Remove cleared lines and add empty ones on top
  clearingLines.sort((a, b) => a - b);
  for (let i = clearingLines.length - 1; i >= 0; i--) {
    board.splice(clearingLines[i], 1);
    board.unshift(new Array(COLS).fill(null));
  }
  clearingLines = [];
  clearAnimTimer = 0;
  spawnPiece();
}

// --- Hold ---
function doHold() {
  if (!currentPiece || holdUsed) return;
  holdUsed = true;

  const name = currentPiece.name;
  if (holdPiece) {
    currentPiece = createPiece(holdPiece);
    holdPiece = name;
  } else {
    holdPiece = name;
    spawnPiece();
  }
  isLocking = false;
  lockTimer = 0;
  lockMoves = 0;
}

// --- Game States ---
function startGame() {
  createBoard();
  bag = fillBag();
  nextQueue = [];
  currentPiece = null;
  holdPiece = null;
  holdUsed = false;
  score = 0;
  level = 1;
  lines = 0;
  combo = -1;
  maxCombo = 0;
  backToBack = false;
  dropTimer = 0;
  particles = [];
  floatingTexts = [];
  hardDropTrails = [];
  landingFlashes = [];
  clearingLines = [];
  clearAnimTimer = 0;
  keysDown = {};
  dasDirection = 0;
  dasTimer = 0;
  dasActive = false;

  // Save player name before starting
  const pName = getPlayerName();
  if (pName && pName !== '???') savePlayerName(pName);

  gameState = 'playing';
  document.getElementById('title-overlay').classList.add('hidden');
  document.getElementById('gameover-overlay').classList.add('hidden');
  document.getElementById('pause-overlay').classList.add('hidden');
  document.getElementById('leaderboard-overlay').classList.add('hidden');
  document.getElementById('game-wrapper').style.display = 'flex';
  scaleGame();
  updateHUD();
  spawnPiece();
}

function gameOver() {
  gameState = 'gameover';

  const comboVal = maxCombo > 0 ? maxCombo + 1 : 0;
  const isNewHigh = score >= highScore && score > 0;

  const statsDiv = document.getElementById('go-stats');
  statsDiv.innerHTML = `
    <div class="go-stat">SCORE: <em>${score.toLocaleString()}</em></div>
    <div class="go-stat">LEVEL: <em>${level}</em></div>
    <div class="go-stat">LINES: <em>${lines}</em></div>
    <div class="go-stat">MAX COMBO: <em>${comboVal}x</em></div>
  `;

  const nhEl = document.getElementById('new-high-indicator');
  if (isNewHigh && score > 0) nhEl.classList.remove('hidden');
  else nhEl.classList.add('hidden');

  // Show overlay immediately with local data, then update when server responds
  renderLeaderboard(-1);
  document.getElementById('gameover-overlay').classList.remove('hidden');

  // Submit score async and refresh leaderboard when done
  if (score > 0) {
    addToLeaderboard(score, level, lines, comboVal).then(newRank => {
      const lb = loadLeaderboard();
      highScore = lb.length > 0 ? lb[0].score : highScore;
      renderLeaderboard(newRank);
    });
  }
}

function togglePause() {
  if (gameState === 'playing') {
    gameState = 'paused';
    document.getElementById('pause-overlay').classList.remove('hidden');
  } else if (gameState === 'paused') {
    gameState = 'playing';
    document.getElementById('pause-overlay').classList.add('hidden');
    lastTime = performance.now();
  }
}

// --- Input ---
function onKeyDown(e) {
  // Don't capture keys while typing in the name input
  if (document.activeElement && document.activeElement.id === 'player-name-input') {
    if (e.key === 'Enter') {
      document.activeElement.blur();
      e.preventDefault();
    }
    return;
  }

  if (e.repeat && (e.key === 'ArrowUp' || e.key === 'z' || e.key === 'Z' ||
                    e.key === ' ' || e.key === 'c' || e.key === 'C')) return;

  const key = e.key;

  // Leaderboard overlay controls
  if (gameState === 'leaderboard') {
    if (key === 'Escape' || key === 'l' || key === 'L') {
      closeLeaderboard();
      e.preventDefault();
    }
    return;
  }

  // Open leaderboard from title or gameover
  if ((key === 'l' || key === 'L') && (gameState === 'title' || gameState === 'gameover')) {
    _returnFromLeaderboard = gameState;
    openLeaderboard();
    e.preventDefault();
    return;
  }

  if (key === 'Enter') {
    if (gameState === 'title' || gameState === 'gameover') {
      startGame();
      e.preventDefault();
      return;
    }
  }

  if (key === 'Escape') {
    if (gameState === 'playing' || gameState === 'paused') {
      togglePause();
      e.preventDefault();
      return;
    }
  }

  if (key === 'p' || key === 'P') {
    if (gameState === 'playing' || gameState === 'paused') {
      togglePause();
      e.preventDefault();
      return;
    }
  }

  if (gameState !== 'playing' || clearingLines.length > 0) return;

  keysDown[key] = true;

  switch(key) {
    case 'ArrowLeft':
      if (movePiece(-1, 0)) {
        dasDirection = -1;
        dasTimer = 0;
        dasActive = false;
      }
      if (currentPiece) currentPiece.lastAction = 'move';
      e.preventDefault();
      break;
    case 'ArrowRight':
      if (movePiece(1, 0)) {
        dasDirection = 1;
        dasTimer = 0;
        dasActive = false;
      }
      if (currentPiece) currentPiece.lastAction = 'move';
      e.preventDefault();
      break;
    case 'ArrowDown':
      softDrop();
      if (currentPiece) currentPiece.lastAction = 'move';
      e.preventDefault();
      break;
    case 'ArrowUp':
      tryRotate(1);
      e.preventDefault();
      break;
    case 'z':
    case 'Z':
      tryRotate(-1);
      e.preventDefault();
      break;
    case ' ':
      hardDrop();
      e.preventDefault();
      break;
    case 'c':
    case 'C':
      doHold();
      e.preventDefault();
      break;
  }
}

function onKeyUp(e) {
  delete keysDown[e.key];

  if (e.key === 'ArrowLeft' && dasDirection === -1) {
    dasDirection = 0;
    dasTimer = 0;
    dasActive = false;
    // Check if right is still held
    if (keysDown['ArrowRight']) {
      dasDirection = 1;
      dasTimer = 0;
    }
  }
  if (e.key === 'ArrowRight' && dasDirection === 1) {
    dasDirection = 0;
    dasTimer = 0;
    dasActive = false;
    if (keysDown['ArrowLeft']) {
      dasDirection = -1;
      dasTimer = 0;
    }
  }
}

// --- HUD ---
function updateHUD() {
  document.getElementById('score-val').textContent = score.toLocaleString();
  document.getElementById('high-score-val').textContent = highScore.toLocaleString();
  document.getElementById('level-val').textContent = level;
  document.getElementById('lines-val').textContent = lines;
  document.getElementById('combo-val').textContent = combo > 0 ? (combo + 1) + 'x' : '0';
}

// --- Visual Effects ---
function showFloatingText(text, color, size) {
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  el.style.color = color;
  el.style.fontSize = size + 'px';

  // Position near the board center
  const boardRect = document.getElementById('board-container').getBoundingClientRect();
  el.style.left = (boardRect.left + boardRect.width/2) + 'px';
  el.style.top = (boardRect.top + boardRect.height/3 + Math.random() * 60) + 'px';
  el.style.transform = 'translateX(-50%)';

  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1300);
}

function triggerScreenFlash() {
  const el = document.createElement('div');
  el.className = 'screen-flash';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function triggerBoardShake(intensity) {
  boardShake.timer = 400;
  boardShake.intensity = intensity;
}

function createHardDropTrail(piece) {
  const ghostY = getGhostY();
  const shape = piece.shape;
  for (let c = 0; c < shape[0].length; c++) {
    // Find topmost filled cell in this column
    let topR = -1;
    for (let r = 0; r < shape.length; r++) {
      if (shape[r][c]) { topR = r; break; }
    }
    if (topR >= 0) {
      const sx = (piece.x + c) * CELL + CELL/2;
      const startY = (piece.y + topR - HIDDEN_ROWS) * CELL;
      const endY = (ghostY + topR - HIDDEN_ROWS) * CELL;
      if (endY > startY) {
        hardDropTrails.push({
          x: sx, startY, endY, life: 1, color: piece.color
        });
      }
    }
  }
}

function createLandingFlash(piece) {
  const shape = piece.shape;
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        landingFlashes.push({
          x: (piece.x + c) * CELL,
          y: (piece.y + r - HIDDEN_ROWS) * CELL,
          life: 1
        });
      }
    }
  }
}

// --- Background ---
function drawBackground(dt) {
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

  bgGridOffset += dt * 0.015;
  if (bgGridOffset > 40) bgGridOffset -= 40;

  bgCtx.strokeStyle = 'rgba(0, 229, 255, 0.04)';
  bgCtx.lineWidth = 1;

  const spacing = 40;
  for (let x = -spacing + (bgGridOffset % spacing); x < bgCanvas.width + spacing; x += spacing) {
    bgCtx.beginPath();
    bgCtx.moveTo(x, 0);
    bgCtx.lineTo(x, bgCanvas.height);
    bgCtx.stroke();
  }
  for (let y = -spacing + (bgGridOffset % spacing); y < bgCanvas.height + spacing; y += spacing) {
    bgCtx.beginPath();
    bgCtx.moveTo(0, y);
    bgCtx.lineTo(bgCanvas.width, y);
    bgCtx.stroke();
  }
}

// --- Title Screen ---
function updateTitlePieces(dt) {
  // Spawn pieces occasionally
  if (Math.random() < dt * 0.002) {
    const name = PIECE_NAMES[Math.floor(Math.random() * PIECE_NAMES.length)];
    const def = PIECES[name];
    titlePieces.push({
      shape: def.shape,
      color: def.color,
      x: Math.random() * titleCanvas.width,
      y: -60,
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 2,
      vy: 30 + Math.random() * 40,
      size: 8 + Math.random() * 6,
      alpha: 0.3 + Math.random() * 0.3
    });
  }

  for (let i = titlePieces.length - 1; i >= 0; i--) {
    const p = titlePieces[i];
    p.y += p.vy * dt / 1000;
    p.rot += p.rotSpeed * dt / 1000;
    if (p.y > titleCanvas.height + 100) {
      titlePieces.splice(i, 1);
    }
  }
}

function drawTitlePieces() {
  titleCtx.clearRect(0, 0, titleCanvas.width, titleCanvas.height);
  for (const p of titlePieces) {
    titleCtx.save();
    titleCtx.globalAlpha = p.alpha;
    titleCtx.translate(p.x, p.y);
    titleCtx.rotate(p.rot);
    for (let r = 0; r < p.shape.length; r++) {
      for (let c = 0; c < p.shape[r].length; c++) {
        if (p.shape[r][c]) {
          const bx = (c - p.shape[0].length/2) * p.size;
          const by = (r - p.shape.length/2) * p.size;
          titleCtx.fillStyle = p.color;
          titleCtx.fillRect(bx, by, p.size - 1, p.size - 1);
        }
      }
    }
    titleCtx.restore();
  }
}

// --- Rendering ---
function drawBlock(ctx, x, y, color, alpha = 1) {
  ctx.globalAlpha = alpha;

  // Main block
  ctx.fillStyle = color;
  ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);

  // Highlight (top-left bevel)
  const lighter = lightenColor(color, 40);
  ctx.fillStyle = lighter;
  ctx.fillRect(x + 1, y + 1, CELL - 2, 3);
  ctx.fillRect(x + 1, y + 1, 3, CELL - 2);

  // Shadow (bottom-right bevel)
  const darker = darkenColor(color, 40);
  ctx.fillStyle = darker;
  ctx.fillRect(x + 1, y + CELL - 4, CELL - 2, 3);
  ctx.fillRect(x + CELL - 4, y + 1, 3, CELL - 2);

  // Inner glow
  ctx.fillStyle = lightenColor(color, 20);
  ctx.fillRect(x + 4, y + 4, CELL - 8, CELL - 8);

  // Subtle center shine
  ctx.fillStyle = lightenColor(color, 60);
  ctx.globalAlpha = alpha * 0.3;
  ctx.fillRect(x + 6, y + 4, CELL - 12, 3);
  ctx.globalAlpha = alpha;
}

function lightenColor(hex, amt) {
  let r = parseInt(hex.slice(1,3), 16);
  let g = parseInt(hex.slice(3,5), 16);
  let b = parseInt(hex.slice(5,7), 16);
  r = Math.min(255, r + amt);
  g = Math.min(255, g + amt);
  b = Math.min(255, b + amt);
  return `rgb(${r},${g},${b})`;
}

function darkenColor(hex, amt) {
  let r = parseInt(hex.slice(1,3), 16);
  let g = parseInt(hex.slice(3,5), 16);
  let b = parseInt(hex.slice(5,7), 16);
  r = Math.max(0, r - amt);
  g = Math.max(0, g - amt);
  b = Math.max(0, b - amt);
  return `rgb(${r},${g},${b})`;
}

function drawBoard() {
  gameCtx.clearRect(0, 0, BOARD_W, BOARD_H);

  // Grid lines
  gameCtx.strokeStyle = 'rgba(50, 50, 100, 0.2)';
  gameCtx.lineWidth = 0.5;
  for (let c = 1; c < COLS; c++) {
    gameCtx.beginPath();
    gameCtx.moveTo(c * CELL, 0);
    gameCtx.lineTo(c * CELL, BOARD_H);
    gameCtx.stroke();
  }
  for (let r = 1; r < ROWS; r++) {
    gameCtx.beginPath();
    gameCtx.moveTo(0, r * CELL);
    gameCtx.lineTo(BOARD_W, r * CELL);
    gameCtx.stroke();
  }

  // Draw placed blocks
  for (let r = HIDDEN_ROWS; r < TOTAL_ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) {
        const screenR = r - HIDDEN_ROWS;
        // Check if this row is being cleared
        if (clearingLines.includes(r)) {
          const progress = 1 - clearAnimTimer / CLEAR_ANIM_DURATION;
          if (progress < 0.5) {
            // Flash white
            gameCtx.globalAlpha = 1;
            gameCtx.fillStyle = `rgba(255, 255, 255, ${1 - progress * 2})`;
            gameCtx.fillRect(c * CELL, screenR * CELL, CELL, CELL);
            drawBlock(gameCtx, c * CELL, screenR * CELL, board[r][c], 1 - progress);
          } else {
            // Dissolve
            const dissolve = (progress - 0.5) * 2;
            drawBlock(gameCtx, c * CELL, screenR * CELL, board[r][c], 1 - dissolve);
          }
        } else {
          drawBlock(gameCtx, c * CELL, screenR * CELL, board[r][c]);
        }
      }
    }
  }
  gameCtx.globalAlpha = 1;
}

function drawGhostPiece() {
  if (!currentPiece || clearingLines.length > 0) return;
  const ghostY = getGhostY();
  if (ghostY === currentPiece.y) return;

  const shape = currentPiece.shape;
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        const bx = (currentPiece.x + c) * CELL;
        const by = (ghostY + r - HIDDEN_ROWS) * CELL;
        if (by >= 0) {
          gameCtx.globalAlpha = 0.2;
          gameCtx.fillStyle = currentPiece.color;
          gameCtx.fillRect(bx + 1, by + 1, CELL - 2, CELL - 2);
          gameCtx.globalAlpha = 0.4;
          gameCtx.strokeStyle = currentPiece.color;
          gameCtx.lineWidth = 1;
          gameCtx.strokeRect(bx + 1, by + 1, CELL - 2, CELL - 2);
        }
      }
    }
  }
  gameCtx.globalAlpha = 1;
}

function drawCurrentPiece() {
  if (!currentPiece || clearingLines.length > 0) return;
  const shape = currentPiece.shape;
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        const bx = (currentPiece.x + c) * CELL;
        const by = (currentPiece.y + r - HIDDEN_ROWS) * CELL;
        if (by >= -CELL) {
          drawBlock(gameCtx, bx, by, currentPiece.color);
        }
      }
    }
  }
}

function drawMiniPiece(ctx, name, cx, cy, scale) {
  if (!name) return;
  const def = PIECES[name];
  const shape = def.shape;
  const s = scale || 16;

  // Center the piece
  let minC = shape[0].length, maxC = 0, minR = shape.length, maxR = 0;
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c]) {
        minC = Math.min(minC, c); maxC = Math.max(maxC, c);
        minR = Math.min(minR, r); maxR = Math.max(maxR, r);
      }
    }
  }

  const pw = (maxC - minC + 1) * s;
  const ph = (maxR - minR + 1) * s;
  const ox = cx - pw/2;
  const oy = cy - ph/2;

  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      if (shape[r][c]) {
        const bx = ox + (c - minC) * s;
        const by = oy + (r - minR) * s;
        ctx.fillStyle = def.color;
        ctx.fillRect(bx + 1, by + 1, s - 2, s - 2);
        // Mini bevel
        ctx.fillStyle = lightenColor(def.color, 30);
        ctx.fillRect(bx + 1, by + 1, s - 2, 2);
        ctx.fillRect(bx + 1, by + 1, 2, s - 2);
        ctx.fillStyle = darkenColor(def.color, 30);
        ctx.fillRect(bx + 1, by + s - 3, s - 2, 2);
        ctx.fillRect(bx + s - 3, by + 1, 2, s - 2);
      }
    }
  }
}

function drawHoldPanel() {
  holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
  if (holdPiece) {
    const alpha = holdUsed ? 0.4 : 1;
    holdCtx.globalAlpha = alpha;
    drawMiniPiece(holdCtx, holdPiece, holdCanvas.width/2, holdCanvas.height/2, 18);
    holdCtx.globalAlpha = 1;
  }
}

function drawNextPanel() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  for (let i = 0; i < Math.min(3, nextQueue.length); i++) {
    drawMiniPiece(nextCtx, nextQueue[i], nextCanvas.width/2, 40 + i * 75, 16);
  }
}

function drawEffects(dt) {
  // Hard drop trails
  for (let i = hardDropTrails.length - 1; i >= 0; i--) {
    const t = hardDropTrails[i];
    t.life -= dt / 200;
    if (t.life <= 0) { hardDropTrails.splice(i, 1); continue; }

    gameCtx.globalAlpha = t.life * 0.6;
    const grad = gameCtx.createLinearGradient(t.x, t.startY, t.x, t.endY);
    grad.addColorStop(0, 'transparent');
    grad.addColorStop(0.5, t.color);
    grad.addColorStop(1, 'transparent');
    gameCtx.strokeStyle = grad;
    gameCtx.lineWidth = 3;
    gameCtx.beginPath();
    gameCtx.moveTo(t.x, t.startY);
    gameCtx.lineTo(t.x, t.endY);
    gameCtx.stroke();
  }

  // Landing flashes
  for (let i = landingFlashes.length - 1; i >= 0; i--) {
    const f = landingFlashes[i];
    f.life -= dt / 300;
    if (f.life <= 0) { landingFlashes.splice(i, 1); continue; }
    gameCtx.globalAlpha = f.life * 0.5;
    gameCtx.fillStyle = '#fff';
    gameCtx.fillRect(f.x, f.y, CELL, CELL);
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15; // gravity
    p.life -= dt / 800;
    if (p.life <= 0) { particles.splice(i, 1); continue; }

    gameCtx.globalAlpha = p.life;
    gameCtx.fillStyle = p.color;
    gameCtx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  }

  gameCtx.globalAlpha = 1;
}

// --- Board shake ---
function updateBoardShake(dt) {
  if (boardShake.timer > 0) {
    boardShake.timer -= dt;
    const intensity = boardShake.intensity * (boardShake.timer / 400);
    boardShake.x = (Math.random() - 0.5) * intensity * 2;
    boardShake.y = (Math.random() - 0.5) * intensity * 2;
  } else {
    boardShake.x = 0;
    boardShake.y = 0;
  }

  const container = document.getElementById('board-container');
  if (container) {
    container.style.transform = `translate(${boardShake.x}px, ${boardShake.y}px)`;
  }
}

// --- Game Loop ---
function gameLoop(timestamp) {
  const dt = Math.min(timestamp - lastTime, 50); // Cap delta
  lastTime = timestamp;
  animFrame++;

  drawBackground(dt);

  if (gameState === 'title' || gameState === 'leaderboard') {
    updateTitlePieces(dt);
    drawTitlePieces();
  }

  if (gameState === 'playing') {
    update(dt);
    render(dt);
    updateBoardShake(dt);
    drawHoldPanel();
    drawNextPanel();
  } else if (gameState === 'paused') {
    render(0);
    drawHoldPanel();
    drawNextPanel();
  } else if (gameState === 'gameover') {
    render(dt);
    drawHoldPanel();
    drawNextPanel();
  }

  requestAnimationFrame(gameLoop);
}

function update(dt) {
  if (clearingLines.length > 0) {
    clearAnimTimer -= dt;
    if (clearAnimTimer <= 0) {
      finishLineClear();
    }
    return;
  }

  if (!currentPiece) return;

  // DAS (Delayed Auto Shift)
  if (dasDirection !== 0 && (keysDown['ArrowLeft'] || keysDown['ArrowRight'])) {
    dasTimer += dt;
    if (!dasActive && dasTimer >= DAS_DELAY) {
      dasActive = true;
      dasTimer = DAS_DELAY;
    }
    if (dasActive) {
      while (dasTimer >= DAS_DELAY + DAS_REPEAT) {
        movePiece(dasDirection, 0);
        if (currentPiece) currentPiece.lastAction = 'move';
        dasTimer -= DAS_REPEAT;
      }
    }
  }

  // Soft drop (held down)
  if (keysDown['ArrowDown']) {
    const softInterval = getDropInterval(level) / SOFT_DROP_FACTOR;
    dropTimer += dt;
    while (dropTimer >= softInterval) {
      if (!softDrop()) break;
      dropTimer -= softInterval;
    }
  } else {
    // Normal gravity
    dropTimer += dt;
    const interval = getDropInterval(level);
    while (dropTimer >= interval) {
      if (!movePiece(0, 1)) {
        // Can't move down - start/continue locking
        if (!isLocking) {
          isLocking = true;
          lockTimer = 0;
          lockMoves = 0;
        }
        dropTimer = 0;
        break;
      } else {
        isLocking = false;
        lockTimer = 0;
      }
      dropTimer -= interval;
    }
  }

  // Lock delay
  if (isLocking) {
    // Check if piece can still fall (maybe a line was cleared beneath)
    if (isValidPosition(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
      isLocking = false;
      lockTimer = 0;
    } else {
      lockTimer += dt;
      if (lockTimer >= LOCK_DELAY || lockMoves >= LOCK_MOVES_MAX) {
        lockPiece();
      }
    }
  }
}

function render(dt) {
  drawBoard();
  drawGhostPiece();
  drawCurrentPiece();
  drawEffects(dt);
  updateHUD();
}

// --- Border pulse ---
setInterval(() => {
  borderPulse = (borderPulse + 1) % 360;
  const container = document.getElementById('board-container');
  if (container) {
    const intensity = 0.2 + Math.sin(borderPulse * Math.PI / 180) * 0.15;
    container.style.boxShadow = `0 0 ${20 + intensity * 30}px rgba(0, 229, 255, ${intensity}), 0 0 ${40 + intensity * 40}px rgba(0, 229, 255, ${intensity * 0.5}), inset 0 0 30px rgba(0, 0, 0, 0.5)`;
  }
}, 50);

// --- Start ---
window.addEventListener('DOMContentLoaded', init);

})();
</script>
</body>
</html>
